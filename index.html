<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>DAGknight Protocol Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0A0E17;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #E0E0E0;
        }

        #app {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
        }

        /* Status overlay */
        #status {
            position: absolute;
            top: 16px;
            left: 16px;
            z-index: 100;
            background: rgba(10, 14, 23, 0.85);
            border: 1px solid rgba(74, 144, 217, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 13px;
            backdrop-filter: blur(8px);
            min-width: 200px;
        }

        #status .title {
            font-size: 16px;
            font-weight: 600;
            color: #4A90D9;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #status .title::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
            animation: pulse 2s infinite;
        }

        #status.connected .title::before {
            background: #00FF88;
        }

        #status .row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        #status .row:last-child {
            border-bottom: none;
        }

        #status .label {
            color: #888;
        }

        #status .value {
            color: #FFF;
            font-family: 'Consolas', monospace;
        }

        /* Stats overlay */
        #stats {
            position: absolute;
            top: 16px;
            right: 16px;
            z-index: 100;
            background: rgba(10, 14, 23, 0.85);
            border: 1px solid rgba(74, 144, 217, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 12px;
            backdrop-filter: blur(8px);
            font-family: 'Consolas', monospace;
        }

        #stats .fps {
            font-size: 24px;
            font-weight: bold;
            color: #00FF88;
        }

        #stats .fps.warning {
            color: #F1C40F;
        }

        #stats .fps.critical {
            color: #E74C3C;
        }

        /* Legend */
        #legend {
            position: absolute;
            bottom: 16px;
            left: 16px;
            z-index: 100;
            background: rgba(10, 14, 23, 0.85);
            border: 1px solid rgba(74, 144, 217, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 12px;
            backdrop-filter: blur(8px);
            display: flex;
            gap: 16px;
        }

        #legend .item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #legend .color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .color-pending { background: #888888; }
        .color-blue { background: #4A90D9; }
        .color-red { background: #E74C3C; }
        .color-vspc { background: #00FF88; box-shadow: 0 0 8px #00FF88; }
        .color-cluster { background: #9B59B6; }
        .color-lcca { background: #FFD700; box-shadow: 0 0 8px #FFD700; }

        /* Controls */
        #controls {
            position: absolute;
            bottom: 16px;
            right: 16px;
            z-index: 100;
            display: flex;
            gap: 8px;
        }

        #controls button {
            background: rgba(74, 144, 217, 0.2);
            border: 1px solid rgba(74, 144, 217, 0.5);
            color: #4A90D9;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        #controls button:hover {
            background: rgba(74, 144, 217, 0.4);
            border-color: #4A90D9;
        }

        #controls button:active {
            transform: scale(0.98);
        }

        /* Dummy simulation controls */
        #dummy-controls {
            position: absolute;
            bottom: 60px;
            right: 16px;
            z-index: 100;
            display: flex;
            gap: 8px;
            align-items: center;
            background: rgba(10, 14, 23, 0.85);
            border: 1px solid rgba(74, 144, 217, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            backdrop-filter: blur(8px);
        }

        #dummy-controls .label {
            font-size: 12px;
            color: #888;
            margin-right: 4px;
        }

        #dummy-controls button {
            background: rgba(74, 144, 217, 0.2);
            border: 1px solid rgba(74, 144, 217, 0.5);
            color: #4A90D9;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        #dummy-controls button:hover {
            background: rgba(74, 144, 217, 0.4);
        }

        #dummy-controls button.active {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00FF88;
            color: #00FF88;
        }

        #dummy-controls button.multiplier.selected {
            background: rgba(255, 215, 0, 0.3);
            border-color: #FFD700;
            color: #FFD700;
        }

        /* Loading overlay */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0A0E17;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #loading .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(74, 144, 217, 0.2);
            border-top-color: #4A90D9;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        #loading .text {
            margin-top: 16px;
            color: #4A90D9;
            font-size: 14px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="canvas-container"></div>

        <div id="status">
            <div class="title">DAGknight Visualizer</div>
            <div class="row">
                <span class="label">Status</span>
                <span class="value" id="connection-status">Disconnected</span>
            </div>
            <div class="row">
                <span class="label">Network</span>
                <span class="value" id="network-name">-</span>
            </div>
            <div class="row">
                <span class="label">Blue Score</span>
                <span class="value" id="blue-score">-</span>
            </div>
            <div class="row">
                <span class="label">Blocks</span>
                <span class="value" id="block-count">0</span>
            </div>
        </div>

        <div id="stats">
            <div class="fps" id="fps-display">-- FPS</div>
            <div id="draw-calls">Draw calls: -</div>
            <div id="memory-usage">Memory: -</div>
            <div id="debug-info" style="font-size: 10px; color: #888; margin-top: 8px;"></div>
        </div>

        <div id="legend">
            <div class="item"><div class="color color-pending"></div> Pending</div>
            <div class="item"><div class="color color-blue"></div> Blue Block</div>
            <div class="item"><div class="color color-red"></div> Red Block</div>
            <div class="item"><div class="color color-vspc"></div> Selected Chain</div>
            <div class="item"><div class="color color-cluster"></div> Honest Cluster</div>
            <div class="item"><div class="color color-lcca"></div> LCCA</div>
        </div>

        <div id="dummy-controls">
            <span class="label">BPS Sim:</span>
            <button id="btn-dummy-toggle">OFF</button>
            <span class="label">×</span>
            <button id="btn-dummy-2x" class="multiplier selected">2</button>
            <button id="btn-dummy-10x" class="multiplier">10</button>
            <button id="btn-dummy-100x" class="multiplier">100</button>
        </div>

        <div id="controls">
            <button id="btn-disconnect">Disconnect</button>
            <button id="btn-pause">Pause</button>
            <button id="btn-reset">Reset</button>
            <button id="btn-zoom-in">+</button>
            <button id="btn-zoom-out">-</button>
        </div>

        <div id="loading">
            <div class="spinner"></div>
            <div class="text">Initializing...</div>
        </div>
    </div>

    <!-- PixiJS v8 -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.x/dist/pixi.min.js"></script>

    <!-- Kaspa WASM SDK -->
    <script type="module">
        // ============================================================
        // DAGknight Protocol Visualizer
        // Phase 1: Foundation
        // ============================================================

        // ------------------------------------------------------------
        // Constants
        // ------------------------------------------------------------
        const CONFIG = {
            // Version (for debugging screenshots)
            VERSION: 'v85-perf-profiling',

            // Display
            MAX_BLOCKS: 500,
            MAX_EDGES: 500,
            BLOCK_SIZE: 8,
            BLOCK_SIZE_VIRTUAL: 12,
            LINEAR_PITCH: 10,  // X spacing between linearized blocks
            SPAWN_X: 400,  // Screen-relative: blocks spawn at right side (relative to center 0)
            CLEANUP_THRESHOLD: -1600,  // Remove blocks with X below this (≈ 2x screen width left of SPAWN_X)

            // Colors
            COLORS: {
                BACKGROUND: 0x0A0E17,
                PENDING_BLOCK: 0x888888,  // Gray - not yet confirmed
                BLUE_BLOCK: 0x4A90D9,
                BLUE_EDGE: 0x7AB8E8,      // Lighter blue for finalized chain edges
                RED_BLOCK: 0xE74C3C,
                SELECTED_CHAIN: 0x00FF88,
                LCCA: 0xFFD700,  // Gold/Yellow for LCCA
                WHITE: 0xFFFFFF,  // White for outlines
                EDGE: 0x334455,
                EDGE_SELECTED: 0xFFFFFF,
                HONEST_CLUSTER: 0x9B59B6,
            },

            // Performance
            UPDATE_INTERVAL: 500,  // ms
            TARGET_FPS: 60,

            // Network
            RPC_ENDPOINTS: [
                'wss://kaspa.aspectron.org/mainnet/wrpc/borsh',
                'wss://kaspa.matryx.io/mainnet/wrpc/borsh',
            ],

            // High BPS Simulation (Dummy Blocks)
            DUMMY: {
                ENABLED: false,        // Toggle dummy block generation
                MULTIPLIER: 1,         // +1=2x, +9=10x, +99=100x BPS
                MAX_PARENT_SELECT: 2,  // Dummy removed from tips after this many selections
                MAX_DUMMY_PARENTS: 2,  // Max dummy tips to add as parents per block
            },
        };

        // ------------------------------------------------------------
        // State
        // ------------------------------------------------------------
        const State = {
            app: null,
            graphics: null,  // Will be initialized in initPixi()
            rpcClient: null,
            isConnected: false,
            isPaused: false,

            // Block data (TypedArrays for performance)
            blockData: {
                hashes: new Array(CONFIG.MAX_BLOCKS),
                parentHashes: new Array(CONFIG.MAX_BLOCKS),  // Store parent hashes for dynamic resolution
                x: new Float32Array(CONFIG.MAX_BLOCKS),
                y: new Float32Array(CONFIG.MAX_BLOCKS),
                targetX: new Float32Array(CONFIG.MAX_BLOCKS),  // For smooth X animation (linearization)
                targetY: new Float32Array(CONFIG.MAX_BLOCKS),  // For smooth Y animation
                linearIndex: new Int32Array(CONFIG.MAX_BLOCKS),  // -1 = not linearized yet
                color: new Uint32Array(CONFIG.MAX_BLOCKS),
                size: new Float32Array(CONFIG.MAX_BLOCKS),
                isBlue: new Uint8Array(CONFIG.MAX_BLOCKS),
                confirmationState: new Uint8Array(CONFIG.MAX_BLOCKS),  // 0=Pending, 1=Blue, 2=Red
                daaScore: new Float64Array(CONFIG.MAX_BLOCKS),
                blueScore: new Float64Array(CONFIG.MAX_BLOCKS),
                blueWork: new Array(CONFIG.MAX_BLOCKS),  // BigInt as string
                bits: new Uint32Array(CONFIG.MAX_BLOCKS),  // PoW difficulty bits
            },
            blockCount: 0,
            blockHashToIndex: new Map(),

            // High BPS Simulation (Dummy Blocks)
            dummyTips: new Map(),      // Map<dummyHash, selectCount> - tracks how many times selected as parent
            dummyBlockCount: 0,        // Total dummy blocks generated
            lastDummyLog: 0,           // Throttle debug logging

            // Ring buffer pointers
            ringHead: 0,
            ringTail: 0,

            // DAA score reference for relative X coordinates
            minDaaScore: null,
            maxDaaScore: null,

            // Viewport
            viewport: {
                x: 0,  // Center at origin
                y: 0,
                targetX: 0,  // Fixed camera (no scrolling needed)
                zoom: 1,
                width: 0,
                height: 0,
            },

            // Stats
            stats: {
                fps: 0,
                frameCount: 0,
                lastFpsUpdate: 0,
                drawCalls: 0,
                visibleBlocks: 0,
                edgeCount: 0,
            },

            // Selected Chain (Selected Parent Chain)
            selectedChainEdges: [],    // [[fromHash, toHash], ...] - all edges, classified at render time
            selectedChainBlocks: new Set(),  // Blocks on selected chain (for large block rendering)
            orderedBlocks: new Set(),  // All topologically ordered blocks (chain + ancestors)
            linearOrder: [],  // Final linearized order [hash, hash, ...]
            lccaHash: null,  // Latest Common Chain Ancestor (convergence point)
            lastDagknightCalc: 0,

            // Debug info
            debug: null,

            // Performance profiling
            perf: {
                findLCCA: { calls: 0, time: 0 },
                selectParent: { calls: 0, time: 0 },
                selectBest: { calls: 0, time: 0 },
                compareRank: { calls: 0 },
                cacheHits: 0,
            },

            // Selected Parent Cache (dkoder optimization)
            // Map<blockHash, selectedParentHash>
            selectedParentCache: new Map(),

            // DAGknight Engine (dkoder-compliant)
            dagknight: {
                // BlockColouring enum: 0=Pending, 1=Blue, 2=Red
                PENDING: 0,
                BLUE: 1,
                RED: 2,

                // ConflictZoneManager data
                conflictZone: {
                    root: null,        // conflict genesis (LCCA)
                    tips: [],          // current tip hashes
                    blocks: new Set(), // blocks in zone
                },

                // CascadeTree data (per-block)
                cascadeTree: {
                    pastBlues: new Map(),      // hash → count
                    pastReds: new Map(),       // hash → count
                    anticoneBlues: new Map(),  // hash → count
                    arlb: new Map(),           // anticone_reds_lower_bound
                    floor: new Map(),          // hash → floor value
                },

                // Per-block coloring data
                bluesAnticoneSizes: new Map(), // hash → Map<blueHash, size>
                mergesetBlues: new Map(),      // hash → Set<hash>
                mergesetReds: new Map(),       // hash → Set<hash>
                coloringK: new Map(),          // hash → k value used

                // Caches (dkoder optimization)
                ancestorCache: new Map(),      // "hashA:hashB" → boolean
                kColouringCache: new Map(),    // "parents_hash:k" → result
                ancestorCacheHits: 0,
                ancestorCacheMisses: 0,

                // Interval-based reachability (dkoder: reachability_service)
                // Each block has interval [start, end] for O(1) chain ancestor check
                intervalMap: new Map(),        // hash → {start, end}
                intervalCounter: 0,            // Counter for interval assignment
                intervalChainHits: 0,          // Times isChainAncestor returned true
                intervalChainMisses: 0,        // Times fell back to BFS

                // Performance profiling
                perf: {
                    isAncestor: { calls: 0, time: 0 },
                    commonChainAncestor: { calls: 0, time: 0 },
                    calcConflictZoneWork: { calls: 0, time: 0 },
                    computeIntervals: { calls: 0, time: 0 },
                    kColouring: { calls: 0, time: 0 },
                    checkBlueCandidate: { calls: 0, time: 0 },
                    rank: { calls: 0, time: 0 },
                    addBlockColoring: { calls: 0, time: 0 },
                },

                // Parameters
                d: 10,  // deficit parameter for confirmation
            },
        };

        // ------------------------------------------------------------
        // DOM Elements
        // ------------------------------------------------------------
        const DOM = {
            container: document.getElementById('canvas-container'),
            loading: document.getElementById('loading'),
            loadingText: document.querySelector('#loading .text'),
            status: document.getElementById('status'),
            connectionStatus: document.getElementById('connection-status'),
            networkName: document.getElementById('network-name'),
            blueScore: document.getElementById('blue-score'),
            blockCount: document.getElementById('block-count'),
            fpsDisplay: document.getElementById('fps-display'),
            drawCalls: document.getElementById('draw-calls'),
            memoryUsage: document.getElementById('memory-usage'),
            btnDisconnect: document.getElementById('btn-disconnect'),
            btnPause: document.getElementById('btn-pause'),
            btnReset: document.getElementById('btn-reset'),
            btnZoomIn: document.getElementById('btn-zoom-in'),
            btnZoomOut: document.getElementById('btn-zoom-out'),
            debugInfo: document.getElementById('debug-info'),
            // Dummy controls
            btnDummyToggle: document.getElementById('btn-dummy-toggle'),
            btnDummy2x: document.getElementById('btn-dummy-2x'),
            btnDummy10x: document.getElementById('btn-dummy-10x'),
            btnDummy100x: document.getElementById('btn-dummy-100x'),
        };

        // ------------------------------------------------------------
        // PixiJS Initialization
        // ------------------------------------------------------------
        async function initPixi() {
            updateLoadingText('Initializing renderer...');

            State.app = new PIXI.Application();

            await State.app.init({
                background: CONFIG.COLORS.BACKGROUND,
                resizeTo: DOM.container,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
                powerPreference: 'high-performance',
            });

            DOM.container.appendChild(State.app.canvas);

            // Create Graphics objects ONCE (reused every frame)
            State.graphics = {
                edges: new PIXI.Graphics(),
                chainEdges: new PIXI.Graphics(),  // Selected Chain edges (behind blocks)
                pendingBlocks: new PIXI.Graphics(),  // Pending blocks (gray, behind blue/red)
                blueBlocks: new PIXI.Graphics(),
                redBlocks: new PIXI.Graphics(),
                chainBlocks: new PIXI.Graphics(),  // Chain blocks (large, with white outline, on top)
                lcca: new PIXI.Graphics(),  // LCCA block (on top)
            };

            // Add to stage (layered: back to front)
            State.app.stage.addChild(State.graphics.edges);          // 1. Gray edges (back)
            State.app.stage.addChild(State.graphics.chainEdges);     // 2. Selected Chain edges
            State.app.stage.addChild(State.graphics.pendingBlocks);  // 3. Pending blocks (gray)
            State.app.stage.addChild(State.graphics.blueBlocks);     // 4. Blue blocks (non-chain)
            State.app.stage.addChild(State.graphics.redBlocks);      // 5. Red blocks
            State.app.stage.addChild(State.graphics.chainBlocks);    // 6. Chain blocks (large, front)
            State.app.stage.addChild(State.graphics.lcca);           // 7. LCCA (front)

            // Store viewport dimensions
            State.viewport.width = State.app.screen.width;
            State.viewport.height = State.app.screen.height;

            // Handle resize
            window.addEventListener('resize', onResize);

            // Start render loop
            State.app.ticker.add(onTick);

            console.log('PixiJS initialized', {
                width: State.viewport.width,
                height: State.viewport.height,
                renderer: State.app.renderer.type === 1 ? 'WebGL' : 'WebGPU',
            });
        }

        function onResize() {
            State.viewport.width = State.app.screen.width;
            State.viewport.height = State.app.screen.height;
        }

        // ------------------------------------------------------------
        // Render Loop
        // ------------------------------------------------------------
        function onTick(ticker) {
            if (State.isPaused) return;

            // Update FPS counter
            State.stats.frameCount++;
            const now = performance.now();
            if (now - State.stats.lastFpsUpdate >= 1000) {
                State.stats.fps = State.stats.frameCount;
                State.stats.frameCount = 0;
                State.stats.lastFpsUpdate = now;
                updateStatsDisplay();
            }

            // Run DAGknight calculation periodically (every 500ms)
            if (now - State.lastDagknightCalc >= 500) {
                // Reset perf counters
                State.perf.findLCCA = { calls: 0, time: 0 };
                State.perf.selectParent = { calls: 0, time: 0 };
                State.perf.selectBest = { calls: 0, time: 0 };
                State.perf.compareRank = { calls: 0 };
                State.perf.cacheHits = 0;
                runDAGknightCalculation();
                State.lastDagknightCalc = now;
            }

            // Render blocks and edges
            renderDAG();
        }

        // ------------------------------------------------------------
        // DAG Rendering (Optimized: reuse Graphics objects)
        // ------------------------------------------------------------
        function renderDAG() {
            const { edges, chainEdges, pendingBlocks, blueBlocks, redBlocks, chainBlocks, lcca } = State.graphics;

            // Smooth viewport scrolling (lerp interpolation)
            State.viewport.x += (State.viewport.targetX - State.viewport.x) * 0.1;

            // Smooth X and Y animation for all blocks (lerp to targets)
            const { x, y, targetX, targetY, linearIndex } = State.blockData;
            for (let i = 0; i < State.blockCount; i++) {
                // Y animation (all blocks)
                y[i] += (targetY[i] - y[i]) * 0.15;

                // X animation (only for linearized blocks)
                if (linearIndex[i] >= 0) {
                    x[i] += (targetX[i] - x[i]) * 0.1;
                }
            }

            // Clear previous frame (reuse same objects)
            edges.clear();
            chainEdges.clear();
            pendingBlocks.clear();
            blueBlocks.clear();
            redBlocks.clear();
            chainBlocks.clear();
            lcca.clear();

            if (State.blockCount === 0) return;

            const { size, isBlue, confirmationState, parentHashes, hashes } = State.blockData;
            const { zoom, width, height } = State.viewport;
            const vpX = State.viewport.x;
            const vpY = State.viewport.y;
            const halfWidth = width / 2;
            const halfHeight = height / 2;

            let visibleCount = 0;
            let edgeCount = 0;

            // Build sorted index array (by X descending = newest first)
            const sortedIndices = [];
            for (let i = 0; i < State.blockCount; i++) {
                sortedIndices.push(i);
            }
            sortedIndices.sort((a, b) => x[b] - x[a]);

            // First pass: draw edges (newest blocks first, up to MAX_EDGES)
            for (const i of sortedIndices) {
                if (edgeCount >= CONFIG.MAX_EDGES) break;

                const screenX = (x[i] - vpX) * zoom + halfWidth;
                const screenY = (y[i] - vpY) * zoom + halfHeight;

                // Skip if outside viewport
                if (screenX < -100 || screenX > width + 100 ||
                    screenY < -100 || screenY > height + 100) {
                    continue;
                }

                // Draw edges to parents (skip if block has converged to Y≈0)
                // Edges fade out naturally as blocks reach Y=0, not when linearized
                if (Math.abs(y[i]) > 5) {  // Only draw edges if Y is not yet at 0
                    const parents = parentHashes[i] || [];
                    for (const parentHash of parents) {
                        if (edgeCount >= CONFIG.MAX_EDGES) break;
                        const parentIdx = State.blockHashToIndex.get(parentHash);
                        if (parentIdx !== undefined) {
                            const parentScreenX = (x[parentIdx] - vpX) * zoom + halfWidth;
                            const parentScreenY = (y[parentIdx] - vpY) * zoom + halfHeight;

                            edges.moveTo(screenX, screenY);
                            edges.lineTo(parentScreenX, parentScreenY);
                            edgeCount++;
                        }
                    }
                }
            }

            // Stroke all edges at once
            if (edgeCount > 0) {
                edges.stroke({ width: 2, color: CONFIG.COLORS.EDGE, alpha: 0.5 });
            }

            // Second pass: draw blocks (on top of edges)
            // Chain blocks are drawn larger (14px vs 8px)
            const chainBlockSize = 14 * zoom;
            const chainHalfSize = chainBlockSize / 2;

            for (let i = 0; i < State.blockCount; i++) {
                const hash = hashes[i];
                if (!hash) continue;

                const screenX = (x[i] - vpX) * zoom + halfWidth;
                const screenY = (y[i] - vpY) * zoom + halfHeight;

                // Skip if outside viewport
                if (screenX < -50 || screenX > width + 50 ||
                    screenY < -50 || screenY > height + 50) {
                    continue;
                }

                // Check if this block is on the Selected Chain
                const isChainBlock = State.selectedChainBlocks && State.selectedChainBlocks.has(hash);
                const state = confirmationState[i];

                // dkoder: Tips (pending) stay gray even if on selected chain
                // Only confirmed blocks (with children) get blue/large styling
                if (state === 0) {
                    // Pending (gray) - tips or unconfirmed blocks
                    // Regular size even if on chain (not yet confirmed)
                    const blockSize = size[i] * zoom;
                    const halfSize = blockSize / 2;
                    pendingBlocks.rect(screenX - halfSize, screenY - halfSize, blockSize, blockSize);
                } else if (isChainBlock && state === 1) {
                    // Confirmed chain block - larger blue with white outline (top layer)
                    chainBlocks.rect(screenX - chainHalfSize, screenY - chainHalfSize, chainBlockSize, chainBlockSize)
                        .fill({ color: CONFIG.COLORS.BLUE_BLOCK })
                        .stroke({ width: 1, color: CONFIG.COLORS.WHITE });
                } else if (state === 1) {
                    // Blue (confirmed but not on chain) - with white outline
                    const blockSize = size[i] * zoom;
                    const halfSize = blockSize / 2;
                    blueBlocks.rect(screenX - halfSize, screenY - halfSize, blockSize, blockSize)
                        .fill({ color: CONFIG.COLORS.BLUE_BLOCK })
                        .stroke({ width: 1, color: CONFIG.COLORS.WHITE });
                } else {
                    // Red (confirmed but not selected) - with white outline
                    const blockSize = size[i] * zoom;
                    const halfSize = blockSize / 2;
                    redBlocks.rect(screenX - halfSize, screenY - halfSize, blockSize, blockSize)
                        .fill({ color: CONFIG.COLORS.RED_BLOCK })
                        .stroke({ width: 1, color: CONFIG.COLORS.WHITE });
                }

                visibleCount++;
            }

            // Draw Selected Chain edges FIRST (behind blocks)
            // dkoder: Selected chain is determined by blueWork, known immediately even for tips
            // Green = active area (LCCA to tips) - chain structure is known
            // Blue = finalized area (before LCCA) - confirmed and stable
            if (State.selectedChainEdges && State.selectedChainEdges.length > 0) {
                const { targetX } = State.blockData;

                // Get LCCA's targetX for comparison (stable, not animated)
                let lccaTargetX = -Infinity;
                if (State.lccaHash) {
                    const lccaIdx = State.blockHashToIndex.get(State.lccaHash);
                    if (lccaIdx !== undefined) {
                        lccaTargetX = targetX[lccaIdx];
                    }
                }

                let blueDrawn = false;
                let greenDrawn = false;

                // First pass: blue edges (at least one endpoint in finalized area)
                for (const [fromHash, toHash] of State.selectedChainEdges) {
                    const idx1 = State.blockHashToIndex.get(fromHash);
                    const idx2 = State.blockHashToIndex.get(toHash);

                    if (idx1 !== undefined && idx2 !== undefined) {
                        const bothInActive = targetX[idx1] >= lccaTargetX && targetX[idx2] >= lccaTargetX;
                        if (!bothInActive) {
                            const screenX1 = (x[idx1] - vpX) * zoom + halfWidth;
                            const screenY1 = (y[idx1] - vpY) * zoom + halfHeight;
                            const screenX2 = (x[idx2] - vpX) * zoom + halfWidth;
                            const screenY2 = (y[idx2] - vpY) * zoom + halfHeight;
                            chainEdges.moveTo(screenX1, screenY1);
                            chainEdges.lineTo(screenX2, screenY2);
                            blueDrawn = true;
                        }
                    }
                }
                if (blueDrawn) {
                    chainEdges.stroke({ width: 4, color: CONFIG.COLORS.BLUE_EDGE, alpha: 0.9 });
                }

                // Second pass: green edges (BOTH endpoints in active area - including tips)
                for (const [fromHash, toHash] of State.selectedChainEdges) {
                    const idx1 = State.blockHashToIndex.get(fromHash);
                    const idx2 = State.blockHashToIndex.get(toHash);

                    if (idx1 !== undefined && idx2 !== undefined) {
                        const bothInActive = targetX[idx1] >= lccaTargetX && targetX[idx2] >= lccaTargetX;
                        if (bothInActive) {
                            const screenX1 = (x[idx1] - vpX) * zoom + halfWidth;
                            const screenY1 = (y[idx1] - vpY) * zoom + halfHeight;
                            const screenX2 = (x[idx2] - vpX) * zoom + halfWidth;
                            const screenY2 = (y[idx2] - vpY) * zoom + halfHeight;
                            chainEdges.moveTo(screenX1, screenY1);
                            chainEdges.lineTo(screenX2, screenY2);
                            greenDrawn = true;
                        }
                    }
                }
                if (greenDrawn) {
                    chainEdges.stroke({ width: 3, color: CONFIG.COLORS.SELECTED_CHAIN, alpha: 0.8 });
                }
            }

            // Fill pending blocks (no outline)
            // Blue, red, chain, LCCA are filled individually with stroke
            pendingBlocks.fill({ color: CONFIG.COLORS.PENDING_BLOCK });

            // Draw LCCA block LAST (on top of everything)
            if (State.lccaHash) {
                const lccaIdx = State.blockHashToIndex.get(State.lccaHash);
                if (lccaIdx !== undefined) {
                    const lccaScreenX = (x[lccaIdx] - vpX) * zoom + halfWidth;
                    const lccaScreenY = (y[lccaIdx] - vpY) * zoom + halfHeight;

                    // Only draw if visible
                    if (lccaScreenX >= -50 && lccaScreenX <= width + 50 &&
                        lccaScreenY >= -50 && lccaScreenY <= height + 50) {
                        const lccaSize = 18 * zoom;  // Larger than chain blocks (14px)
                        const lccaHalfSize = lccaSize / 2;
                        lcca.rect(lccaScreenX - lccaHalfSize, lccaScreenY - lccaHalfSize, lccaSize, lccaSize)
                            .fill({ color: CONFIG.COLORS.LCCA })  // Yellow/Gold
                            .stroke({ width: 1, color: CONFIG.COLORS.WHITE });
                    }
                }
            }

            // Update stats
            State.stats.drawCalls = 4; // edges + blue blocks + red blocks + chain
            State.stats.visibleBlocks = visibleCount;
            State.stats.edgeCount = edgeCount;
        }

        // ------------------------------------------------------------
        // High BPS Simulation (Dummy Block Generation)
        // ------------------------------------------------------------

        /**
         * Generate a unique dummy hash from original block hash
         * Format: 0dummy_{original}_{index}
         * - '0dummy' prefix ensures it's lexicographically smaller than real hashes
         * - This makes real blocks preferred in selected parent selection
         */
        function generateDummyHash(originalHash, index) {
            return `0dummy_${originalHash.substring(0, 16)}_${index}`;
        }

        /**
         * Check if a hash is a dummy block
         */
        function isDummyHash(hash) {
            return hash && hash.startsWith('0dummy_');
        }

        /**
         * Log dummy block status (throttled to avoid spam)
         */
        function logDummyStatus(force = false) {
            const now = Date.now();
            if (!force && now - State.lastDummyLog < 2000) return;  // Throttle to 2s
            State.lastDummyLog = now;

            if (!CONFIG.DUMMY.ENABLED) return;

            console.log('[Dummy] Status:', {
                enabled: CONFIG.DUMMY.ENABLED,
                multiplier: CONFIG.DUMMY.MULTIPLIER,
                totalGenerated: State.dummyBlockCount,
                activeTips: State.dummyTips.size,
                tips: Array.from(State.dummyTips.entries()).slice(0, 5),  // Show first 5
            });
        }

        /**
         * Generate dummy blocks for high BPS simulation
         * Called after a real block is added
         */
        function generateDummyBlocks(originalBlock) {
            if (!CONFIG.DUMMY.ENABLED) return;
            // Note: Ring buffer handles overflow, no need for safety margin

            const originalHash = originalBlock.header.hash;
            const originalDaaScore = Number(originalBlock.header.daaScore);
            const originalBlueWork = originalBlock.header.blueWork || '0';
            const originalBits = Number(originalBlock.header.bits || 0);
            const parentsByLevel = originalBlock.header.parentsByLevel || [];
            const originalParents = parentsByLevel[0] || [];

            // Generate MULTIPLIER dummy blocks
            for (let i = 0; i < CONFIG.DUMMY.MULTIPLIER; i++) {
                const dummyHash = generateDummyHash(originalHash, i);

                // Skip if already exists
                if (State.blockHashToIndex.has(dummyHash)) continue;

                // Get next index
                const index = State.ringHead;
                const oldHash = State.blockData.hashes[index];
                if (oldHash) {
                    State.blockHashToIndex.delete(oldHash);
                    State.dummyTips.delete(oldHash);  // Remove from tips if it was there
                }

                // Store dummy block
                State.blockData.hashes[index] = dummyHash;
                State.blockHashToIndex.set(dummyHash, index);
                State.blockData.daaScore[index] = originalDaaScore;

                // X = same spawn area with slight offset
                const tipOffset = 10 + Math.random() * 30;
                State.blockData.x[index] = CONFIG.SPAWN_X + tipOffset;

                // Y = spread vertically (different from original)
                const randomY = (Math.random() - 0.5) * 300;
                State.blockData.y[index] = randomY;
                State.blockData.targetY[index] = randomY;

                State.blockData.targetX[index] = State.blockData.x[index];
                State.blockData.linearIndex[index] = -1;

                // BlueWork: same as original (will be lower priority due to hash)
                State.blockData.blueScore[index] = Number(originalBlock.header.blueScore || 0);
                State.blockData.blueWork[index] = originalBlueWork;
                State.blockData.bits[index] = originalBits;

                // Color: Start as Pending
                State.blockData.color[index] = CONFIG.COLORS.PENDING_BLOCK;
                State.blockData.confirmationState[index] = 0;
                State.blockData.isBlue[index] = 1;
                State.blockData.size[index] = CONFIG.BLOCK_SIZE;

                // Parents: same as original
                State.blockData.parentHashes[index] = [...originalParents];

                // Update ring buffer
                State.ringHead = (State.ringHead + 1) % CONFIG.MAX_BLOCKS;
                if (State.blockCount < CONFIG.MAX_BLOCKS) {
                    State.blockCount++;
                }

                // Add to dummyTips (selectCount = 0)
                State.dummyTips.set(dummyHash, 0);
                State.dummyBlockCount++;
            }

            // Debug log (throttled)
            logDummyStatus();
        }

        // ------------------------------------------------------------
        // DAGknight Algorithm
        // ------------------------------------------------------------

        // ============================================================
        // DAGknight Engine (dkoder-compliant implementation)
        // ============================================================

        // --- Step 1: Base Functions ---

        // findSelectedParent: Find parent with highest blueWork (dkoder: find_selected_parent)
        function findSelectedParent(parentHashes) {
            if (!parentHashes || parentHashes.length === 0) return null;
            if (parentHashes.length === 1) return parentHashes[0];

            let selectedParent = null;
            let maxBlueWork = '';

            for (const parentHash of parentHashes) {
                const idx = State.blockHashToIndex.get(parentHash);
                if (idx === undefined) continue;

                const blueWork = State.blockData.blueWork[idx] || '0';
                // String comparison works for hex (same length, lexicographic = numeric)
                if (blueWork > maxBlueWork || (blueWork === maxBlueWork && parentHash > (selectedParent || ''))) {
                    maxBlueWork = blueWork;
                    selectedParent = parentHash;
                }
            }

            return selectedParent;
        }

        // sortBlocks: Sort blocks by blueWork descending (dkoder: sort_blocks)
        function sortBlocks(blockHashes) {
            return [...blockHashes].sort((a, b) => {
                const idxA = State.blockHashToIndex.get(a);
                const idxB = State.blockHashToIndex.get(b);
                if (idxA === undefined) return 1;
                if (idxB === undefined) return -1;

                const workA = State.blockData.blueWork[idxA] || '0';
                const workB = State.blockData.blueWork[idxB] || '0';

                // Descending order (higher blueWork first)
                if (workB > workA) return 1;
                if (workA > workB) return -1;
                // Tie-breaker: hash
                return b > a ? 1 : -1;
            });
        }

        // blueAnticoneSize: Calculate blue anticone size from a worldview (dkoder: blue_anticone_size)
        function blueAnticoneSize(blockHash, worldviewHash, bluesAnticoneSizes) {
            if (!bluesAnticoneSizes) return 0;
            const sizes = bluesAnticoneSizes.get(worldviewHash);
            if (!sizes) return 0;
            return sizes.get(blockHash) || 0;
        }

        // --- Step 2: ConflictZoneManager Functions ---

        // commonChainAncestor: Find LCCA of multiple blocks (dkoder: common_chain_ancestor)
        function commonChainAncestor(hashes) {
            const start = performance.now();
            State.dagknight.perf.commonChainAncestor.calls++;

            if (!hashes || hashes.length === 0) {
                State.dagknight.perf.commonChainAncestor.time += performance.now() - start;
                return null;
            }
            if (hashes.length === 1) {
                State.dagknight.perf.commonChainAncestor.time += performance.now() - start;
                return hashes[0];
            }

            // Build Selected Parent Chain for each hash
            const chains = hashes.map(hash => {
                const chain = [hash];
                let current = hash;
                const visited = new Set([hash]);

                for (let i = 0; i < 200; i++) {  // Max depth
                    const idx = State.blockHashToIndex.get(current);
                    if (idx === undefined) break;

                    const parents = State.blockData.parentHashes[idx] || [];
                    if (parents.length === 0) break;

                    // Find selected parent (highest blueWork)
                    const sp = findSelectedParent(parents);
                    if (!sp || visited.has(sp)) break;

                    visited.add(sp);
                    chain.push(sp);
                    current = sp;
                }
                return chain;
            });

            // Find first common element in all chains
            const firstChainSet = new Set(chains[0]);
            for (const hash of chains[0]) {
                let isCommon = true;
                for (let i = 1; i < chains.length; i++) {
                    if (!chains[i].includes(hash)) {
                        isCommon = false;
                        break;
                    }
                }
                if (isCommon) {
                    State.dagknight.perf.commonChainAncestor.time += performance.now() - start;
                    return hash;
                }
            }

            State.dagknight.perf.commonChainAncestor.time += performance.now() - start;
            return null;
        }

        // calcWork: Calculate PoW work from difficulty bits (dkoder: calc_work)
        // work = (~target / (target + 1)) + 1 ≈ 2^256 / (target + 1)
        // Same scale as Kaspa's blueWork (2^256 based)
        const TWO_256 = 1n << 256n;  // 2^256

        function calcWork(bits) {
            if (!bits || bits === 0) return 1n;  // Fallback to 1 if no bits

            // Decode compact target bits (Bitcoin-style)
            // bits = 0x1e7fffff → exponent=0x1e, mantissa=0x7fffff
            const exponent = bits >> 24;
            const mantissa = bits & 0x007fffff;

            if (exponent === 0 || mantissa === 0) return 1n;

            // target = mantissa × 2^(8 × (exponent - 3))
            const shift = 8 * (exponent - 3);

            // Calculate target as BigInt
            let target;
            if (shift >= 0) {
                target = BigInt(mantissa) << BigInt(shift);
            } else {
                target = BigInt(mantissa) >> BigInt(-shift);
            }

            if (target === 0n) return 1n;

            // work = 2^256 / (target + 1) - same as dkoder
            // dkoder: (!target / (target + 1)) + 1
            // This is mathematically equivalent to 2^256 / (target + 1)
            const work = TWO_256 / (target + 1n);
            return work > 0n ? work : 1n;
        }

        // calcConflictZoneWork: Calculate total work in conflict zone (dkoder: calc_conflict_zone_work)
        // Returns both zoneWork AND zoneBlocks for consistent kColouring
        function calcConflictZoneWork(genesisHash, subgroupHashes) {
            const startTime = performance.now();
            State.dagknight.perf.calcConflictZoneWork.calls++;
            let totalWork = 0n;
            const visited = new Set();
            const validBlocks = [];  // Blocks with valid idx
            let skippedCount = 0;    // Debug: blocks without idx
            let firstBitsValues = []; // Debug: first few bits values

            // BFS from subgroup tips back to genesis
            const queue = [...subgroupHashes];

            // Debug: track input
            State.dagknight.lastSubgroupSize = subgroupHashes.length;
            State.dagknight.lastGenesisExists = State.blockHashToIndex.has(genesisHash);

            while (queue.length > 0) {
                const hash = queue.shift();
                if (visited.has(hash)) continue;
                if (hash === genesisHash) continue;  // Don't include genesis itself
                visited.add(hash);

                // Skip dummy blocks from DAGknight calculation (visualization only)
                if (isDummyHash(hash)) {
                    skippedCount++;
                    continue;
                }

                const idx = State.blockHashToIndex.get(hash);
                if (idx === undefined) {
                    skippedCount++;
                    continue;
                }

                // Add this block's individual work (from bits, not cumulative blueWork)
                const bits = State.blockData.bits[idx];
                const work = calcWork(bits);
                totalWork += work;
                validBlocks.push(hash);

                // Debug: track first few bits values
                if (firstBitsValues.length < 3) {
                    firstBitsValues.push({ bits, work: work.toString().length });
                }

                // Add parents to queue (if not past genesis, skip dummies)
                const parents = State.blockData.parentHashes[idx] || [];
                for (const parentHash of parents) {
                    if (!visited.has(parentHash) && parentHash !== genesisHash && !isDummyHash(parentHash)) {
                        // Check if parent is ancestor of genesis (stop condition)
                        if (!isAncestor(parentHash, genesisHash, 50)) {
                            queue.push(parentHash);
                        }
                    }
                }
            }

            // Debug: track zone stats
            State.dagknight.lastZoneBlockCount = visited.size;
            State.dagknight.lastValidBlockCount = validBlocks.length;
            State.dagknight.lastSkippedCount = skippedCount;
            State.dagknight.lastFirstBits = firstBitsValues;
            State.dagknight.lastTotalWorkDigits = totalWork > 0n ? totalWork.toString().length : 0;

            State.dagknight.perf.calcConflictZoneWork.time += performance.now() - startTime;
            // Return only valid blocks for kColouring
            return { zoneWork: totalWork, zoneBlocks: validBlocks };
        }

        // orderedMergesetWithoutSelectedParent: Get mergeset in topological order (dkoder: ordered_mergeset_without_selected_parent)
        function orderedMergesetWithoutSelectedParent(selectedParent, allParents) {
            // Mergeset = parents that are not the selected parent
            // and not ancestors of selected parent
            const mergeset = [];

            for (const parentHash of allParents) {
                if (parentHash === selectedParent) continue;

                // Check if this parent is in the anticone of selected parent
                // (not ancestor and not descendant)
                if (!isAncestor(parentHash, selectedParent, 50) &&
                    !isAncestor(selectedParent, parentHash, 50)) {
                    mergeset.push(parentHash);
                }
            }

            // Sort by blueWork (topological approximation)
            return sortBlocks(mergeset);
        }

        // --- Step 3: K-Colouring Functions ---

        // checkBlueCandidate: Check if candidate can be blue with given k (dkoder: check_blue_candidate)
        // Debug counters for rejection reasons
        let checkBlueStats = { check1: 0, check2: 0, check3: 0, passed: 0 };

        function checkBlueCandidate(newBlockData, candidateHash, k, mergesetBlues) {
            // Check 1: mergeset blues count <= k
            if (mergesetBlues.size > k) {
                checkBlueStats.check1++;
                return false;
            }

            // Check 2: candidate's blue anticone size <= k
            const candidateAnticoneBlues = countAnticoneBlues(candidateHash, mergesetBlues);
            if (candidateAnticoneBlues > k) {
                checkBlueStats.check2++;
                // Debug: track max anticone seen
                if (!State.dagknight.maxAnticoneBlues || candidateAnticoneBlues > State.dagknight.maxAnticoneBlues) {
                    State.dagknight.maxAnticoneBlues = candidateAnticoneBlues;
                }
                return false;
            }

            // Check 3: for each existing blue, adding candidate doesn't exceed k
            for (const blueHash of mergesetBlues) {
                const blueAnticoneWithCandidate = countAnticoneBluesWithCandidate(
                    blueHash, candidateHash, mergesetBlues
                );
                if (blueAnticoneWithCandidate > k) {
                    checkBlueStats.check3++;
                    return false;
                }
            }

            checkBlueStats.passed++;
            return true;
        }

        // Reset and expose stats
        function resetCheckBlueStats() {
            checkBlueStats = { check1: 0, check2: 0, check3: 0, passed: 0 };
        }
        function getCheckBlueStats() {
            return checkBlueStats;
        }

        // Helper: Count blue blocks in anticone of a block
        function countAnticoneBlues(blockHash, blueSet) {
            let count = 0;
            for (const blueHash of blueSet) {
                if (blueHash === blockHash) continue;
                // In anticone = not ancestor and not descendant
                if (!isAncestor(blueHash, blockHash, 30) &&
                    !isAncestor(blockHash, blueHash, 30)) {
                    count++;
                }
            }
            return count;
        }

        // Helper: Count anticone blues if we add candidate to blue set
        function countAnticoneBluesWithCandidate(blueHash, candidateHash, currentBlues) {
            let count = 0;

            // Count existing blues in anticone
            for (const otherBlue of currentBlues) {
                if (otherBlue === blueHash) continue;
                if (!isAncestor(otherBlue, blueHash, 30) &&
                    !isAncestor(blueHash, otherBlue, 30)) {
                    count++;
                }
            }

            // Check if candidate would be in anticone
            if (candidateHash !== blueHash &&
                !isAncestor(candidateHash, blueHash, 30) &&
                !isAncestor(blueHash, candidateHash, 30)) {
                count++;
            }

            return count;
        }

        // kColouring: Perform k-colouring on parents (dkoder: k_colouring)
        // With caching to avoid redundant calculations
        function kColouring(parentHashes, k, selectedParentOverride = null) {
            const start = performance.now();
            State.dagknight.perf.kColouring.calls++;

            const selectedParent = selectedParentOverride || findSelectedParent(parentHashes);
            if (!selectedParent) {
                State.dagknight.perf.kColouring.time += performance.now() - start;
                return { selectedParent: null, mergesetBlues: new Set(), mergesetReds: new Set() };
            }

            // Cache key: sorted parents + k
            const cacheKey = parentHashes.slice().sort().join(',') + ':' + k;
            const cached = State.dagknight.kColouringCache.get(cacheKey);
            if (cached) {
                State.dagknight.perf.kColouring.time += performance.now() - start;
                return cached;
            }

            const mergeset = orderedMergesetWithoutSelectedParent(selectedParent, parentHashes);
            const mergesetBlues = new Set();
            const mergesetReds = new Set();

            // Reset debug stats for this colouring
            resetCheckBlueStats();

            // Process each candidate in topological order
            for (const candidateHash of mergeset) {
                // Early termination (dkoder): if blues already at k, remaining are Red
                if (mergesetBlues.size >= k && k > 0) {
                    // Can't add more blues, mark rest as red
                    mergesetReds.add(candidateHash);
                    continue;
                }

                if (checkBlueCandidate(null, candidateHash, k, mergesetBlues)) {
                    mergesetBlues.add(candidateHash);
                } else {
                    mergesetReds.add(candidateHash);
                }
            }

            // Save debug stats
            State.dagknight.lastCheckBlueStats = getCheckBlueStats();
            State.dagknight.lastMergesetSize = mergeset.length;

            const result = {
                selectedParent,
                mergesetBlues,
                mergesetReds,
                blueScore: mergesetBlues.size + 1,  // +1 for selected parent
            };

            // Cache result (limit cache size)
            if (State.dagknight.kColouringCache.size < 1000) {
                State.dagknight.kColouringCache.set(cacheKey, result);
            }

            State.dagknight.perf.kColouring.time += performance.now() - start;
            return result;
        }

        // --- Step 4: DagknightExecutor - dkoder-aligned incremental processing ---

        // getBlueWorkForSort: Get blue_work for sorting (from global GHOSTDAG data)
        // blueWork is stored as hex string from API, convert to BigInt for numeric comparison
        function getBlueWorkForSort(hash) {
            const idx = State.blockHashToIndex.get(hash);
            if (idx === undefined) return 0n;
            const hexStr = State.blockData.blueWork?.[idx];
            if (!hexStr || hexStr === '0') return 0n;
            // Convert hex string to BigInt (add 0x prefix)
            try {
                return BigInt('0x' + hexStr);
            } catch (e) {
                // Fallback: if not valid hex, try as decimal
                return BigInt(hexStr || 0);
            }
        }

        // getParentsInStore: Get parents that are already in blueWorkStore (dkoder approach)
        function getParentsInStore(blockHash, blueWorkStore) {
            const idx = State.blockHashToIndex.get(blockHash);
            if (idx === undefined) return [];

            const allParents = State.blockData.parentHashes[idx] || [];
            return allParents.filter(p => blueWorkStore.has(p));
        }

        // findSelectedParentFromStore: Find SP using stored blue_work (dkoder: find_selected_parent)
        function findSelectedParentFromStore(parents, blueWorkStore) {
            if (parents.length === 0) return null;
            if (parents.length === 1) return parents[0];

            let bestParent = parents[0];
            let bestWork = blueWorkStore.get(parents[0]) || 0n;

            for (let i = 1; i < parents.length; i++) {
                const work = blueWorkStore.get(parents[i]) || 0n;
                if (work > bestWork) {
                    bestWork = work;
                    bestParent = parents[i];
                }
            }

            return bestParent;
        }

        // getMergesetBounded: Get mergeset (anticone of SP among zone parents)
        function getMergesetBounded(selectedParent, parents, blockHash) {
            const mergeset = [];
            for (const parent of parents) {
                if (parent === selectedParent) continue;
                // In bounded context, we only check among the direct parents
                // Anticone = not ancestor and not descendant
                if (!isAncestor(parent, selectedParent, 30) &&
                    !isAncestor(selectedParent, parent, 30)) {
                    mergeset.push(parent);
                }
            }
            return sortBlocks(mergeset);
        }

        // checkBlueCandidateBounded: Check if candidate can be blue using bounded store
        function checkBlueCandidateBounded(blockHash, candidateHash, k, mergesetBlues, blueStatusStore) {
            // Check 1: current mergeset blues count <= k
            if (mergesetBlues.length > k) {
                return false;
            }

            // Check 2: candidate's blue anticone size <= k
            // Count blues in anticone of candidate
            let candidateAnticoneBlues = 0;
            for (const blueHash of mergesetBlues) {
                if (!isAncestor(blueHash, candidateHash, 30) &&
                    !isAncestor(candidateHash, blueHash, 30)) {
                    candidateAnticoneBlues++;
                }
            }
            if (candidateAnticoneBlues > k) {
                return false;
            }

            // Check 3: each existing blue's anticone with candidate <= k
            for (const blueHash of mergesetBlues) {
                let blueAnticoneWithCandidate = 0;
                // Count: candidate + other mergeset blues in anticone of this blue
                if (!isAncestor(blueHash, candidateHash, 30) &&
                    !isAncestor(candidateHash, blueHash, 30)) {
                    blueAnticoneWithCandidate++;
                }
                for (const otherBlue of mergesetBlues) {
                    if (otherBlue === blueHash) continue;
                    if (!isAncestor(blueHash, otherBlue, 30) &&
                        !isAncestor(otherBlue, blueHash, 30)) {
                        blueAnticoneWithCandidate++;
                    }
                }
                if (blueAnticoneWithCandidate > k) {
                    return false;
                }
            }

            return true;
        }

        // fillBoundedGhostdagData: dkoder-aligned incremental processing
        // Process zone blocks using heap-based topological order (by blue_work)
        function fillBoundedGhostdagData(root, zoneBlocks, tips, k) {
            const zoneSet = new Set(zoneBlocks);

            // Step 1: Initialize stores
            const blueWorkStore = new Map();   // hash -> BigInt blue_work
            const blueStatusStore = new Map(); // hash -> 'blue' | 'red'
            const mergesetBluesStore = new Map();  // hash -> array of mergeset blues
            const mergesetRedsStore = new Map();   // hash -> array of mergeset reds
            const selectedParentStore = new Map(); // hash -> selected parent

            // dkoder: Pre-insert root into store with 0 blue_work
            // This allows blocks with root as parent to be processed
            blueWorkStore.set(root, 0n);
            blueStatusStore.set(root, 'blue');

            // Step 2: Sort zone blocks by blue_work (ascending) - simulates heap
            const sortedByWork = [...zoneBlocks].sort((a, b) => {
                const workA = getBlueWorkForSort(a);
                const workB = getBlueWorkForSort(b);
                if (workA < workB) return -1;
                if (workA > workB) return 1;
                return 0;
            });

            // Debug counters
            let totalMergesetBlues = 0;
            let totalMergesetReds = 0;
            let blocksProcessed = 0;
            let skippedBlocks = 0;
            let iterations = 0;

            // Step 3: Process blocks - repeat until all are processed
            // dkoder uses heap; we iterate sorted list and skip if parents not ready
            const pending = new Set(sortedByWork);
            const maxIterations = zoneBlocks.length * 2;  // Safety limit

            while (pending.size > 0 && iterations < maxIterations) {
                iterations++;
                let processedThisRound = 0;

                for (const blockHash of sortedByWork) {
                    if (!pending.has(blockHash)) continue;

                    // dkoder: Get parents that are already in store
                    const parentsInStore = getParentsInStore(blockHash, blueWorkStore);

                    // Get ALL parents for this block
                    const idx = State.blockHashToIndex.get(blockHash);
                    if (idx === undefined) {
                        pending.delete(blockHash);
                        continue;
                    }
                    const allParents = State.blockData.parentHashes[idx] || [];

                    // Filter to zone-relevant parents (in zone or root)
                    const zoneParents = allParents.filter(p => zoneSet.has(p) || p === root);

                    // Skip if not all zone parents are in store yet
                    if (parentsInStore.length < zoneParents.length) {
                        skippedBlocks++;
                        continue;
                    }

                    // All zone parents are ready - process this block
                    pending.delete(blockHash);
                    blocksProcessed++;
                    processedThisRound++;

                    if (parentsInStore.length === 0) {
                        // No parents in store - orphaned in zone context
                        blueWorkStore.set(blockHash, 0n);
                        blueStatusStore.set(blockHash, 'blue');
                        continue;
                    }

                    // Find selected parent (highest blue_work among parents in store)
                    const selectedParent = findSelectedParentFromStore(parentsInStore, blueWorkStore);
                    selectedParentStore.set(blockHash, selectedParent);

                    // Get mergeset (anticone of SP among parents in store)
                    const mergeset = getMergesetBounded(selectedParent, parentsInStore, blockHash);

                    // k-colouring on mergeset (track perf like old kColouring)
                    const kColStart = performance.now();
                    State.dagknight.perf.kColouring.calls++;
                    const mergesetBlues = [];
                    const mergesetReds = [];

                    for (const candidate of mergeset) {
                        if (mergesetBlues.length >= k && k > 0) {
                            mergesetReds.push(candidate);
                            continue;
                        }

                        if (checkBlueCandidateBounded(blockHash, candidate, k, mergesetBlues, blueStatusStore)) {
                            mergesetBlues.push(candidate);
                            blueStatusStore.set(candidate, 'blue');
                        } else {
                            mergesetReds.push(candidate);
                            blueStatusStore.set(candidate, 'red');
                        }
                    }
                    State.dagknight.perf.kColouring.time += performance.now() - kColStart;

                    mergesetBluesStore.set(blockHash, mergesetBlues);
                    mergesetRedsStore.set(blockHash, mergesetReds);
                    totalMergesetBlues += mergesetBlues.length;
                    totalMergesetReds += mergesetReds.length;

                    // Calculate blue_work (dkoder formula):
                    // blue_work = SP.blue_work + sum(mergeset_blues work)
                    const spBlueWork = blueWorkStore.get(selectedParent) || 0n;
                    let addedBlueWork = 0n;
                    for (const blueHash of mergesetBlues) {
                        const bidx = State.blockHashToIndex.get(blueHash);
                        if (bidx !== undefined) {
                            addedBlueWork += calcWork(State.blockData.bits[bidx]);
                        }
                    }
                    const blockBlueWork = spBlueWork + addedBlueWork;
                    blueWorkStore.set(blockHash, blockBlueWork);

                    // The block itself is on the selected chain (implicitly blue)
                    blueStatusStore.set(blockHash, 'blue');
                }

                // If no progress, break to avoid infinite loop
                if (processedThisRound === 0) break;
            }

            // Step 4: Get final result from tips
            let finalBlueWork = 0n;
            let finalSelectedParent = null;
            let finalTip = tips[0];

            for (const tip of tips) {
                const tipBlueWork = blueWorkStore.get(tip) || 0n;
                if (tipBlueWork > finalBlueWork) {
                    finalBlueWork = tipBlueWork;
                    finalTip = tip;
                }
            }
            finalSelectedParent = selectedParentStore.get(finalTip);

            // Collect all blues and reds for coloring display
            const allMergesetBlues = new Set();
            const allMergesetReds = new Set();
            for (const [hash, blues] of mergesetBluesStore) {
                for (const b of blues) allMergesetBlues.add(b);
            }
            for (const [hash, reds] of mergesetRedsStore) {
                for (const r of reds) allMergesetReds.add(r);
            }

            // Count total blues (blocks on chain + mergeset blues)
            let chainBlueCount = 0;
            for (const [hash, status] of blueStatusStore) {
                if (status === 'blue' && !allMergesetBlues.has(hash)) {
                    chainBlueCount++;  // Blue but not from mergeset = on chain
                }
            }

            // Debug: track incremental processing stats
            State.dagknight.lastIncremental = {
                input: zoneBlocks.length,
                processed: blocksProcessed,
                pending: pending.size,
                iterations: iterations,
                mergesetBlues: totalMergesetBlues,
                mergesetReds: totalMergesetReds,
                chainBlues: chainBlueCount,
                finalBlueWork: finalBlueWork.toString().length,  // digits
            };

            return {
                selectedParent: finalSelectedParent,
                mergesetBlues: allMergesetBlues,
                mergesetReds: allMergesetReds,
                blueWork: finalBlueWork,
                blueCount: chainBlueCount + allMergesetBlues.size,
                blueStatusStore,  // For coloring
                k,
            };
        }

        // rank: Determine ranking by searching k-space (dkoder: rank)
        // Optimized: limit k search to 32 (usually k=0-5 is enough)
        function rank(conflictGenesis, subgroup, zoneWork, fullSubgroup) {
            const start = performance.now();
            State.dagknight.perf.rank.calls++;

            // Search for minimal k where blueWork >= zoneWork / 2
            const halfZoneWork = zoneWork / 2n;

            // Optimization: limit k search (increased to 64 for debugging)
            const MAX_K = 64;

            // Debug: track parent count
            State.dagknight.lastParentCount = subgroup.length;

            // Track blues at k=0 for comparison
            let bluesAtK0 = 0;

            for (let k = 0; k <= MAX_K; k++) {
                const data = fillBoundedGhostdagData(conflictGenesis, subgroup, subgroup, k);

                // Track k=0 blues
                if (k === 0) {
                    bluesAtK0 = data.blueCount;
                }

                // Debug: track zone/blue work and blue count
                State.dagknight.lastZoneWork = zoneWork.toString();
                State.dagknight.lastBlueWork = data.blueWork.toString();
                State.dagknight.lastBlueCount = data.blueCount;

                if (data.blueWork >= halfZoneWork) {
                    State.dagknight.lastK = k;
                    State.dagknight.lastKFound = true;  // Condition met!
                    State.dagknight.lastBluesAtK0 = bluesAtK0;
                    State.dagknight.perf.rank.time += performance.now() - start;
                    return {
                        k,
                        subgroupVirtual: data,
                    };
                }
            }

            // Fallback: use MAX_K (if still not found, something is wrong)
            const fallbackData = fillBoundedGhostdagData(conflictGenesis, subgroup, subgroup, MAX_K);
            State.dagknight.lastK = MAX_K;
            State.dagknight.lastKFound = false;  // Fallback - condition never met
            State.dagknight.lastBlueCount = fallbackData.blueCount;
            State.dagknight.lastBluesAtK0 = bluesAtK0;
            State.dagknight.perf.rank.time += performance.now() - start;
            return {
                k: MAX_K,
                subgroupVirtual: fallbackData,
            };
        }

        // dagknight: Main parent selection (dkoder: dagknight)
        // Returns { selectedParent, coloringResult, k } for batch coloring
        function dagknight(parentHashes) {
            // Debug: track early return reason
            State.dagknight.lastEarlyReturn = null;
            State.dagknight.lastParentHashCount = parentHashes?.length || 0;

            // Helper: create fallback result with k=18
            const fallbackResult = (selectedParent) => {
                const coloringResult = kColouring(parentHashes, 18);
                return {
                    selectedParent: selectedParent || coloringResult.selectedParent,
                    coloringResult,
                    k: 18,
                };
            };

            if (!parentHashes || parentHashes.length === 0) {
                State.dagknight.lastEarlyReturn = 'no-parents';
                return { selectedParent: null, coloringResult: null, k: 0 };
            }
            if (parentHashes.length === 1) {
                State.dagknight.lastEarlyReturn = 'single-parent';
                return {
                    selectedParent: parentHashes[0],
                    coloringResult: { selectedParent: parentHashes[0], mergesetBlues: new Set(), mergesetReds: new Set() },
                    k: 0,
                };
            }

            // Step 1: Find conflict genesis (LCCA)
            const conflictGenesis = commonChainAncestor(parentHashes);
            State.dagknight.lastConflictGenesis = conflictGenesis ? 'found' : 'null';
            if (!conflictGenesis) {
                State.dagknight.lastEarlyReturn = 'no-genesis';
                return fallbackResult(null);
            }

            // Step 2: Calculate zone work AND get zone blocks
            const { zoneWork, zoneBlocks } = calcConflictZoneWork(conflictGenesis, parentHashes);
            // Debug: store actual zoneWork value
            State.dagknight.lastZoneWorkRaw = zoneWork.toString();
            State.dagknight.lastZoneBlocksLen = zoneBlocks.length;

            if (zoneWork === 0n) {
                State.dagknight.lastEarlyReturn = 'zoneWork=0';
                return fallbackResult(null);
            }

            // Step 2.5: Compute intervals for O(1) ancestor checks (dkoder: reachability_service)
            const zoneSet = new Set(zoneBlocks);
            zoneSet.add(conflictGenesis);  // Include root
            computeIntervals(conflictGenesis, zoneSet);

            // Step 3: Rank using zone blocks (same blocks used for zoneWork)
            State.dagknight.lastEarlyReturn = 'rank-called';
            const rankResult = rank(conflictGenesis, zoneBlocks, zoneWork, parentHashes);

            // Return full result for batch coloring
            const selectedParent = rankResult.subgroupVirtual.selectedParent || findSelectedParent(parentHashes);
            return {
                selectedParent,
                coloringResult: rankResult.subgroupVirtual,
                k: rankResult.k,
            };
        }

        // --- Step 5: CascadeTree Functions (Confirmation) ---

        // cascadeTreeInsert: Add block to cascade tree (dkoder: CascadeTree::insert)
        function cascadeTreeInsert(hash, pastBlues, pastReds, anticoneBlues, arlb) {
            const { cascadeTree } = State.dagknight;
            cascadeTree.pastBlues.set(hash, pastBlues);
            cascadeTree.pastReds.set(hash, pastReds);
            cascadeTree.anticoneBlues.set(hash, anticoneBlues);
            cascadeTree.arlb.set(hash, arlb);

            // Calculate floor
            // floor = pastReds + arlb - pastBlues - anticoneBlues
            const floor = pastReds + arlb - pastBlues - anticoneBlues;
            cascadeTree.floor.set(hash, floor);
        }

        // updateAnticoneBlues: Update anticone blue count (dkoder: CascadeTree::update_anticone_blues)
        function updateAnticoneBlues(hash, count) {
            const { cascadeTree } = State.dagknight;
            cascadeTree.anticoneBlues.set(hash, count);

            // Recalculate floor
            const pastBlues = cascadeTree.pastBlues.get(hash) || 0;
            const pastReds = cascadeTree.pastReds.get(hash) || 0;
            const arlb = cascadeTree.arlb.get(hash) || 0;
            const floor = pastReds + arlb - pastBlues - count;
            cascadeTree.floor.set(hash, floor);
        }

        // peekMin: Get block with minimum floor (dkoder: CascadeTree::peek_min)
        function peekMin() {
            const { cascadeTree } = State.dagknight;
            let minHash = null;
            let minFloor = Infinity;

            for (const [hash, floor] of cascadeTree.floor) {
                if (floor < minFloor) {
                    minFloor = floor;
                    minHash = hash;
                }
            }

            return { hash: minHash, floor: minFloor };
        }

        // updateConfirmationState: Update block confirmation based on DAGknight (dkoder-compliant)
        function updateConfirmationState(blockHash, coloringResult) {
            const { d, PENDING, BLUE, RED } = State.dagknight;
            const idx = State.blockHashToIndex.get(blockHash);
            if (idx === undefined) return;

            // Get floor value
            const { cascadeTree } = State.dagknight;
            const floor = cascadeTree.floor.get(blockHash);

            // Check if confirmed (floor >= -d)
            if (floor !== undefined && floor >= -d) {
                // Determine blue or red from coloring result
                if (coloringResult.mergesetBlues.has(blockHash) ||
                    blockHash === coloringResult.selectedParent) {
                    State.blockData.confirmationState[idx] = BLUE;
                    State.blockData.color[idx] = CONFIG.COLORS.BLUE_BLOCK;
                    State.blockData.isBlue[idx] = 1;
                } else if (coloringResult.mergesetReds.has(blockHash)) {
                    State.blockData.confirmationState[idx] = RED;
                    State.blockData.color[idx] = CONFIG.COLORS.RED_BLOCK;
                    State.blockData.isBlue[idx] = 0;
                }
            }
            // else: stays PENDING
        }

        // ============================================================
        // End DAGknight Engine
        // ============================================================

        // ============================================================
        // Interval-based Reachability (dkoder: reachability_service)
        // ============================================================

        /**
         * Compute intervals for all blocks in the given set
         * Using DFS traversal from root, assign [start, end] intervals
         * This enables O(1) chain ancestor checks
         *
         * dkoder uses: store.get_interval(this)?.contains(store.get_interval(queried)?)
         */
        function computeIntervals(rootHash, blockSet) {
            const startTime = performance.now();
            State.dagknight.perf.computeIntervals.calls++;

            const { intervalMap } = State.dagknight;
            intervalMap.clear();
            State.dagknight.intervalCounter = 0;

            if (!rootHash || !blockSet || blockSet.size === 0) {
                State.dagknight.perf.computeIntervals.time += performance.now() - startTime;
                return;
            }

            // Build child map: parent → [children]
            // This is needed because we only store parentHashes, not childHashes
            const childMap = new Map();
            for (const hash of blockSet) {
                const idx = State.blockHashToIndex.get(hash);
                if (idx === undefined) continue;
                const parents = State.blockData.parentHashes[idx] || [];
                for (const parentHash of parents) {
                    if (!blockSet.has(parentHash)) continue;
                    if (!childMap.has(parentHash)) {
                        childMap.set(parentHash, []);
                    }
                    childMap.get(parentHash).push(hash);
                }
            }

            // DFS to assign intervals
            const visited = new Set();
            function dfs(hash) {
                if (visited.has(hash)) return;
                visited.add(hash);

                const start = State.dagknight.intervalCounter++;

                // Visit children (blocks that have this as parent)
                const children = childMap.get(hash) || [];
                for (const childHash of children) {
                    dfs(childHash);
                }

                const end = State.dagknight.intervalCounter++;
                intervalMap.set(hash, { start, end });
            }

            dfs(rootHash);

            // Also process any blocks not reachable from root
            for (const hash of blockSet) {
                if (!visited.has(hash)) {
                    dfs(hash);
                }
            }

            State.dagknight.perf.computeIntervals.time += performance.now() - startTime;
        }

        /**
         * Check if hashA is a CHAIN ancestor of hashB using intervals
         * This is O(1) - just interval containment check
         *
         * dkoder: is_chain_ancestor_of uses interval.contains()
         * A is ancestor of B if A.interval contains B.interval
         */
        function isChainAncestor(hashA, hashB) {
            const { intervalMap } = State.dagknight;
            const intervalA = intervalMap.get(hashA);
            const intervalB = intervalMap.get(hashB);

            if (!intervalA || !intervalB) return null;  // Unknown, need fallback

            // A contains B means A.start <= B.start && B.end <= A.end
            return intervalA.start <= intervalB.start && intervalB.end <= intervalA.end;
        }

        // ============================================================
        // End Interval-based Reachability
        // ============================================================

        // Step 2.2: Reachability - Check if blockA is ancestor of blockB
        function isAncestor(hashA, hashB, maxDepth = 100) {
            const start = performance.now();
            State.dagknight.perf.isAncestor.calls++;

            if (hashA === hashB) {
                State.dagknight.perf.isAncestor.time += performance.now() - start;
                return true;
            }

            // Try O(1) interval check first (dkoder: is_chain_ancestor_of)
            const chainResult = isChainAncestor(hashA, hashB);
            if (chainResult === true) {
                State.dagknight.intervalChainHits++;
                State.dagknight.perf.isAncestor.time += performance.now() - start;
                return true;
            }
            if (chainResult === false) {
                // Interval says not chain ancestor - but might still be DAG ancestor
                // For now, we use this as strong negative signal
                // In full dkoder impl, would check future_covering_set here
                State.dagknight.intervalChainHits++;
                State.dagknight.perf.isAncestor.time += performance.now() - start;
                return false;
            }
            // chainResult === null means no interval data, fall through to BFS

            // Check cache (dkoder optimization)
            const cacheKey = hashA + ':' + hashB;
            const cached = State.dagknight.ancestorCache.get(cacheKey);
            if (cached !== undefined) {
                State.dagknight.ancestorCacheHits++;
                State.dagknight.perf.isAncestor.time += performance.now() - start;
                return cached;
            }
            State.dagknight.intervalChainMisses++;  // Fell back to BFS

            const visited = new Set();
            const queue = [hashB];
            let depth = 0;

            while (queue.length > 0 && depth < maxDepth) {
                const levelSize = queue.length;
                for (let i = 0; i < levelSize; i++) {
                    const currentHash = queue.shift();
                    if (currentHash === hashA) {
                        // Cache positive result
                        State.dagknight.ancestorCache.set(cacheKey, true);
                        State.dagknight.perf.isAncestor.time += performance.now() - start;
                        return true;
                    }
                    if (visited.has(currentHash)) continue;
                    visited.add(currentHash);

                    // Get parents of current block
                    const idx = State.blockHashToIndex.get(currentHash);
                    if (idx === undefined) continue;
                    const parents = State.blockData.parentHashes[idx] || [];
                    for (const parentHash of parents) {
                        if (!visited.has(parentHash)) {
                            queue.push(parentHash);
                        }
                    }
                }
                depth++;
            }

            // Cache negative result
            State.dagknight.ancestorCache.set(cacheKey, false);
            State.dagknight.perf.isAncestor.time += performance.now() - start;
            return false;
        }

        // Step 2.3: Find Latest Common Chain Ancestor (LCCA)
        function findLCCA(hashes) {
            const start = performance.now();
            State.perf.findLCCA.calls++;
            if (hashes.length === 0) { State.perf.findLCCA.time += performance.now() - start; return null; }
            if (hashes.length === 1) { State.perf.findLCCA.time += performance.now() - start; return hashes[0]; }

            // Build Selected Parent Chain for each hash (dkoder compliant)
            // Follow ONLY the selected parent (highest blue_work) at each step
            // Uses cache to avoid repeated blue_work comparisons
            const chains = hashes.map(hash => {
                const chain = new Set([hash]);
                let current = hash;
                for (let depth = 0; depth < 30; depth++) {
                    const idx = State.blockHashToIndex.get(current);
                    if (idx === undefined) break;
                    const parents = State.blockData.parentHashes[idx] || [];
                    if (parents.length === 0) break;

                    // Check cache first (dkoder optimization)
                    let selectedParent = State.selectedParentCache.get(current);
                    if (selectedParent === undefined) {
                        // Not in cache, compute and store
                        selectedParent = selectBestFromGroup(parents);
                        if (selectedParent) {
                            State.selectedParentCache.set(current, selectedParent);
                        }
                    } else {
                        State.perf.cacheHits++;
                    }

                    if (!selectedParent || chain.has(selectedParent)) break;
                    chain.add(selectedParent);
                    current = selectedParent;
                }
                return chain;
            });

            // Find common blocks across all Selected Parent Chains
            let common = chains[0];
            for (let i = 1; i < chains.length; i++) {
                common = new Set([...common].filter(x => chains[i].has(x)));
            }

            // Return the one with highest DAA score (latest = LCCA)
            let lcca = null;
            let maxDaa = -1;
            for (const hash of common) {
                const idx = State.blockHashToIndex.get(hash);
                if (idx !== undefined) {
                    const daa = State.blockData.daaScore[idx];
                    if (daa > maxDaa) {
                        maxDaa = daa;
                        lcca = hash;
                    }
                }
            }
            State.perf.findLCCA.time += performance.now() - start;
            return lcca;
        }

        // Step 2.4: Group blocks by conflict zone origin
        // Returns Map<conflictOriginHash, blockHash[]>
        function groupByConflictZone(blockHashes, lccaHash) {
            const groups = new Map();  // conflictOrigin -> [blockHashes]

            for (const blockHash of blockHashes) {
                // Find the first block after LCCA on path from block to LCCA
                const conflictOrigin = findConflictOrigin(blockHash, lccaHash);

                if (!groups.has(conflictOrigin)) {
                    groups.set(conflictOrigin, []);
                }
                groups.get(conflictOrigin).push(blockHash);
            }

            return groups;
        }

        // Find conflict origin: first block after LCCA on the path from block to LCCA
        function findConflictOrigin(blockHash, lccaHash) {
            if (blockHash === lccaHash) return lccaHash;

            // BFS from block to LCCA, tracking path
            const parent = new Map();  // child -> parent (for path reconstruction)
            const visited = new Set([blockHash]);
            const queue = [blockHash];

            while (queue.length > 0) {
                const current = queue.shift();
                if (current === lccaHash) break;

                const idx = State.blockHashToIndex.get(current);
                if (idx === undefined) continue;

                const parents = State.blockData.parentHashes[idx] || [];
                for (const p of parents) {
                    if (!visited.has(p)) {
                        visited.add(p);
                        parent.set(p, current);
                        queue.push(p);
                    }
                }
            }

            // Reconstruct path from LCCA back to block, return first child of LCCA
            if (!visited.has(lccaHash)) return blockHash;  // No path found

            let current = lccaHash;
            let prev = null;

            // Walk from LCCA to block via parent map (reversed)
            // We need to find the child of LCCA (first step away from LCCA toward block)
            const pathToBlock = [lccaHash];
            const lccaIdx = State.blockHashToIndex.get(lccaHash);
            if (lccaIdx === undefined) return blockHash;

            // Reverse: find which visited block has LCCA as parent
            for (const [child, p] of parent.entries()) {
                if (p === lccaHash || isAncestor(lccaHash, p, 5)) {
                    // This child is close to LCCA
                    if (isAncestor(child, blockHash, 50) || child === blockHash) {
                        return child;
                    }
                }
            }

            return blockHash;  // Fallback
        }

        // Step 2.5: Compare RankValue (k, blueWork, selectedParentHash)
        function compareRank(hashA, hashB) {
            State.perf.compareRank.calls++;
            const idxA = State.blockHashToIndex.get(hashA);
            const idxB = State.blockHashToIndex.get(hashB);
            if (idxA === undefined || idxB === undefined) return 0;

            // Compare blueWork (higher is better)
            // blueWork is hex string, convert with 0x prefix
            const workStrA = State.blockData.blueWork[idxA] || '0';
            const workStrB = State.blockData.blueWork[idxB] || '0';

            try {
                const blueWorkA = BigInt('0x' + workStrA.replace(/^0x/, ''));
                const blueWorkB = BigInt('0x' + workStrB.replace(/^0x/, ''));

                if (blueWorkA > blueWorkB) return -1;  // A wins
                if (blueWorkA < blueWorkB) return 1;   // B wins
            } catch (e) {
                // Fallback: compare as strings
                if (workStrA > workStrB) return -1;
                if (workStrA < workStrB) return 1;
            }

            // Tiebreaker: hash (lexicographic, lower wins)
            if (hashA < hashB) return -1;
            if (hashA > hashB) return 1;

            return 0;
        }

        // Step 2.6: Select best block from a group using RankValue
        function selectBestFromGroup(blockHashes) {
            const start = performance.now();
            State.perf.selectBest.calls++;
            if (blockHashes.length === 0) { State.perf.selectBest.time += performance.now() - start; return null; }
            if (blockHashes.length === 1) { State.perf.selectBest.time += performance.now() - start; return blockHashes[0]; }

            let best = blockHashes[0];
            for (let i = 1; i < blockHashes.length; i++) {
                if (compareRank(blockHashes[i], best) < 0) {
                    best = blockHashes[i];
                }
            }
            State.perf.selectBest.time += performance.now() - start;
            return best;
        }

        // Step 2.7: DAGknight Parent Selection (hierarchical conflict resolution)
        function selectParent(parentHashes, depth = 0) {
            const start = performance.now();
            State.perf.selectParent.calls++;
            // Prevent infinite recursion
            if (depth > 10) { State.perf.selectParent.time += performance.now() - start; return selectBestFromGroup(parentHashes); }

            if (parentHashes.length === 0) { State.perf.selectParent.time += performance.now() - start; return null; }
            if (parentHashes.length === 1) { State.perf.selectParent.time += performance.now() - start; return parentHashes[0]; }

            // Find LCCA
            const lcca = findLCCA(parentHashes);
            if (!lcca) { State.perf.selectParent.time += performance.now() - start; return selectBestFromGroup(parentHashes); }

            // Group by conflict zone
            const groups = groupByConflictZone(parentHashes, lcca);

            // If only one group, select best from that group
            if (groups.size <= 1) {
                State.perf.selectParent.time += performance.now() - start;
                return selectBestFromGroup(parentHashes);
            }

            // Select best block from each group
            const groupWinners = [];
            for (const [origin, members] of groups.entries()) {
                const winner = selectBestFromGroup(members);
                if (winner) groupWinners.push(winner);
            }

            // Recursively select among group winners (with depth limit)
            State.perf.selectParent.time += performance.now() - start;
            return selectParent(groupWinners, depth + 1);
        }

        // Step 2.8: Build Selected Chains from each Tip
        // Returns array of edges: [[from, to], [from, to], ...]
        // Also collects all ancestors (for topological ordering / Y=0 convergence)
        function buildSelectedChains(tipHashes, maxDepth = 50) {
            const edges = [];           // [fromHash, toHash] pairs for selected chain
            const visited = new Set();  // Avoid duplicate edges after merge
            const chainBlocks = new Set(); // Blocks on selected chain
            const orderedBlocks = new Set(); // All blocks that should be Y=0 (chain + ancestors)

            for (const tip of tipHashes) {
                let currentHash = tip;
                let depth = 0;

                while (currentHash && depth < maxDepth) {
                    const idx = State.blockHashToIndex.get(currentHash);
                    if (idx === undefined) break;

                    chainBlocks.add(currentHash);
                    orderedBlocks.add(currentHash);

                    const parents = State.blockData.parentHashes[idx] || [];
                    if (parents.length === 0) break;

                    // Add ALL parents to orderedBlocks (they are topologically ordered)
                    for (const p of parents) {
                        orderedBlocks.add(p);
                        // Recursively add ancestors of non-selected parents too
                        collectAncestors(p, orderedBlocks, 30);
                    }

                    // Select parent for this block (for chain edge)
                    const selectedParent = selectParent(parents);
                    if (!selectedParent) break;

                    // Add edge if not already visited (avoid duplicates after merge)
                    const edgeKey = `${currentHash}->${selectedParent}`;
                    if (!visited.has(edgeKey)) {
                        visited.add(edgeKey);
                        edges.push([currentHash, selectedParent]);
                    }

                    currentHash = selectedParent;
                    depth++;
                }
            }

            return { edges, chainBlocks, orderedBlocks };
        }

        // Helper: Collect all ancestors up to maxDepth
        function collectAncestors(hash, resultSet, maxDepth) {
            if (maxDepth <= 0 || resultSet.has(hash)) return;

            const idx = State.blockHashToIndex.get(hash);
            if (idx === undefined) return;

            resultSet.add(hash);

            const parents = State.blockData.parentHashes[idx] || [];
            for (const p of parents) {
                collectAncestors(p, resultSet, maxDepth - 1);
            }
        }

        // ============================================================
        // Linearization Algorithm (DAGknight/GHOSTDAG compliant)
        // ============================================================

        // Check if 'ancestor' is an ancestor of 'block' (with depth limit)
        function isAncestorOf(ancestor, block, maxDepth = 30) {
            if (!block || !ancestor) return false;
            if (ancestor === block) return true;

            const visited = new Set();
            const queue = [block];
            let depth = 0;

            while (queue.length > 0 && depth < maxDepth) {
                const levelSize = queue.length;
                for (let i = 0; i < levelSize; i++) {
                    const current = queue.shift();
                    if (current === ancestor) return true;

                    const idx = State.blockHashToIndex.get(current);
                    if (idx === undefined) continue;

                    const parents = State.blockData.parentHashes[idx] || [];
                    for (const p of parents) {
                        if (!visited.has(p)) {
                            visited.add(p);
                            queue.push(p);
                        }
                    }
                }
                depth++;
            }

            return false;
        }

        // Compute Mergeset (dkoder-style): BFS from chainBlock, stop at selectedParent's ancestors
        // This only processes blocks in the "river" between chainBlock and selectedParent
        function computeMergeset(chainBlock, selectedParent) {
            const mergeset = [];
            if (!chainBlock) return mergeset;

            const idx = State.blockHashToIndex.get(chainBlock);
            if (idx === undefined) return mergeset;

            const parents = State.blockData.parentHashes[idx] || [];
            if (parents.length === 0) return mergeset;

            // BFS from chainBlock's parents (excluding selectedParent)
            const visited = new Set();
            const pastOfSelected = new Set();  // Blocks known to be in Past(selectedParent)
            const queue = [];

            for (const p of parents) {
                if (p !== selectedParent) {
                    queue.push(p);
                    visited.add(p);
                    mergeset.push(p);
                }
            }

            // BFS with stopping condition (like dkoder)
            let iterations = 0;
            const maxIterations = 200;  // Safety limit

            while (queue.length > 0 && iterations < maxIterations) {
                const current = queue.shift();
                iterations++;

                const currentIdx = State.blockHashToIndex.get(current);
                if (currentIdx === undefined) continue;

                const currentParents = State.blockData.parentHashes[currentIdx] || [];
                for (const parent of currentParents) {
                    if (visited.has(parent) || pastOfSelected.has(parent)) {
                        continue;
                    }

                    // Check if this parent is an ancestor of selectedParent (stop condition)
                    if (selectedParent && isAncestorOf(parent, selectedParent, 20)) {
                        pastOfSelected.add(parent);
                        continue;  // Don't add to mergeset, stop exploring this path
                    }

                    visited.add(parent);
                    mergeset.push(parent);
                    queue.push(parent);
                }
            }

            return mergeset;
        }

        // Sort blocks by blue_work ascending, then hash ascending (tiebreaker)
        function sortByBlueWork(hashes) {
            return hashes.sort((a, b) => {
                const idxA = State.blockHashToIndex.get(a);
                const idxB = State.blockHashToIndex.get(b);
                if (idxA === undefined || idxB === undefined) return 0;

                // Get blueWork as BigInt
                const workStrA = State.blockData.blueWork[idxA] || '0';
                const workStrB = State.blockData.blueWork[idxB] || '0';

                try {
                    const workA = BigInt('0x' + workStrA.replace(/^0x/, ''));
                    const workB = BigInt('0x' + workStrB.replace(/^0x/, ''));

                    // Ascending order (lower blue_work first)
                    if (workA < workB) return -1;
                    if (workA > workB) return 1;
                } catch (e) {
                    // Fallback: string comparison
                    if (workStrA < workStrB) return -1;
                    if (workStrA > workStrB) return 1;
                }

                // Tiebreaker: hash ascending
                if (a < b) return -1;
                if (a > b) return 1;

                return 0;
            });
        }

        // Build complete linear order from Selected Chain
        // Order: S0 → mergeset(S1) → S1 → mergeset(S2) → S2 → ...
        function buildLinearOrder(selectedChain) {
            if (selectedChain.length === 0) return [];

            const linearOrder = [];
            const addedToOrder = new Set();

            // Reverse chain to go from oldest to newest
            const chainOldestFirst = [...selectedChain].reverse();

            for (let i = 0; i < chainOldestFirst.length; i++) {
                const chainBlock = chainOldestFirst[i];
                const prevChainBlock = i > 0 ? chainOldestFirst[i - 1] : null;

                // Compute mergeset for this chain block
                const mergeset = computeMergeset(chainBlock, prevChainBlock);

                // Sort mergeset by blue_work ascending
                const sortedMergeset = sortByBlueWork(mergeset);

                // Add mergeset blocks (skip if already added)
                for (const hash of sortedMergeset) {
                    if (!addedToOrder.has(hash)) {
                        addedToOrder.add(hash);
                        linearOrder.push(hash);
                    }
                }

                // Add chain block itself
                if (!addedToOrder.has(chainBlock)) {
                    addedToOrder.add(chainBlock);
                    linearOrder.push(chainBlock);
                }
            }

            return linearOrder;
        }

        // Step 2.9: Run DAGknight calculation and update block positions
        function runDAGknightCalculation() {
            if (State.blockCount < 2) return;

            try {
                // Find all tips (blocks with no children)
                const allHashes = [];
                for (let i = 0; i < State.blockCount; i++) {
                    const hash = State.blockData.hashes[i];
                    if (hash) allHashes.push(hash);
                }

                // Find tips by checking which blocks are not parents of any other block
                const hasChild = new Set();
                for (let i = 0; i < State.blockCount; i++) {
                    const parents = State.blockData.parentHashes[i] || [];
                    for (const p of parents) {
                        hasChild.add(p);
                    }
                }

                const tips = allHashes.filter(h => !hasChild.has(h));
                if (tips.length === 0) return;

                // Build Selected Chains from tips (with timeout protection)
                const startTime = performance.now();
                const { edges, chainBlocks, orderedBlocks } = buildSelectedChains(tips.slice(0, 10));

                // Find LCCA (convergence point where all tip paths meet)
                const lccaHash = findLCCA(tips.slice(0, 10));
                State.lccaHash = lccaHash;

                // Build Single Selected Chain for linearization (dkoder compliant)
                // Start from best tip (highest blue_work), follow selected parents
                const bestTip = selectParent(tips);
                const chainList = [];
                let currentChainBlock = bestTip;
                const maxChainDepth = 100;

                while (currentChainBlock && chainList.length < maxChainDepth) {
                    chainList.push(currentChainBlock);

                    const idx = State.blockHashToIndex.get(currentChainBlock);
                    if (idx === undefined) break;

                    const parents = State.blockData.parentHashes[idx] || [];
                    if (parents.length === 0) break;

                    // Select next chain block (highest blue_work parent)
                    currentChainBlock = selectParent(parents);
                }
                // chainList is now [bestTip, parent1, parent2, ...] = newest to oldest

                // Build linear order (DAGknight compliant)
                const linearOrder = buildLinearOrder(chainList);
                const calcTime = performance.now() - startTime;

                // Accumulate ALL edges (keep until blocks are deleted)
                // Classification (green/blue) happens at render time using targetX
                const survivingOldEdges = [];
                if (State.selectedChainEdges) {
                    for (const [fromHash, toHash] of State.selectedChainEdges) {
                        const idx1 = State.blockHashToIndex.get(fromHash);
                        const idx2 = State.blockHashToIndex.get(toHash);
                        if (idx1 !== undefined && idx2 !== undefined) {
                            survivingOldEdges.push([fromHash, toHash]);
                        }
                    }
                }

                // Merge: old surviving edges + new edges (deduplicated)
                const edgeSet = new Set();
                const mergedEdges = [];

                for (const edge of survivingOldEdges) {
                    const key = `${edge[0]}->${edge[1]}`;
                    if (!edgeSet.has(key)) {
                        edgeSet.add(key);
                        mergedEdges.push(edge);
                    }
                }

                for (const edge of edges) {
                    const key = `${edge[0]}->${edge[1]}`;
                    if (!edgeSet.has(key)) {
                        edgeSet.add(key);
                        mergedEdges.push(edge);
                    }
                }

                State.selectedChainEdges = mergedEdges;

                State.selectedChainBlocks = chainBlocks;
                State.orderedBlocks = orderedBlocks;
                State.linearOrder = linearOrder;

                State.debug = {
                    tips: tips.length,
                    chainLen: chainList.length,
                    linearLen: linearOrder.length,
                    calcTime: calcTime.toFixed(1),
                };

                // --- DAGknight Coloring: Dynamic k-search with caching ---
                // Reset perf counters for this calculation cycle
                const dk = State.dagknight.perf;
                dk.isAncestor = { calls: 0, time: 0 };
                dk.commonChainAncestor = { calls: 0, time: 0 };
                dk.calcConflictZoneWork = { calls: 0, time: 0 };
                dk.computeIntervals = { calls: 0, time: 0 };
                dk.kColouring = { calls: 0, time: 0 };
                dk.rank = { calls: 0, time: 0 };
                // Reset interval-based reachability counters
                State.dagknight.intervalChainHits = 0;
                State.dagknight.intervalChainMisses = 0;

                const { PENDING, BLUE, RED } = State.dagknight;
                let coloredCount = 0;
                const processedParentSets = new Set();  // Cache: avoid duplicate calculations

                // Process from tips backwards - each tip confirms its parents
                // Limit processing to avoid performance issues
                const tipsToProcess = tips.slice(0, 20);  // Process up to 20 tips

                for (const tipHash of tipsToProcess) {
                    const tipIdx = State.blockHashToIndex.get(tipHash);
                    if (tipIdx === undefined) continue;

                    const parents = State.blockData.parentHashes[tipIdx] || [];
                    if (parents.length === 0) continue;

                    // Cache key: sorted parent hashes
                    const parentsKey = parents.slice().sort().join(',');
                    if (processedParentSets.has(parentsKey)) continue;
                    processedParentSets.add(parentsKey);

                    // DAGknight: Call main function (dkoder-aligned structure)
                    const dkResult = dagknight(parents);
                    const coloringResult = dkResult.coloringResult;
                    const usedK = dkResult.k;

                    // Skip if no valid coloring result
                    if (!coloringResult) continue;

                    // Update confirmation state for parents
                    for (const parentHash of parents) {
                        const parentIdx = State.blockHashToIndex.get(parentHash);
                        if (parentIdx === undefined) continue;

                        // Only update if still pending
                        if (State.blockData.confirmationState[parentIdx] !== PENDING) continue;

                        // Determine blue or red based on DAGknight coloring
                        if (parentHash === coloringResult.selectedParent ||
                            coloringResult.mergesetBlues.has(parentHash)) {
                            State.blockData.confirmationState[parentIdx] = BLUE;
                            State.blockData.color[parentIdx] = CONFIG.COLORS.BLUE_BLOCK;
                            State.blockData.isBlue[parentIdx] = 1;
                        } else if (coloringResult.mergesetReds.has(parentHash)) {
                            State.blockData.confirmationState[parentIdx] = RED;
                            State.blockData.color[parentIdx] = CONFIG.COLORS.RED_BLOCK;
                            State.blockData.isBlue[parentIdx] = 0;
                        } else {
                            // Ancestor of selected parent - blue
                            State.blockData.confirmationState[parentIdx] = BLUE;
                            State.blockData.color[parentIdx] = CONFIG.COLORS.BLUE_BLOCK;
                            State.blockData.isBlue[parentIdx] = 1;
                        }
                        coloredCount++;
                    }

                    // Store the k value used
                    State.dagknight.coloringK.set(tipHash, usedK);
                }

                // Also color any remaining hasChild blocks that weren't processed
                // (older blocks not reachable from current tips)
                for (let i = 0; i < State.blockCount; i++) {
                    if (State.blockData.confirmationState[i] !== PENDING) continue;
                    const blockHash = State.blockData.hashes[i];
                    if (!blockHash) continue;

                    if (hasChild.has(blockHash)) {
                        // Has children but wasn't processed - mark as Blue
                        State.blockData.confirmationState[i] = BLUE;
                        State.blockData.color[i] = CONFIG.COLORS.BLUE_BLOCK;
                        State.blockData.isBlue[i] = 1;
                        coloredCount++;
                    }
                }

                // Debug: track stats
                State.dagknight.lastColoredCount = coloredCount;
                State.dagknight.lastProcessedTips = tipsToProcess.length;
                // --- End DAGknight Coloring ---

                // Assign linearIndex and targetX to linearized blocks
                // Screen-relative: newest at SPAWN_X, oldest spreads left
                const maxLinearIdx = linearOrder.length - 1;
                const SPAWN_X = CONFIG.SPAWN_X;

                // Build hash→index map for O(1) lookup (fixes O(n²) indexOf issue)
                const linearOrderMap = new Map();
                for (let idx = 0; idx < linearOrder.length; idx++) {
                    linearOrderMap.set(linearOrder[idx], idx);
                }

                for (let i = 0; i < State.blockCount; i++) {
                    const hash = State.blockData.hashes[i];
                    const linearIdx = linearOrderMap.has(hash) ? linearOrderMap.get(hash) : -1;

                    if (linearIdx !== -1) {
                        // Block is linearized - right aligned from SPAWN_X
                        // linearIdx=max (newest) → X=SPAWN_X
                        // linearIdx=0 (oldest) → X=SPAWN_X - maxLinearIdx*PITCH (goes left)
                        State.blockData.linearIndex[i] = linearIdx;
                        State.blockData.targetX[i] = SPAWN_X - (maxLinearIdx - linearIdx) * CONFIG.LINEAR_PITCH;
                        State.blockData.targetY[i] = 0;
                        State.blockData.isBlue[i] = 1;
                    } else {
                        // Block not yet linearized - place just right of SPAWN_X
                        State.blockData.linearIndex[i] = -1;
                        State.blockData.targetX[i] = SPAWN_X + 20;
                        // targetY stays at random position
                    }
                }

                // Viewport stays fixed at center (0, 0)
                // No scrolling needed with screen-relative coordinates

                // Cleanup: Remove blocks that have scrolled too far left
                let removedCount = 0;
                for (let i = 0; i < State.blockCount; i++) {
                    const hash = State.blockData.hashes[i];
                    if (!hash) continue;

                    // Check if block is too far left (past cleanup threshold)
                    if (State.blockData.x[i] < CONFIG.CLEANUP_THRESHOLD) {
                        // Remove from hash map
                        State.blockHashToIndex.delete(hash);
                        // Clear the slot
                        State.blockData.hashes[i] = null;
                        removedCount++;
                    }
                }

                if (removedCount > 0) {
                    State.debug.removed = removedCount;
                }
            } catch (error) {
                State.debug = { error: error.message };
                console.error('DAGknight calculation error:', error);
            }
        }

        // ------------------------------------------------------------
        // Block Management
        // ------------------------------------------------------------
        function addBlock(blockInfo) {
            const index = State.ringHead;

            // Remove oldest block BEFORE overwriting (Ring Buffer bug fix)
            if (State.blockCount >= CONFIG.MAX_BLOCKS) {
                const oldestHash = State.blockData.hashes[index];
                State.blockHashToIndex.delete(oldestHash);
            }

            // Store hash (WASM SDK uses header.hash, not block.hash)
            const hash = blockInfo.header.hash;
            State.blockData.hashes[index] = hash;
            State.blockHashToIndex.set(hash, index);

            // Calculate position using relative coordinates (avoids Float32 precision issues)
            const daaScore = Number(blockInfo.header.daaScore);
            State.blockData.daaScore[index] = daaScore;

            // Set reference point on first block
            if (State.minDaaScore === null) {
                State.minDaaScore = daaScore;
                State.maxDaaScore = daaScore;
            }

            // Track DAA score range (for reference)
            if (daaScore > State.maxDaaScore) {
                State.maxDaaScore = daaScore;
            }

            // X = SPAWN_X (screen-relative: right side of center)
            // Small random offset to spread tips visually
            const tipOffset = 10 + Math.random() * 30;
            State.blockData.x[index] = CONFIG.SPAWN_X + tipOffset;

            // Y = random (spread vertically around center)
            const randomY = (Math.random() - 0.5) * 300;
            State.blockData.y[index] = randomY;
            State.blockData.targetY[index] = randomY;  // Same as y initially

            // X target = same as X initially (will be updated by linearization)
            State.blockData.targetX[index] = State.blockData.x[index];
            State.blockData.linearIndex[index] = -1;  // Not linearized yet

            // Store blueScore, blueWork, and bits for DAGknight calculation
            State.blockData.blueScore[index] = Number(blockInfo.header.blueScore || 0);
            State.blockData.blueWork[index] = blockInfo.header.blueWork || '0';
            State.blockData.bits[index] = Number(blockInfo.header.bits || 0);

            // Color: Start as Pending (gray), will be confirmed when child arrives
            State.blockData.color[index] = CONFIG.COLORS.PENDING_BLOCK;
            State.blockData.confirmationState[index] = 0;  // 0 = Pending
            State.blockData.isBlue[index] = 1;  // Default to blue (will be updated)
            State.blockData.size[index] = CONFIG.BLOCK_SIZE;

            // Store parent hashes (resolved dynamically in renderDAG)
            // WASM SDK uses parentsByLevel - only use level 0 (direct parents)
            const parentsByLevel = blockInfo.header.parentsByLevel || [];
            const parents = [...(parentsByLevel[0] || [])];  // Copy to avoid mutation

            // Phase 3: Add dummy tips as additional parents (high BPS simulation)
            // Limited to MAX_DUMMY_PARENTS to prevent explosion
            if (CONFIG.DUMMY.ENABLED && State.dummyTips.size > 0) {
                const dummyParentsToAdd = [];
                let addedCount = 0;

                for (const [dummyHash, selectCount] of State.dummyTips) {
                    // Limit dummy parents per block
                    if (addedCount >= CONFIG.DUMMY.MAX_DUMMY_PARENTS) break;

                    // Add dummy as parent
                    dummyParentsToAdd.push(dummyHash);
                    addedCount++;

                    // Increment select count
                    const newCount = selectCount + 1;
                    if (newCount >= CONFIG.DUMMY.MAX_PARENT_SELECT) {
                        // Remove from tips (has been selected enough times)
                        State.dummyTips.delete(dummyHash);
                    } else {
                        State.dummyTips.set(dummyHash, newCount);
                    }
                }
                // Add limited dummy parents to the block's parents
                parents.push(...dummyParentsToAdd);
            }

            State.blockData.parentHashes[index] = parents;

            // DAGknight: Block starts as Pending (gray)
            // Actual blue/red coloring is computed in updateDAGknight() every 0.5s
            // This keeps addBlock() lightweight for high BPS

            // Update ring buffer
            State.ringHead = (State.ringHead + 1) % CONFIG.MAX_BLOCKS;
            if (State.blockCount < CONFIG.MAX_BLOCKS) {
                State.blockCount++;
            }

            // Viewport stays at center (0, 0) - no need to update

            // Update UI
            DOM.blockCount.textContent = State.blockCount.toLocaleString();
        }

        // ------------------------------------------------------------
        // Kaspa SDK Integration
        // ------------------------------------------------------------
        async function initKaspaSDK() {
            updateLoadingText('Loading Kaspa SDK...');

            try {
                // Dynamic import of local Kaspa WASM SDK
                const kaspa = await import('./kaspa-core.js');
                console.log('kaspa-core.js imported');

                // Initialize WASM binary
                await kaspa.default({ module_or_path: './kaspa-core_bg.wasm' });
                console.log('WASM binary initialized');

                // Store kaspa module in state for later use
                State.kaspa = kaspa;

                updateLoadingText('Connecting to network...');

                // Create RPC client
                const resolver = new kaspa.Resolver();
                State.rpcClient = new kaspa.RpcClient({
                    resolver,
                    networkId: 'mainnet',
                });

                // Connect
                await State.rpcClient.connect();

                // Get initial info
                const info = await State.rpcClient.getBlockDagInfo();
                console.log('Connected to Kaspa network:', info);

                // Update UI
                State.isConnected = true;
                DOM.status.classList.add('connected');
                DOM.connectionStatus.textContent = 'Connected';
                DOM.networkName.textContent = 'Mainnet';
                DOM.blueScore.textContent = Number(info.virtualDaaScore).toLocaleString();

                // Subscribe to new blocks
                await subscribeToBlocks();

                return kaspa;
            } catch (error) {
                console.error('Failed to initialize Kaspa SDK:', error);
                DOM.connectionStatus.textContent = 'Error: ' + error.message;
                throw error;
            }
        }

        async function subscribeToBlocks() {
            updateLoadingText('Subscribing to blocks...');

            // Subscribe to block added notifications
            State.rpcClient.addEventListener('block-added', async (event) => {
                if (State.isPaused) return;

                try {
                    const block = event.data.block;
                    // block-added event already contains full block info
                    addBlock(block);

                    // Generate dummy blocks for high BPS simulation (Phase 2)
                    generateDummyBlocks(block);
                } catch (error) {
                    console.warn('Failed to process block:', error);
                }
            });

            // Start subscription
            await State.rpcClient.subscribeBlockAdded();

            console.log('Subscribed to block notifications');
        }

        // ------------------------------------------------------------
        // UI Updates
        // ------------------------------------------------------------
        function updateLoadingText(text) {
            DOM.loadingText.textContent = text;
        }

        function hideLoading() {
            DOM.loading.classList.add('hidden');
        }

        function updateStatsDisplay() {
            // FPS
            DOM.fpsDisplay.textContent = `${State.stats.fps} FPS`;
            DOM.fpsDisplay.className = 'fps';
            if (State.stats.fps < 30) {
                DOM.fpsDisplay.classList.add('critical');
            } else if (State.stats.fps < 50) {
                DOM.fpsDisplay.classList.add('warning');
            }

            // Draw calls and visible blocks
            DOM.drawCalls.textContent = `Draws: ${State.stats.drawCalls} | Visible: ${State.stats.visibleBlocks}`;

            // Memory (if available)
            if (performance.memory) {
                const mb = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                DOM.memoryUsage.textContent = `Mem: ${mb}MB | Edges: ${State.stats.edgeCount}`;
            } else {
                DOM.memoryUsage.textContent = `Edges: ${State.stats.edgeCount}`;
            }

            // Debug info (multi-line for readability)
            if (DOM.debugInfo) {
                const lines = [];

                // Line 1: Version and timing
                let line1 = `${CONFIG.VERSION}`;
                if (State.debug?.error) {
                    line1 += ` | ERR: ${State.debug.error}`;
                } else if (State.debug) {
                    line1 += ` | T:${State.debug.calcTime}ms`;
                    const dk = State.dagknight.perf;
                    line1 += ` | zoneW:${dk.calcConflictZoneWork.time.toFixed(0)}ms`;
                    line1 += ` intv:${dk.computeIntervals.time.toFixed(0)}ms`;
                    line1 += ` isAnc:${dk.isAncestor.calls}x/${dk.isAncestor.time.toFixed(0)}ms`;
                    line1 += ` kCol:${dk.kColouring.calls}x/${dk.kColouring.time.toFixed(0)}ms`;
                    line1 += ` rank:${dk.rank.calls}x/${dk.rank.time.toFixed(0)}ms`;
                    // Interval-based reachability stats (dkoder: O(1) vs BFS fallback)
                    const intHit = State.dagknight.intervalChainHits;
                    const intMiss = State.dagknight.intervalChainMisses;
                    if (intHit > 0 || intMiss > 0) {
                        const hitRate = intHit + intMiss > 0 ? ((intHit / (intHit + intMiss)) * 100).toFixed(0) : 0;
                        line1 += ` | int:${hitRate}%`; // Interval hit rate
                    }
                }
                lines.push(line1);

                // Line 2: dagknight flow debug
                if (State.debug && !State.debug.error) {
                    let line2 = `ret:${State.dagknight.lastEarlyReturn ?? '?'}`;
                    line2 += ` | parents:${State.dagknight.lastParentHashCount ?? 0}`;
                    line2 += ` genesis:${State.dagknight.lastConflictGenesis ?? '?'}`;
                    line2 += ` | zW:${State.dagknight.lastTotalWorkDigits ?? 0}桁`;
                    line2 += ` zBlks:${State.dagknight.lastZoneBlocksLen ?? 0}`;
                    lines.push(line2);

                    // Line 3: zone details
                    const kVal = State.dagknight.lastK ?? '-';
                    const kStatus = State.dagknight.lastKFound ? '✓' : '(MAX)';
                    let line3 = `k:${kVal}${kStatus}`;
                    if (State.dagknight.lastZoneBlockCount !== undefined) {
                        const valid = State.dagknight.lastValidBlockCount ?? 0;
                        const skipped = State.dagknight.lastSkippedCount ?? 0;
                        line3 += ` | zone:${valid}/${State.dagknight.lastZoneBlockCount}`;
                        if (skipped > 0) {
                            line3 += `(skip:${skipped})`;
                        }
                    }
                    // Show first bits values
                    if (State.dagknight.lastFirstBits?.length > 0) {
                        const fb = State.dagknight.lastFirstBits[0];
                        line3 += ` | 1st bits:${fb.bits ? '0x' + fb.bits.toString(16) : 'null'} w:${fb.work}桁`;
                    }
                    lines.push(line3);

                    // Line 4: Incremental processing stats (dkoder-aligned)
                    const inc = State.dagknight.lastIncremental;
                    if (inc) {
                        let line4 = `proc:${inc.processed}/${inc.input}`;
                        if (inc.pending > 0) line4 += `(pend:${inc.pending})`;
                        line4 += ` iter:${inc.iterations}`;
                        line4 += ` | bW:${inc.finalBlueWork}桁`;
                        lines.push(line4);

                        // Line 5: Blue composition
                        let line5 = `chain:${inc.chainBlues} mBlue:${inc.mergesetBlues} mRed:${inc.mergesetReds}`;
                        const bluesNow = State.dagknight.lastBlueCount ?? 0;
                        line5 += ` | total:${bluesNow}`;
                        lines.push(line5);
                    } else {
                        // Fallback to old format
                        const bluesNow = State.dagknight.lastBlueCount ?? 0;
                        let line4 = `blues:${bluesNow}`;
                        line4 += ` | col:${State.dagknight.lastColoredCount || 0}`;
                        lines.push(line4);
                    }

                    // Line 6: Detailed k-colouring stats (if available)
                    const stats = State.dagknight.lastCheckBlueStats;
                    if (stats && (stats.check1 > 0 || stats.check2 > 0 || stats.check3 > 0)) {
                        let line6 = `reject: c1:${stats.check1} c2:${stats.check2} c3:${stats.check3}`;
                        line6 += ` pass:${stats.passed}`;
                        lines.push(line6);
                    }
                }

                // Line 7: Dummy block simulation status
                if (CONFIG.DUMMY.ENABLED) {
                    const effectiveBPS = 1 + CONFIG.DUMMY.MULTIPLIER;
                    let lineDummy = `[DUMMY] ${effectiveBPS}x BPS`;
                    lineDummy += ` | gen:${State.dummyBlockCount}`;
                    lineDummy += ` tips:${State.dummyTips.size}`;
                    lines.push(lineDummy);
                } else {
                    lines.push(`[DUMMY] OFF`);
                }

                DOM.debugInfo.innerHTML = lines.join('<br>');
            }
        }

        // ------------------------------------------------------------
        // Controls
        // ------------------------------------------------------------
        function setupControls() {
            DOM.btnDisconnect.addEventListener('click', async () => {
                if (State.isConnected && State.rpcClient) {
                    try {
                        await State.rpcClient.disconnect();
                        State.isConnected = false;
                        DOM.connectionStatus.textContent = 'Disconnected';
                        DOM.connectionStatus.className = 'disconnected';
                        DOM.btnDisconnect.textContent = 'Connect';
                    } catch (e) {
                        console.error('Disconnect error:', e);
                    }
                } else {
                    // Reconnect
                    try {
                        await State.rpcClient.connect();
                        await State.rpcClient.subscribeBlockAdded();
                        State.isConnected = true;
                        DOM.connectionStatus.textContent = 'Connected';
                        DOM.connectionStatus.className = 'connected';
                        DOM.btnDisconnect.textContent = 'Disconnect';
                    } catch (e) {
                        console.error('Connect error:', e);
                    }
                }
            });

            DOM.btnPause.addEventListener('click', () => {
                State.isPaused = !State.isPaused;
                DOM.btnPause.textContent = State.isPaused ? 'Resume' : 'Pause';
            });

            DOM.btnReset.addEventListener('click', () => {
                // Clear all blocks
                State.blockCount = 0;
                State.ringHead = 0;
                State.ringTail = 0;
                State.blockHashToIndex.clear();
                State.viewport.x = 0;
                State.viewport.y = 0;
                DOM.blockCount.textContent = '0';
            });

            DOM.btnZoomIn.addEventListener('click', () => {
                State.viewport.zoom = Math.min(State.viewport.zoom * 1.2, 3);
            });

            DOM.btnZoomOut.addEventListener('click', () => {
                State.viewport.zoom = Math.max(State.viewport.zoom / 1.2, 0.2);
            });

            // Dummy block simulation controls
            function updateDummyUI() {
                // Update toggle button
                DOM.btnDummyToggle.textContent = CONFIG.DUMMY.ENABLED ? 'ON' : 'OFF';
                DOM.btnDummyToggle.classList.toggle('active', CONFIG.DUMMY.ENABLED);

                // Update multiplier buttons
                const mult = CONFIG.DUMMY.MULTIPLIER;
                DOM.btnDummy2x.classList.toggle('selected', mult === 1);
                DOM.btnDummy10x.classList.toggle('selected', mult === 9);
                DOM.btnDummy100x.classList.toggle('selected', mult === 99);
            }

            DOM.btnDummyToggle.addEventListener('click', () => {
                CONFIG.DUMMY.ENABLED = !CONFIG.DUMMY.ENABLED;
                updateDummyUI();
                console.log('[Dummy] Toggled:', CONFIG.DUMMY.ENABLED ? 'ON' : 'OFF');
            });

            DOM.btnDummy2x.addEventListener('click', () => {
                CONFIG.DUMMY.MULTIPLIER = 1;  // +1 = 2x BPS
                updateDummyUI();
            });

            DOM.btnDummy10x.addEventListener('click', () => {
                CONFIG.DUMMY.MULTIPLIER = 9;  // +9 = 10x BPS
                updateDummyUI();
            });

            DOM.btnDummy100x.addEventListener('click', () => {
                CONFIG.DUMMY.MULTIPLIER = 99;  // +99 = 100x BPS
                updateDummyUI();
            });

            // Pan with mouse drag
            let isDragging = false;
            let lastMouse = { x: 0, y: 0 };

            State.app.canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouse = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = (e.clientX - lastMouse.x) / State.viewport.zoom;
                const dy = (e.clientY - lastMouse.y) / State.viewport.zoom;
                State.viewport.x -= dx;
                State.viewport.y -= dy;
                lastMouse = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Zoom with mouse wheel
            State.app.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                State.viewport.zoom = Math.max(0.2, Math.min(3, State.viewport.zoom * zoomFactor));
            });
        }

        // ------------------------------------------------------------
        // Main
        // ------------------------------------------------------------
        async function main() {
            try {
                await initPixi();
                setupControls();
                await initKaspaSDK();
                hideLoading();
                console.log('DAGknight Visualizer initialized successfully');

                // Log dummy block configuration
                console.log('[Dummy] Configuration:', {
                    enabled: CONFIG.DUMMY.ENABLED,
                    multiplier: CONFIG.DUMMY.MULTIPLIER,
                    maxParentSelect: CONFIG.DUMMY.MAX_PARENT_SELECT,
                    effectiveBPS: CONFIG.DUMMY.ENABLED ? `${1 + CONFIG.DUMMY.MULTIPLIER}x` : '1x (real)',
                });
            } catch (error) {
                console.error('Initialization failed:', error);
                updateLoadingText('Error: ' + error.message);
            }
        }

        // Start
        main();
    </script>
</body>
</html>
