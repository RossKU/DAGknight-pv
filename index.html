<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kaspa DAGknight Protocol Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0A0E17;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #E0E0E0;
        }

        #app {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none;  /* Disable browser touch handling */
        }

        /* Status overlay */
        #status {
            position: absolute;
            top: 76px;
            left: 16px;
            z-index: 100;
            background: rgba(10, 14, 23, 0.85);
            border: 1px solid rgba(74, 144, 217, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 13px;
            backdrop-filter: blur(8px);
            min-width: 200px;
        }

        #status .title {
            font-size: 16px;
            font-weight: 600;
            color: #FFFFFF;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #status .title::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
            animation: pulse 2s infinite;
        }

        #status.connected .title::before {
            background: #00FF88;
        }

        #status .row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        #status .row:last-child {
            border-bottom: none;
        }

        #status .label {
            color: #888;
        }

        #status .value {
            color: #FFF;
            font-family: 'Consolas', monospace;
        }

        /* Stats overlay */
        #stats {
            position: absolute;
            top: 76px;
            right: 16px;
            z-index: 100;
            background: rgba(10, 14, 23, 0.85);
            border: 1px solid rgba(74, 144, 217, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 12px;
            backdrop-filter: blur(8px);
            font-family: 'Consolas', monospace;
        }

        #stats .fps {
            font-size: 24px;
            font-weight: bold;
            color: #00FF88;
        }

        #stats .fps.warning {
            color: #F1C40F;
        }

        #stats .fps.critical {
            color: #E74C3C;
        }

        /* Legend */
        #legend {
            position: absolute;
            bottom: 16px;
            left: 16px;
            z-index: 100;
            background: rgba(10, 14, 23, 0.85);
            border: 1px solid rgba(74, 144, 217, 0.3);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 12px;
            backdrop-filter: blur(8px);
            display: flex;
            gap: 16px;
        }

        #legend .item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #legend .color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .color-pending { background: #888888; }
        .color-blue { background: #4A90D9; }
        .color-red { background: #E74C3C; }
        .color-vspc { background: #00FF88; box-shadow: 0 0 8px #00FF88; }
        .color-lcca { background: #FFD700; box-shadow: 0 0 8px #FFD700; }

        /* Block Info Panel (shown during pause) */
        #block-info {
            position: absolute;
            bottom: 70px;
            left: 16px;
            z-index: 100;
            background: rgba(10, 14, 23, 0.9);
            border: 1px solid rgba(74, 144, 217, 0.5);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 11px;
            backdrop-filter: blur(8px);
            display: none;
            min-width: 200px;
            max-width: calc(100vw - 32px);
        }
        #block-info.visible { display: block; }
        #block-info .title {
            font-weight: bold;
            color: #4A90D9;
            margin-bottom: 8px;
            font-size: 12px;
        }
        #block-info .row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            gap: 12px;
        }
        #block-info .label { color: #888; }
        #block-info .value {
            color: #fff;
            font-family: monospace;
            word-break: break-all;
        }
        #block-info .hint {
            color: #666;
            font-size: 10px;
            margin-top: 8px;
            text-align: center;
        }
        #block-info.clickable {
            cursor: pointer;
            border-color: rgba(74, 144, 217, 0.8);
        }
        #block-info.clickable:hover {
            background: rgba(20, 30, 50, 0.95);
        }
        #block-info.clickable .hint {
            color: #4A90D9;
        }

        /* Header */
        #header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            text-align: center;
            padding: 12px 20px;
            background: rgba(10, 14, 23, 0.9);
            border-bottom: 1px solid rgba(74, 144, 217, 0.3);
            z-index: 100;
            backdrop-filter: blur(8px);
        }

        #header h1 {
            font-size: 20px;
            font-weight: 600;
            color: #FFFFFF;
            margin-bottom: 4px;
        }

        #header .subtitle {
            color: #888;
            font-size: 12px;
        }

        #header .logo {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
        }

        /* Controls */
        #controls {
            position: absolute;
            bottom: 16px;
            right: 16px;
            z-index: 100;
            display: flex;
            gap: 8px;
        }

        #controls button {
            background: rgba(74, 144, 217, 0.2);
            border: 1px solid rgba(74, 144, 217, 0.5);
            color: #4A90D9;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        #controls button:hover {
            background: rgba(74, 144, 217, 0.4);
            border-color: #4A90D9;
        }

        #controls button:active {
            transform: scale(0.98);
        }

        /* Dummy simulation controls */
        #dummy-controls {
            position: absolute;
            bottom: 60px;
            right: 16px;
            z-index: 100;
            display: flex;
            gap: 8px;
            align-items: center;
            background: rgba(10, 14, 23, 0.85);
            border: 1px solid rgba(74, 144, 217, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            backdrop-filter: blur(8px);
        }

        #dummy-controls .label {
            font-size: 12px;
            color: #888;
            margin-right: 4px;
        }

        #dummy-controls button {
            background: rgba(74, 144, 217, 0.2);
            border: 1px solid rgba(74, 144, 217, 0.5);
            color: #4A90D9;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        #dummy-controls button:hover {
            background: rgba(74, 144, 217, 0.4);
        }

        #dummy-controls button.active {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00FF88;
            color: #00FF88;
        }

        #dummy-controls button.multiplier.selected {
            background: rgba(255, 215, 0, 0.3);
            border-color: #FFD700;
            color: #FFD700;
        }

        /* View mode controls */
        #view-mode-controls {
            position: absolute;
            bottom: 104px;
            right: 16px;
            z-index: 100;
            display: flex;
            gap: 8px;
            align-items: center;
            background: rgba(10, 14, 23, 0.85);
            border: 1px solid rgba(74, 144, 217, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            backdrop-filter: blur(8px);
        }

        #view-mode-controls .label {
            font-size: 12px;
            color: #888;
            margin-right: 4px;
        }

        #view-mode-controls button {
            background: rgba(74, 144, 217, 0.2);
            border: 1px solid rgba(74, 144, 217, 0.5);
            color: #4A90D9;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        #view-mode-controls button:hover {
            background: rgba(74, 144, 217, 0.4);
        }

        #view-mode-controls button.selected {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00FF88;
            color: #00FF88;
        }

        /* Loading overlay */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0A0E17;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #loading .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(74, 144, 217, 0.2);
            border-top-color: #4A90D9;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        #loading .text {
            margin-top: 16px;
            color: #4A90D9;
            font-size: 14px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Hide panels when viewport is too small */
        @media (max-height: 500px) {
            #status, #stats {
                display: none;
            }
        }

        @media (max-width: 600px) {
            #status, #stats {
                display: none;
            }
            #header h1 {
                font-size: 16px;
            }
            #header .subtitle {
                font-size: 10px;
            }
            #header .logo {
                width: 30px;
                height: 30px;
            }
        }

        /* Tutorial */
        @keyframes gentle-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        #tutorial-btn {
            position: absolute;
            bottom: 150px;
            right: 16px;
            z-index: 100;
            background: rgba(74, 144, 217, 0.2);
            border: 1px solid rgba(74, 144, 217, 0.5);
            color: #4A90D9;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            animation: gentle-pulse 3s ease-in-out infinite;
        }
        #tutorial-btn:hover {
            background: rgba(74, 144, 217, 0.4);
            border-color: #4A90D9;
        }
        #tutorial-btn.clicked {
            animation: none;
        }
        #tutorial-btn .icon {
            font-size: 16px;
            font-weight: bold;
        }

        /* Tutorial Overlay - disabled */
        #tutorial-overlay {
            display: none !important;
        }

        /* Tutorial Modal */
        #tutorial-modal {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 501;
            background: rgba(10, 14, 23, 0.95);
            border: 1px solid rgba(74, 144, 217, 0.5);
            border-radius: 12px;
            padding: 24px 32px;
            width: 600px;
            max-width: calc(100% - 32px);
            height: 260px;
            backdrop-filter: blur(12px);
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #tutorial-modal.visible {
            display: block;
            opacity: 1;
        }
        #tutorial-modal .step-indicator {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }
        #tutorial-modal .step-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(74, 144, 217, 0.3);
            transition: all 0.3s;
        }
        #tutorial-modal .step-dot.active {
            background: #4A90D9;
            box-shadow: 0 0 8px #4A90D9;
        }
        #tutorial-modal .step-dot.completed {
            background: #00FF88;
        }
        #tutorial-modal .content {
            text-align: center;
            height: 120px;
            overflow: hidden;
        }
        #tutorial-modal .content h2 {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 16px;
            line-height: 1.4;
        }
        #tutorial-modal .content p {
            font-size: 14px;
            color: #aaa;
            line-height: 1.4;
            margin-bottom: 6px;
        }
        #tutorial-modal .content .highlight {
            color: #4A90D9;
            font-weight: 500;
        }
        #tutorial-modal .content .highlight-gold {
            color: #FFD700;
            font-weight: 500;
        }
        #tutorial-modal .content .highlight-green {
            color: #00FF88;
            font-weight: 500;
        }
        #tutorial-modal .content .highlight-gray {
            color: #888888;
            font-weight: 500;
        }
        #tutorial-modal .content .highlight-blue {
            color: #4A90D9;
            font-weight: 500;
        }
        #tutorial-modal .content .highlight-red {
            color: #E74C3C;
            font-weight: 500;
        }
        #tutorial-modal .content .big-number {
            font-size: 32px;
            font-weight: bold;
            color: #00FF88;
            display: block;
            margin: 12px 0;
        }
        #tutorial-modal .buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 24px;
            gap: 12px;
        }
        #tutorial-modal .btn {
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            border: none;
        }
        #tutorial-modal .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }
        #tutorial-modal .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }
        #tutorial-modal .btn-primary {
            background: rgba(74, 144, 217, 0.3);
            border: 1px solid #4A90D9;
            color: #4A90D9;
        }
        #tutorial-modal .btn-primary:hover {
            background: rgba(74, 144, 217, 0.5);
        }
        #tutorial-modal .btn-share {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00FF88;
            color: #00FF88;
        }
        #tutorial-modal .btn-share:hover {
            background: rgba(0, 255, 136, 0.3);
        }
        #tutorial-modal .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Spotlight highlight for tutorial */
        .tutorial-spotlight {
            box-shadow: 0 0 0 4px rgba(74, 144, 217, 0.8), 0 0 20px rgba(74, 144, 217, 0.5);
            border-radius: 8px;
            z-index: 502 !important;
        }

        /* Responsive: Portrait / Narrow screens */
        @media (max-width: 600px) {
            /* Top: Keep Network State, hide Debug State */
            #stats {
                display: none;
            }

            /* Bottom: Hide Legend (Block Type) to avoid collision with controls */
            #legend {
                display: none;
            }

            /* Adjust tutorial button position for narrow screens */
            #tutorial-btn {
                bottom: 160px;
                right: 8px;
            }

            /* Compact controls */
            #controls {
                right: 8px;
                gap: 4px;
            }
            #controls button {
                padding: 6px 10px;
                font-size: 11px;
            }

            #dummy-controls, #view-mode-controls {
                right: 8px;
                padding: 6px 8px;
            }
        }

        /* Very narrow screens (< 400px) */
        @media (max-width: 400px) {
            #status {
                left: 8px;
                min-width: 150px;
                font-size: 11px;
                padding: 8px 12px;
            }
            #status .title {
                font-size: 13px;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="canvas-container"></div>

        <div id="header">
            <h1>Kaspa DAGknight Protocol Visualizer</h1>
            <p class="subtitle">A Parameterless Generalization of Nakamoto Consensus</p>
            <svg class="logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 197.05 196.86">
                <defs><style>.logo-white{fill:#fff;}.logo-teal{fill:#6fc7ba;}</style></defs>
                <circle class="logo-white" cx="98.52" cy="98.43" r="41.03"></circle>
                <path class="logo-teal" d="m149.42,76.34c-2.8-6.76-7.22-13.03-12.32-18.12-5.08-5.1-11.61-8.91-18.38-11.71-6.51-2.71-13.78-4.07-21.28-4.07s-15.21.27-21.72,2.98c-6.76,2.8-12.42,8.12-17.51,13.22-5.1,5.1-11.02,10.51-13.82,17.26-2.71,6.53-1.83,14.48-1.83,21.99s.55,14.85,3.26,21.38c2.8,6.76,8.52,11.54,13.6,16.64,5.1,5.1,9.71,11.18,16.47,13.98,6.53,2.71,14.04,4.55,21.54,4.55s14.87-2.22,21.4-4.94c6.75-2.8,12.86-7.18,17.96-12.27,5.1-5.1,9.19-11.32,12.01-18.08,2.7-6.51,5.79-13.76,5.79-21.26s-2.48-15-5.19-21.53Zm-36.26,53.49l-11.88-1.75,3.39-23-24.87,19.16-7.32-9.56,21.82-16.8-21.82-16.81,7.32-9.56,24.87,19.16-3.39-22.99,11.88-1.77,4.73,31.98-4.73,31.96Z"></path>
            </svg>
        </div>

        <div id="status">
            <div class="title">Network State</div>
            <div class="row">
                <span class="label">Status</span>
                <span class="value" id="connection-status">Disconnected</span>
            </div>
            <div class="row">
                <span class="label">Network</span>
                <span class="value" id="network-name">-</span>
            </div>
            <div class="row">
                <span class="label">DAA Score</span>
                <span class="value" id="daa-score">-</span>
            </div>
            <div class="row">
                <span class="label">Blocks</span>
                <span class="value" id="block-count">0</span>
            </div>
        </div>

        <div id="stats">
            <div class="fps" id="fps-display">-- FPS</div>
            <div id="draw-calls">Draw calls: -</div>
            <div id="memory-usage">Memory: -</div>
            <div id="debug-info" style="font-size: 10px; color: #888; margin-top: 8px;"></div>
        </div>

        <div id="block-info">
            <div class="title">Block Info</div>
            <div class="row"><span class="label">Hash</span><span class="value" id="info-hash">-</span></div>
            <div class="row"><span class="label">DAA Score</span><span class="value" id="info-daa">-</span></div>
            <div class="row"><span class="label">Blue Score</span><span class="value" id="info-blue-score">-</span></div>
            <div class="row"><span class="label">Blue Work</span><span class="value" id="info-blue-work">-</span></div>
            <div class="hint" id="info-hint">Tap a block to inspect</div>
        </div>

        <div id="legend">
            <div class="item"><div class="color color-pending"></div> Pending</div>
            <div class="item"><div class="color color-blue"></div> Blue Block</div>
            <div class="item"><div class="color color-red"></div> Red Block</div>
            <div class="item"><div class="color color-vspc"></div> Selected Chain</div>
            <div class="item"><div class="color color-lcca"></div> LCCA</div>
        </div>

        <!-- Tutorial Button -->
        <button id="tutorial-btn">
            <span class="icon">?</span>
            <span>What's this?</span>
        </button>

        <!-- Tutorial Overlay -->
        <div id="tutorial-overlay"></div>

        <!-- Tutorial Modal -->
        <div id="tutorial-modal">
            <div class="step-indicator">
                <div class="step-dot" data-step="1"></div>
                <div class="step-dot" data-step="2"></div>
                <div class="step-dot" data-step="3"></div>
                <div class="step-dot" data-step="4"></div>
                <div class="step-dot" data-step="5"></div>
                <div class="step-dot" data-step="6"></div>
                <div class="step-dot" data-step="7"></div>
                <div class="step-dot" data-step="8"></div>
                <div class="step-dot" data-step="9"></div>
                <div class="step-dot" data-step="10"></div>
            </div>
            <div class="content" id="tutorial-content">
                <!-- Content injected by JS -->
            </div>
            <div class="buttons">
                <button class="btn btn-secondary" id="tutorial-back">← Back</button>
                <button class="btn btn-primary" id="tutorial-next">Next →</button>
            </div>
        </div>

        <div id="dummy-controls">
            <span class="label">BPS Simulator</span>
            <button id="btn-dummy-toggle">OFF</button>
            <button id="btn-dummy-30bps" class="multiplier selected">30BPS</button>
            <button id="btn-dummy-100bps" class="multiplier">100BPS</button>
        </div>

        <div id="view-mode-controls">
            <span class="label">View</span>
            <button id="btn-view-linear" class="selected">Linear</button>
            <button id="btn-view-dag">DAG</button>
        </div>

        <div id="controls">
            <button id="btn-disconnect">Disconnect</button>
            <button id="btn-pause">Pause</button>
            <button id="btn-reset">Reset</button>
            <button id="btn-zoom-in">+</button>
            <button id="btn-zoom-out">-</button>
        </div>

        <div id="loading">
            <div class="spinner"></div>
            <div class="text">Initializing...</div>
        </div>
    </div>

    <!-- PixiJS v8 -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.x/dist/pixi.min.js"></script>

    <!-- Kaspa WASM SDK -->
    <script type="module">
        // ============================================================
        // DAGknight Protocol Visualizer
        // Phase 1: Foundation
        // ============================================================

        // ------------------------------------------------------------
        // Constants
        // ------------------------------------------------------------
        const CONFIG = {
            // Version (for debugging screenshots)
            VERSION: 'v150-responsive',

            // Display
            MAX_BLOCKS: 500,
            MAX_EDGES: 500,
            BLOCK_SIZE: 8,
            BLOCK_SIZE_VIRTUAL: 12,
            LINEAR_PITCH: 10,  // X spacing between linearized blocks
            SPAWN_X: 400,  // Screen-relative: blocks spawn at right side (relative to center 0)
            DAA_PITCH: 10,  // X spacing per DAA score in DAG mode (was 50)
            DAA_GROUP: 5,   // Group DAA scores within ±5 into same column
            DAA_COLUMN_WIDTH: 50,  // X width per column (group of DAA scores)
            Y_STEP: 20,     // Y spacing step in DAG mode
            VIEW_MODE: 'linear',  // 'linear' | 'dag'
            CLEANUP_THRESHOLD: -1600,  // Remove blocks with X below this (≈ 2x screen width left of SPAWN_X)

            // Colors
            COLORS: {
                BACKGROUND: 0x0A0E17,
                PENDING_BLOCK: 0x888888,  // Gray - not yet confirmed
                BLUE_BLOCK: 0x4A90D9,
                BLUE_EDGE: 0x7AB8E8,      // Lighter blue for finalized chain edges
                RED_BLOCK: 0xE74C3C,
                SELECTED_CHAIN: 0x00FF88,
                LCCA: 0xFFD700,  // Gold/Yellow for LCCA
                WHITE: 0xFFFFFF,  // White for outlines
                EDGE: 0x334455,
                EDGE_SELECTED: 0xFFFFFF,
            },

            // Performance
            UPDATE_INTERVAL: 500,  // ms (DAGknight calculation interval)
            TARGET_FPS: 60,

            // Network
            RPC_ENDPOINTS: [
                'wss://kaspa.aspectron.org/mainnet/wrpc/borsh',
                'wss://kaspa.matryx.io/mainnet/wrpc/borsh',
            ],

            // High BPS Simulation (Dummy Blocks)
            DUMMY: {
                ENABLED: false,        // Toggle dummy block generation
                MULTIPLIER: 2,         // +2=30BPS, +9=100BPS (base 10BPS)
                MAX_PARENT_SELECT: 2,  // Dummy removed from tips after this many selections
                MAX_DUMMY_PARENTS: 2,  // Max dummy tips to add as parents per block
            },

            // Edge display limit (DAG mode performance)
            MAX_EDGES_PER_BLOCK: 3,    // Max edges to draw per block (0 = unlimited)
        };

        // ------------------------------------------------------------
        // State
        // ------------------------------------------------------------
        const State = {
            app: null,
            graphics: null,  // Will be initialized in initPixi()
            rpcClient: null,
            isConnected: false,
            isPaused: false,
            pauseStartTime: null,      // When pause started (for 5-sec timeout)
            pauseBuffer: [],           // Blocks received during pause
            pauseExpired: false,       // True if paused > 5 seconds
            selectedBlockIndex: null,  // Selected block for info display (pause mode)
            tutorialStep: -1,  // Current tutorial step (-1 = not in tutorial)

            // Block data (TypedArrays for performance)
            blockData: {
                hashes: new Array(CONFIG.MAX_BLOCKS),
                parentHashes: new Array(CONFIG.MAX_BLOCKS),  // Store parent hashes for dynamic resolution
                x: new Float32Array(CONFIG.MAX_BLOCKS),
                y: new Float32Array(CONFIG.MAX_BLOCKS),
                targetX: new Float32Array(CONFIG.MAX_BLOCKS),  // For smooth X animation (linearization)
                targetY: new Float32Array(CONFIG.MAX_BLOCKS),  // For smooth Y animation
                linearIndex: new Int32Array(CONFIG.MAX_BLOCKS),  // -1 = not linearized yet
                color: new Uint32Array(CONFIG.MAX_BLOCKS),
                size: new Float32Array(CONFIG.MAX_BLOCKS),
                isBlue: new Uint8Array(CONFIG.MAX_BLOCKS),
                confirmationState: new Uint8Array(CONFIG.MAX_BLOCKS),  // 0=Pending, 1=Blue, 2=Red
                daaScore: new Float64Array(CONFIG.MAX_BLOCKS),
                blueScore: new Float64Array(CONFIG.MAX_BLOCKS),
                blueWork: new Array(CONFIG.MAX_BLOCKS),  // BigInt as string
                bits: new Uint32Array(CONFIG.MAX_BLOCKS),  // PoW difficulty bits
            },
            blockCount: 0,
            blockHashToIndex: new Map(),

            // High BPS Simulation (Dummy Blocks)
            dummyTips: new Map(),      // Map<dummyHash, selectCount> - tracks how many times selected as parent
            dummyBlockCount: 0,        // Total dummy blocks generated
            lastDummyLog: 0,           // Throttle debug logging

            // Ring buffer pointers
            ringHead: 0,
            ringTail: 0,

            // DAA score reference for relative X coordinates
            minDaaScore: null,
            maxDaaScore: null,
            dagColumnCount: new Map(),  // column -> block count (for Y positioning in DAG mode)

            // Viewport
            viewport: {
                x: 0,  // Center at origin
                y: 0,
                targetX: 0,  // Fixed camera (no scrolling needed)
                zoom: 1,
                width: 0,
                height: 0,
            },

            // Stats
            stats: {
                fps: 0,
                frameCount: 0,
                lastFpsUpdate: 0,
                drawCalls: 0,
                visibleBlocks: 0,
                edgeCount: 0,
            },

            // Selected Chain (Selected Parent Chain)
            selectedChainEdges: [],    // [[fromHash, toHash], ...] - all edges, classified at render time
            selectedChainBlocks: new Set(),  // Blocks on selected chain (for large block rendering)
            orderedBlocks: new Set(),  // All topologically ordered blocks (chain + ancestors)
            linearOrder: [],  // Final linearized order [hash, hash, ...]
            lccaHash: null,  // Latest Common Chain Ancestor (convergence point)
            sortedIndices: [],  // Cached: block indices sorted by X (updated in DAGknight calc, not every frame)
            lastDagknightCalc: 0,

            // Selected Parent Cache (dkoder optimization)
            // Map<blockHash, selectedParentHash>
            selectedParentCache: new Map(),

            // DAGknight Engine (dkoder-compliant)
            dagknight: {
                // BlockColouring enum: 0=Pending, 1=Blue, 2=Red
                PENDING: 0,
                BLUE: 1,
                RED: 2,

                // ConflictZoneManager data
                conflictZone: {
                    root: null,        // conflict genesis (LCCA)
                    tips: [],          // current tip hashes
                    blocks: new Set(), // blocks in zone
                },

                // CascadeTree data (per-block)
                cascadeTree: {
                    pastBlues: new Map(),      // hash → count
                    pastReds: new Map(),       // hash → count
                    anticoneBlues: new Map(),  // hash → count
                    arlb: new Map(),           // anticone_reds_lower_bound
                    floor: new Map(),          // hash → floor value
                },

                // Per-block coloring data
                bluesAnticoneSizes: new Map(), // hash → Map<blueHash, size>
                mergesetBlues: new Map(),      // hash → Set<hash>
                mergesetReds: new Map(),       // hash → Set<hash>
                coloringK: new Map(),          // hash → k value used

                // Caches (dkoder optimization)
                ancestorCache: new Map(),      // "hashA:hashB" → boolean
                kColouringCache: new Map(),    // "parents_hash:k" → result

                // Interval-based reachability (dkoder: reachability_service)
                intervalMap: new Map(),        // hash → {start, end}
                intervalCounter: 0,            // Counter for interval assignment

                // Debug (minimal - K cluster and zone size only)
                lastK: null,
                lastZoneBlockCount: 0,

                // Parameters
                d: 10,  // deficit parameter for confirmation
            },
        };

        // ------------------------------------------------------------
        // DOM Elements
        // ------------------------------------------------------------
        const DOM = {
            container: document.getElementById('canvas-container'),
            loading: document.getElementById('loading'),
            loadingText: document.querySelector('#loading .text'),
            status: document.getElementById('status'),
            connectionStatus: document.getElementById('connection-status'),
            networkName: document.getElementById('network-name'),
            daaScore: document.getElementById('daa-score'),
            blockCount: document.getElementById('block-count'),
            fpsDisplay: document.getElementById('fps-display'),
            drawCalls: document.getElementById('draw-calls'),
            memoryUsage: document.getElementById('memory-usage'),
            btnDisconnect: document.getElementById('btn-disconnect'),
            btnPause: document.getElementById('btn-pause'),
            btnReset: document.getElementById('btn-reset'),
            btnZoomIn: document.getElementById('btn-zoom-in'),
            btnZoomOut: document.getElementById('btn-zoom-out'),
            debugInfo: document.getElementById('debug-info'),
            // Dummy controls
            btnDummyToggle: document.getElementById('btn-dummy-toggle'),
            btnDummy30bps: document.getElementById('btn-dummy-30bps'),
            btnDummy100bps: document.getElementById('btn-dummy-100bps'),
            // View mode controls
            btnViewLinear: document.getElementById('btn-view-linear'),
            btnViewDag: document.getElementById('btn-view-dag'),
            // Block info panel
            blockInfo: document.getElementById('block-info'),
            infoHash: document.getElementById('info-hash'),
            infoDaa: document.getElementById('info-daa'),
            infoBlueScore: document.getElementById('info-blue-score'),
            infoBlueWork: document.getElementById('info-blue-work'),
            infoHint: document.getElementById('info-hint'),
            // Tutorial
            tutorialBtn: document.getElementById('tutorial-btn'),
            tutorialOverlay: document.getElementById('tutorial-overlay'),
            tutorialModal: document.getElementById('tutorial-modal'),
            tutorialContent: document.getElementById('tutorial-content'),
            tutorialBack: document.getElementById('tutorial-back'),
            tutorialNext: document.getElementById('tutorial-next'),
        };

        // ------------------------------------------------------------
        // PixiJS Initialization
        // ------------------------------------------------------------
        async function initPixi() {
            updateLoadingText('Initializing renderer...');

            State.app = new PIXI.Application();

            await State.app.init({
                background: CONFIG.COLORS.BACKGROUND,
                resizeTo: DOM.container,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
                powerPreference: 'high-performance',
            });

            DOM.container.appendChild(State.app.canvas);

            // Create Graphics objects ONCE (reused every frame)
            State.graphics = {
                edges: new PIXI.Graphics(),
                chainEdges: new PIXI.Graphics(),  // Selected Chain edges (behind blocks)
                pendingBlocks: new PIXI.Graphics(),  // Pending blocks (gray, behind blue/red)
                blueBlocks: new PIXI.Graphics(),
                redBlocks: new PIXI.Graphics(),
                chainBlocks: new PIXI.Graphics(),  // Chain blocks (large, with white outline, on top)
                lcca: new PIXI.Graphics(),  // LCCA block (on top)
            };

            // Add to stage (layered: back to front)
            State.app.stage.addChild(State.graphics.edges);          // 1. Gray edges (back)
            State.app.stage.addChild(State.graphics.chainEdges);     // 2. Selected Chain edges
            State.app.stage.addChild(State.graphics.pendingBlocks);  // 3. Pending blocks (gray)
            State.app.stage.addChild(State.graphics.blueBlocks);     // 4. Blue blocks (non-chain)
            State.app.stage.addChild(State.graphics.redBlocks);      // 5. Red blocks
            State.app.stage.addChild(State.graphics.chainBlocks);    // 6. Chain blocks (large, front)
            State.app.stage.addChild(State.graphics.lcca);           // 7. LCCA (front)

            // Store viewport dimensions (use actual CSS pixels, not internal resolution)
            State.viewport.width = State.app.canvas.clientWidth;
            State.viewport.height = State.app.canvas.clientHeight;

            // Handle resize
            window.addEventListener('resize', onResize);

            // Start render loop
            State.app.ticker.add(onTick);
        }

        function onResize() {
            // Delay execution to ensure canvas size is actually updated
            requestAnimationFrame(() => {
                const newWidth = State.app.canvas.clientWidth;
                const newHeight = State.app.canvas.clientHeight;

                // Skip if no change
                if (State.viewport.width === newWidth && State.viewport.height === newHeight) return;

                // Update stored dimensions first
                State.viewport.width = newWidth;
                State.viewport.height = newHeight;

                const zoom = State.viewport.zoom;
                const newHalfWidth = newWidth / 2;

                // DAG mode: recalculate X from scratch (tip at right edge)
                if (CONFIG.VIEW_MODE === 'dag' && State.maxDaaScore !== null && State.minDaaScore !== null) {
                    const maxColumn = Math.floor((State.maxDaaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                    const maxX = maxColumn * CONFIG.DAA_COLUMN_WIDTH;
                    const margin = 150 / zoom;
                    State.viewport.x = maxX - newHalfWidth / zoom + margin;
                    State.viewport.targetX = State.viewport.x;
                }
                // Linear mode: keep viewport at 0
            });
        }

        // ------------------------------------------------------------
        // Render Loop
        // ------------------------------------------------------------
        function onTick(ticker) {
            if (State.isPaused) {
                renderDAG();  // Keep rendering during pause (for mode switching)
                return;
            }

            // Update FPS counter
            State.stats.frameCount++;
            const now = performance.now();
            if (now - State.stats.lastFpsUpdate >= 1000) {
                State.stats.fps = State.stats.frameCount;
                State.stats.frameCount = 0;
                State.stats.lastFpsUpdate = now;
                updateStatsDisplay();
            }

            // Run DAGknight calculation periodically
            if (now - State.lastDagknightCalc >= CONFIG.UPDATE_INTERVAL) {
                runDAGknightCalculation();
                State.lastDagknightCalc = now;
            }

            // Render blocks and edges
            renderDAG();
        }

        // ------------------------------------------------------------
        // DAG Rendering (Optimized: reuse Graphics objects)
        // ------------------------------------------------------------
        function renderDAG() {
            const { edges, chainEdges, pendingBlocks, blueBlocks, redBlocks, chainBlocks, lcca } = State.graphics;

            // Smooth viewport scrolling (lerp interpolation)
            State.viewport.x += (State.viewport.targetX - State.viewport.x) * 0.1;

            // Smooth X and Y animation for all blocks (lerp to targets)
            const { x, y, targetX, targetY, linearIndex } = State.blockData;
            for (let i = 0; i < State.blockCount; i++) {
                // Y animation (all blocks)
                y[i] += (targetY[i] - y[i]) * 0.15;

                // X animation: DAG mode = all blocks, Linear mode = only linearized
                if (CONFIG.VIEW_MODE === 'dag' || linearIndex[i] >= 0) {
                    x[i] += (targetX[i] - x[i]) * 0.1;
                }
            }

            // Clear previous frame (reuse same objects)
            edges.clear();
            chainEdges.clear();
            pendingBlocks.clear();
            blueBlocks.clear();
            redBlocks.clear();
            chainBlocks.clear();
            lcca.clear();

            if (State.blockCount === 0) return;

            const { size, isBlue, confirmationState, parentHashes, hashes } = State.blockData;
            const { zoom, width, height } = State.viewport;
            const vpX = State.viewport.x;
            const vpY = State.viewport.y;
            const halfWidth = width / 2;
            const halfHeight = height / 2;

            let visibleCount = 0;
            let edgeCount = 0;

            // Use cached sorted indices (updated in DAGknight calc, not every frame)
            const sortedIndices = State.sortedIndices;

            // First pass: draw edges (newest blocks first, up to MAX_EDGES)
            for (const i of sortedIndices) {
                if (edgeCount >= CONFIG.MAX_EDGES) break;

                const screenX = (x[i] - vpX) * zoom + halfWidth;
                const screenY = (y[i] - vpY) * zoom + halfHeight;

                // Skip if outside viewport
                if (screenX < -100 || screenX > width + 100 ||
                    screenY < -100 || screenY > height + 100) {
                    continue;
                }

                // Draw edges to parents (skip if block has converged to Y≈0)
                // Edges fade out naturally as blocks reach Y=0, not when linearized
                if (Math.abs(y[i]) > 5) {  // Only draw edges if Y is not yet at 0
                    const parents = parentHashes[i] || [];
                    let edgesThisBlock = 0;
                    const maxPerBlock = CONFIG.MAX_EDGES_PER_BLOCK || parents.length;
                    for (const parentHash of parents) {
                        if (edgeCount >= CONFIG.MAX_EDGES) break;
                        if (edgesThisBlock >= maxPerBlock) break;
                        const parentIdx = State.blockHashToIndex.get(parentHash);
                        if (parentIdx !== undefined) {
                            const parentScreenX = (x[parentIdx] - vpX) * zoom + halfWidth;
                            const parentScreenY = (y[parentIdx] - vpY) * zoom + halfHeight;

                            edges.moveTo(screenX, screenY);
                            edges.lineTo(parentScreenX, parentScreenY);
                            edgeCount++;
                            edgesThisBlock++;
                        }
                    }
                }
            }

            // Stroke all edges at once
            if (edgeCount > 0) {
                edges.stroke({ width: 2, color: CONFIG.COLORS.EDGE, alpha: 0.5 });
            }

            // Second pass: draw blocks (on top of edges)
            // Chain blocks are drawn larger (14px vs 8px)
            const chainBlockSize = 14 * zoom;
            const chainHalfSize = chainBlockSize / 2;

            for (let i = 0; i < State.blockCount; i++) {
                const hash = hashes[i];
                if (!hash) continue;

                const screenX = (x[i] - vpX) * zoom + halfWidth;
                const screenY = (y[i] - vpY) * zoom + halfHeight;

                // Skip if outside viewport
                if (screenX < -50 || screenX > width + 50 ||
                    screenY < -50 || screenY > height + 50) {
                    continue;
                }

                // Check if this block is on the Selected Chain
                const isChainBlock = State.selectedChainBlocks && State.selectedChainBlocks.has(hash);
                const state = confirmationState[i];

                // dkoder: Tips (pending) stay gray even if on selected chain
                // Only confirmed blocks (with children) get blue/large styling
                if (state === 0) {
                    // Pending (gray) - tips or unconfirmed blocks
                    // Regular size even if on chain (not yet confirmed)
                    const blockSize = size[i] * zoom;
                    const halfSize = blockSize / 2;
                    pendingBlocks.rect(screenX - halfSize, screenY - halfSize, blockSize, blockSize);
                } else if (isChainBlock && state === 1) {
                    // Confirmed chain block - larger blue with white outline (top layer)
                    chainBlocks.rect(screenX - chainHalfSize, screenY - chainHalfSize, chainBlockSize, chainBlockSize)
                        .fill({ color: CONFIG.COLORS.BLUE_BLOCK })
                        .stroke({ width: 1, color: CONFIG.COLORS.WHITE });
                } else if (state === 1) {
                    // Blue (confirmed but not on chain) - with white outline
                    const blockSize = size[i] * zoom;
                    const halfSize = blockSize / 2;
                    blueBlocks.rect(screenX - halfSize, screenY - halfSize, blockSize, blockSize)
                        .fill({ color: CONFIG.COLORS.BLUE_BLOCK })
                        .stroke({ width: 1, color: CONFIG.COLORS.WHITE });
                } else {
                    // Red (confirmed but not selected) - with white outline
                    const blockSize = size[i] * zoom;
                    const halfSize = blockSize / 2;
                    redBlocks.rect(screenX - halfSize, screenY - halfSize, blockSize, blockSize)
                        .fill({ color: CONFIG.COLORS.RED_BLOCK })
                        .stroke({ width: 1, color: CONFIG.COLORS.WHITE });
                }

                visibleCount++;
            }

            // Draw Selected Chain edges
            // Tutorial Step 6,7 (index 5,6): draw on top with arrows
            // Normal: draw behind blocks
            const isTutorialChainStep = State.tutorialStep === 5 || State.tutorialStep === 6;

            if (!isTutorialChainStep && State.selectedChainEdges && State.selectedChainEdges.length > 0) {
                // Normal mode: draw behind blocks
                const { targetX } = State.blockData;
                let lccaTargetX = -Infinity;
                if (State.lccaHash) {
                    const lccaIdx = State.blockHashToIndex.get(State.lccaHash);
                    if (lccaIdx !== undefined) {
                        lccaTargetX = targetX[lccaIdx];
                    }
                }

                let blueDrawn = false;
                let greenDrawn = false;

                for (const [fromHash, toHash] of State.selectedChainEdges) {
                    const idx1 = State.blockHashToIndex.get(fromHash);
                    const idx2 = State.blockHashToIndex.get(toHash);
                    if (idx1 !== undefined && idx2 !== undefined) {
                        const bothInActive = targetX[idx1] >= lccaTargetX && targetX[idx2] >= lccaTargetX;
                        if (!bothInActive) {
                            const screenX1 = (x[idx1] - vpX) * zoom + halfWidth;
                            const screenY1 = (y[idx1] - vpY) * zoom + halfHeight;
                            const screenX2 = (x[idx2] - vpX) * zoom + halfWidth;
                            const screenY2 = (y[idx2] - vpY) * zoom + halfHeight;
                            chainEdges.moveTo(screenX1, screenY1);
                            chainEdges.lineTo(screenX2, screenY2);
                            blueDrawn = true;
                        }
                    }
                }
                if (blueDrawn) {
                    chainEdges.stroke({ width: 3, color: CONFIG.COLORS.BLUE_EDGE, alpha: 0.9 });
                }

                for (const [fromHash, toHash] of State.selectedChainEdges) {
                    const idx1 = State.blockHashToIndex.get(fromHash);
                    const idx2 = State.blockHashToIndex.get(toHash);
                    if (idx1 !== undefined && idx2 !== undefined) {
                        const bothInActive = targetX[idx1] >= lccaTargetX && targetX[idx2] >= lccaTargetX;
                        if (bothInActive) {
                            const screenX1 = (x[idx1] - vpX) * zoom + halfWidth;
                            const screenY1 = (y[idx1] - vpY) * zoom + halfHeight;
                            const screenX2 = (x[idx2] - vpX) * zoom + halfWidth;
                            const screenY2 = (y[idx2] - vpY) * zoom + halfHeight;
                            chainEdges.moveTo(screenX1, screenY1);
                            chainEdges.lineTo(screenX2, screenY2);
                            greenDrawn = true;
                        }
                    }
                }
                if (greenDrawn) {
                    chainEdges.stroke({ width: 2, color: CONFIG.COLORS.SELECTED_CHAIN, alpha: 0.8 });
                }
            }

            // Fill pending blocks (no outline)
            // Blue, red, chain, LCCA are filled individually with stroke
            pendingBlocks.fill({ color: CONFIG.COLORS.PENDING_BLOCK });

            // Draw LCCA block LAST (on top of everything)
            if (State.lccaHash) {
                const lccaIdx = State.blockHashToIndex.get(State.lccaHash);
                if (lccaIdx !== undefined) {
                    const lccaScreenX = (x[lccaIdx] - vpX) * zoom + halfWidth;
                    const lccaScreenY = (y[lccaIdx] - vpY) * zoom + halfHeight;

                    // Only draw if visible
                    if (lccaScreenX >= -50 && lccaScreenX <= width + 50 &&
                        lccaScreenY >= -50 && lccaScreenY <= height + 50) {
                        const lccaSize = 18 * zoom;  // Larger than chain blocks (14px)
                        const lccaHalfSize = lccaSize / 2;
                        lcca.rect(lccaScreenX - lccaHalfSize, lccaScreenY - lccaHalfSize, lccaSize, lccaSize)
                            .fill({ color: CONFIG.COLORS.LCCA })  // Yellow/Gold
                            .stroke({ width: 1, color: CONFIG.COLORS.WHITE });
                    }
                }
            }

            // Draw selection highlight (pause mode only) - white block
            if (State.isPaused && State.selectedBlockIndex !== null) {
                const selIdx = State.selectedBlockIndex;
                if (hashes[selIdx]) {
                    const selScreenX = (x[selIdx] - vpX) * zoom + halfWidth;
                    const selScreenY = (y[selIdx] - vpY) * zoom + halfHeight;
                    const selSize = size[selIdx] * zoom;
                    const selHalfSize = selSize / 2;
                    // White filled block (overwrites original color)
                    lcca.rect(selScreenX - selHalfSize, selScreenY - selHalfSize, selSize, selSize)
                        .fill({ color: 0xFFFFFF });
                }
            }

            // Tutorial Step 6,7 (index 5,6): Draw Selected Chain on TOP with arrows (child → parent)
            // Blue for finalized (before LCCA), Green for active (LCCA to tips)
            if (isTutorialChainStep && State.selectedChainEdges && State.selectedChainEdges.length > 0) {
                const { targetX } = State.blockData;
                const arrowSize = 10 * zoom;

                // Get LCCA's targetX
                let lccaTargetX = -Infinity;
                if (State.lccaHash) {
                    const lccaIdx = State.blockHashToIndex.get(State.lccaHash);
                    if (lccaIdx !== undefined) {
                        lccaTargetX = targetX[lccaIdx];
                    }
                }

                // First pass: Blue edges (finalized - before LCCA)
                let blueDrawn = false;
                for (const [fromHash, toHash] of State.selectedChainEdges) {
                    const idx1 = State.blockHashToIndex.get(fromHash);
                    const idx2 = State.blockHashToIndex.get(toHash);
                    if (idx1 !== undefined && idx2 !== undefined) {
                        const bothInActive = targetX[idx1] >= lccaTargetX && targetX[idx2] >= lccaTargetX;
                        if (!bothInActive) {
                            const screenX1 = (x[idx1] - vpX) * zoom + halfWidth;
                            const screenY1 = (y[idx1] - vpY) * zoom + halfHeight;
                            const screenX2 = (x[idx2] - vpX) * zoom + halfWidth;
                            const screenY2 = (y[idx2] - vpY) * zoom + halfHeight;
                            if (screenX1 < -50 || screenX1 > width + 50 || screenX2 < -50 || screenX2 > width + 50) continue;

                            lcca.moveTo(screenX1, screenY1);
                            lcca.lineTo(screenX2, screenY2);
                            const angle = Math.atan2(screenY2 - screenY1, screenX2 - screenX1);
                            lcca.moveTo(screenX2, screenY2);
                            lcca.lineTo(screenX2 - arrowSize * Math.cos(angle - Math.PI / 6), screenY2 - arrowSize * Math.sin(angle - Math.PI / 6));
                            lcca.moveTo(screenX2, screenY2);
                            lcca.lineTo(screenX2 - arrowSize * Math.cos(angle + Math.PI / 6), screenY2 - arrowSize * Math.sin(angle + Math.PI / 6));
                            blueDrawn = true;
                        }
                    }
                }
                if (blueDrawn) {
                    lcca.stroke({ width: 3, color: CONFIG.COLORS.BLUE_EDGE, alpha: 1.0 });
                }

                // Second pass: Green edges (active - LCCA to tips)
                let greenDrawn = false;
                for (const [fromHash, toHash] of State.selectedChainEdges) {
                    const idx1 = State.blockHashToIndex.get(fromHash);
                    const idx2 = State.blockHashToIndex.get(toHash);
                    if (idx1 !== undefined && idx2 !== undefined) {
                        const bothInActive = targetX[idx1] >= lccaTargetX && targetX[idx2] >= lccaTargetX;
                        if (bothInActive) {
                            const screenX1 = (x[idx1] - vpX) * zoom + halfWidth;
                            const screenY1 = (y[idx1] - vpY) * zoom + halfHeight;
                            const screenX2 = (x[idx2] - vpX) * zoom + halfWidth;
                            const screenY2 = (y[idx2] - vpY) * zoom + halfHeight;
                            if (screenX1 < -50 || screenX1 > width + 50 || screenX2 < -50 || screenX2 > width + 50) continue;

                            lcca.moveTo(screenX1, screenY1);
                            lcca.lineTo(screenX2, screenY2);
                            const angle = Math.atan2(screenY2 - screenY1, screenX2 - screenX1);
                            lcca.moveTo(screenX2, screenY2);
                            lcca.lineTo(screenX2 - arrowSize * Math.cos(angle - Math.PI / 6), screenY2 - arrowSize * Math.sin(angle - Math.PI / 6));
                            lcca.moveTo(screenX2, screenY2);
                            lcca.lineTo(screenX2 - arrowSize * Math.cos(angle + Math.PI / 6), screenY2 - arrowSize * Math.sin(angle + Math.PI / 6));
                            greenDrawn = true;
                        }
                    }
                }
                if (greenDrawn) {
                    lcca.stroke({ width: 3, color: CONFIG.COLORS.SELECTED_CHAIN, alpha: 1.0 });
                }
            }

            // Update stats
            State.stats.drawCalls = 4; // edges + blue blocks + red blocks + chain
            State.stats.visibleBlocks = visibleCount;
            State.stats.edgeCount = edgeCount;
        }

        // ------------------------------------------------------------
        // High BPS Simulation (Dummy Block Generation)
        // ------------------------------------------------------------

        /**
         * Generate a unique dummy hash from original block hash
         * Format: 0dummy_{original}_{index}
         * - '0dummy' prefix ensures it's lexicographically smaller than real hashes
         * - This makes real blocks preferred in selected parent selection
         */
        function generateDummyHash(originalHash, index) {
            return `0dummy_${originalHash.substring(0, 16)}_${index}`;
        }

        /**
         * Check if a hash is a dummy block
         */
        function isDummyHash(hash) {
            return hash && hash.startsWith('0dummy_');
        }

        /**
         * Generate dummy blocks for high BPS simulation
         * Called after a real block is added
         */
        function generateDummyBlocks(originalBlock) {
            if (!CONFIG.DUMMY.ENABLED) return;
            // Note: Ring buffer handles overflow, no need for safety margin

            const originalHash = originalBlock.header.hash;
            const originalDaaScore = Number(originalBlock.header.daaScore);
            const originalBlueWork = originalBlock.header.blueWork || '0';
            const originalBits = Number(originalBlock.header.bits || 0);
            const parentsByLevel = originalBlock.header.parentsByLevel || [];
            const originalParents = parentsByLevel[0] || [];

            // Generate MULTIPLIER dummy blocks
            for (let i = 0; i < CONFIG.DUMMY.MULTIPLIER; i++) {
                const dummyHash = generateDummyHash(originalHash, i);

                // Skip if already exists
                if (State.blockHashToIndex.has(dummyHash)) continue;

                // Get next index
                const index = State.ringHead;
                const oldHash = State.blockData.hashes[index];
                if (oldHash) {
                    State.blockHashToIndex.delete(oldHash);
                    State.dummyTips.delete(oldHash);  // Remove from tips if it was there
                }

                // Store dummy block
                State.blockData.hashes[index] = dummyHash;
                State.blockHashToIndex.set(dummyHash, index);
                State.blockData.daaScore[index] = originalDaaScore;

                // Position based on view mode (same logic as addBlock)
                const yScale = CONFIG.DUMMY.MULTIPLIER <= 2 ? 1.5 : 2.0;
                if (CONFIG.VIEW_MODE === 'dag') {
                    // DAG mode: X based on column (DAA grouped), Y based on order in column
                    const column = Math.floor((originalDaaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                    const columnX = column * CONFIG.DAA_COLUMN_WIDTH;

                    // Get block index within column for Y positioning
                    const columnKey = column;
                    const blockIndexInColumn = State.dagColumnCount.get(columnKey) || 0;
                    State.dagColumnCount.set(columnKey, blockIndexInColumn + 1);

                    // Calculate Y: 0, +20, -20, +40, -40, ... (scaled for high BPS)
                    let blockY;
                    if (blockIndexInColumn === 0) {
                        blockY = 0;
                    } else {
                        const offset = Math.ceil(blockIndexInColumn / 2) * CONFIG.Y_STEP * yScale;
                        const direction = (blockIndexInColumn % 2 === 1) ? 1 : -1;
                        blockY = offset * direction;
                    }

                    State.blockData.x[index] = columnX;
                    State.blockData.targetX[index] = columnX;
                    State.blockData.y[index] = blockY;
                    State.blockData.targetY[index] = blockY;
                } else {
                    // Linear mode: X at spawn area with slight offset
                    const tipOffset = 10 + Math.random() * 30;
                    State.blockData.x[index] = CONFIG.SPAWN_X + tipOffset;
                    State.blockData.targetX[index] = State.blockData.x[index];

                    // Y = spread vertically (scaled for high BPS)
                    const randomY = (Math.random() - 0.5) * 300 * yScale;
                    State.blockData.y[index] = randomY;
                    State.blockData.targetY[index] = randomY;
                }
                State.blockData.linearIndex[index] = -1;

                // BlueWork: subtract (i+1) to make each dummy unique and lower priority
                State.blockData.blueScore[index] = Number(originalBlock.header.blueScore || 0);
                // Parse hex blueWork, subtract to ensure unique values
                let dummyBlueWork = originalBlueWork;
                try {
                    const bwBigInt = BigInt('0x' + originalBlueWork);
                    const adjusted = bwBigInt - BigInt(i + 1);
                    dummyBlueWork = adjusted > 0n ? adjusted.toString(16) : '0';
                } catch (e) {
                    // Keep original if parsing fails
                }
                State.blockData.blueWork[index] = dummyBlueWork;
                State.blockData.bits[index] = originalBits;

                // Pending state (will be colored by DAGknight if it gets children)
                State.blockData.confirmationState[index] = 0;
                State.blockData.size[index] = CONFIG.BLOCK_SIZE;

                // Parents: same as original
                State.blockData.parentHashes[index] = [...originalParents];

                // Calculate Selected Parent (highest BlueWork) and add green edge
                // Note: Dummies are not part of Selected Chain, so no edges added

                // Update ring buffer
                State.ringHead = (State.ringHead + 1) % CONFIG.MAX_BLOCKS;
                if (State.blockCount < CONFIG.MAX_BLOCKS) {
                    State.blockCount++;
                }

                // Add to dummyTips (selectCount = 0)
                State.dummyTips.set(dummyHash, 0);
                State.dummyBlockCount++;
            }
        }

        // ------------------------------------------------------------
        // DAGknight Algorithm
        // ------------------------------------------------------------

        // ============================================================
        // DAGknight Engine (dkoder-compliant implementation)
        // ============================================================

        // --- Step 1: Base Functions ---

        // findSelectedParent: Find parent with highest blueWork (dkoder: find_selected_parent)
        // Skip dummy blocks - only select from real blocks
        function findSelectedParent(parentHashes) {
            if (!parentHashes || parentHashes.length === 0) return null;

            // Filter out dummies - selected chain should only contain real blocks
            const realParents = parentHashes.filter(h => !isDummyHash(h));
            if (realParents.length === 0) return null;
            if (realParents.length === 1) return realParents[0];

            let selectedParent = null;
            let maxBlueWork = '';

            for (const parentHash of realParents) {
                const idx = State.blockHashToIndex.get(parentHash);
                if (idx === undefined) continue;

                const blueWork = State.blockData.blueWork[idx] || '0';
                // String comparison works for hex (same length, lexicographic = numeric)
                if (blueWork > maxBlueWork || (blueWork === maxBlueWork && parentHash > (selectedParent || ''))) {
                    maxBlueWork = blueWork;
                    selectedParent = parentHash;
                }
            }

            return selectedParent;
        }

        // sortBlocks: Sort blocks by blueWork descending (dkoder: sort_blocks)
        function sortBlocks(blockHashes) {
            return [...blockHashes].sort((a, b) => {
                const idxA = State.blockHashToIndex.get(a);
                const idxB = State.blockHashToIndex.get(b);
                if (idxA === undefined) return 1;
                if (idxB === undefined) return -1;

                const workA = State.blockData.blueWork[idxA] || '0';
                const workB = State.blockData.blueWork[idxB] || '0';

                // Descending order (higher blueWork first)
                if (workB > workA) return 1;
                if (workA > workB) return -1;
                // Tie-breaker: hash
                return b > a ? 1 : -1;
            });
        }

        // blueAnticoneSize: Calculate blue anticone size from a worldview (dkoder: blue_anticone_size)
        function blueAnticoneSize(blockHash, worldviewHash, bluesAnticoneSizes) {
            if (!bluesAnticoneSizes) return 0;
            const sizes = bluesAnticoneSizes.get(worldviewHash);
            if (!sizes) return 0;
            return sizes.get(blockHash) || 0;
        }

        // --- Step 2: ConflictZoneManager Functions ---

        // commonChainAncestor: Find LCCA of multiple blocks (dkoder: common_chain_ancestor)
        function commonChainAncestor(hashes) {
            if (!hashes || hashes.length === 0) return null;
            if (hashes.length === 1) return hashes[0];

            // Build Selected Parent Chain for each hash
            const chains = hashes.map(hash => {
                const chain = [hash];
                let current = hash;
                const visited = new Set([hash]);

                for (let i = 0; i < 200; i++) {
                    const idx = State.blockHashToIndex.get(current);
                    if (idx === undefined) break;

                    const parents = State.blockData.parentHashes[idx] || [];
                    if (parents.length === 0) break;

                    const sp = findSelectedParent(parents);
                    if (!sp || visited.has(sp)) break;

                    visited.add(sp);
                    chain.push(sp);
                    current = sp;
                }
                return chain;
            });

            // Find first common element in all chains
            for (const hash of chains[0]) {
                let isCommon = true;
                for (let i = 1; i < chains.length; i++) {
                    if (!chains[i].includes(hash)) {
                        isCommon = false;
                        break;
                    }
                }
                if (isCommon) return hash;
            }

            return null;
        }

        // calcWork: Calculate PoW work from difficulty bits (dkoder: calc_work)
        // work = (~target / (target + 1)) + 1 ≈ 2^256 / (target + 1)
        // Same scale as Kaspa's blueWork (2^256 based)
        const TWO_256 = 1n << 256n;  // 2^256

        function calcWork(bits) {
            if (!bits || bits === 0) return 1n;  // Fallback to 1 if no bits

            // Decode compact target bits (Bitcoin-style)
            // bits = 0x1e7fffff → exponent=0x1e, mantissa=0x7fffff
            const exponent = bits >> 24;
            const mantissa = bits & 0x007fffff;

            if (exponent === 0 || mantissa === 0) return 1n;

            // target = mantissa × 2^(8 × (exponent - 3))
            const shift = 8 * (exponent - 3);

            // Calculate target as BigInt
            let target;
            if (shift >= 0) {
                target = BigInt(mantissa) << BigInt(shift);
            } else {
                target = BigInt(mantissa) >> BigInt(-shift);
            }

            if (target === 0n) return 1n;

            // work = 2^256 / (target + 1) - same as dkoder
            // dkoder: (!target / (target + 1)) + 1
            // This is mathematically equivalent to 2^256 / (target + 1)
            const work = TWO_256 / (target + 1n);
            return work > 0n ? work : 1n;
        }

        // calcConflictZoneWork: Calculate total work in conflict zone (dkoder: calc_conflict_zone_work)
        // Returns both zoneWork AND zoneBlocks for consistent kColouring
        function calcConflictZoneWork(genesisHash, subgroupHashes) {
            let totalWork = 0n;
            const visited = new Set();
            const validBlocks = [];  // Blocks with valid idx

            // BFS from subgroup tips back to genesis
            const queue = [...subgroupHashes];

            while (queue.length > 0) {
                const hash = queue.shift();
                if (visited.has(hash)) continue;
                if (hash === genesisHash) continue;  // Don't include genesis itself
                visited.add(hash);

                // Skip dummy blocks from DAGknight calculation (visualization only)
                if (isDummyHash(hash)) continue;

                const idx = State.blockHashToIndex.get(hash);
                if (idx === undefined) continue;

                // Add this block's individual work (from bits, not cumulative blueWork)
                const bits = State.blockData.bits[idx];
                const work = calcWork(bits);
                totalWork += work;
                validBlocks.push(hash);

                // Add parents to queue (if not past genesis, skip dummies)
                const parents = State.blockData.parentHashes[idx] || [];
                for (const parentHash of parents) {
                    if (!visited.has(parentHash) && parentHash !== genesisHash && !isDummyHash(parentHash)) {
                        // Check if parent is ancestor of genesis (stop condition)
                        if (!isAncestor(parentHash, genesisHash, 50)) {
                            queue.push(parentHash);
                        }
                    }
                }
            }

            // Track zone size (for display)
            State.dagknight.lastZoneBlockCount = visited.size;

            // Return only valid blocks for kColouring
            return { zoneWork: totalWork, zoneBlocks: validBlocks };
        }

        // orderedMergesetWithoutSelectedParent: Get mergeset in topological order (dkoder: ordered_mergeset_without_selected_parent)
        function orderedMergesetWithoutSelectedParent(selectedParent, allParents) {
            // Mergeset = parents that are not the selected parent
            // and not ancestors of selected parent
            const mergeset = [];

            for (const parentHash of allParents) {
                if (parentHash === selectedParent) continue;

                // Check if this parent is in the anticone of selected parent
                // (not ancestor and not descendant)
                if (!isAncestor(parentHash, selectedParent, 50) &&
                    !isAncestor(selectedParent, parentHash, 50)) {
                    mergeset.push(parentHash);
                }
            }

            // Sort by blueWork (topological approximation)
            return sortBlocks(mergeset);
        }

        // --- Step 3: K-Colouring Functions ---

        // checkBlueCandidate: Check if candidate can be blue with given k (dkoder: check_blue_candidate)
        // Debug counters for rejection reasons
        let checkBlueStats = { check1: 0, check2: 0, check3: 0, passed: 0 };

        function checkBlueCandidate(newBlockData, candidateHash, k, mergesetBlues) {
            // Check 1: mergeset blues count <= k
            if (mergesetBlues.size > k) {
                checkBlueStats.check1++;
                return false;
            }

            // Check 2: candidate's blue anticone size <= k
            const candidateAnticoneBlues = countAnticoneBlues(candidateHash, mergesetBlues);
            if (candidateAnticoneBlues > k) {
                checkBlueStats.check2++;
                return false;
            }

            // Check 3: for each existing blue, adding candidate doesn't exceed k
            for (const blueHash of mergesetBlues) {
                const blueAnticoneWithCandidate = countAnticoneBluesWithCandidate(
                    blueHash, candidateHash, mergesetBlues
                );
                if (blueAnticoneWithCandidate > k) {
                    checkBlueStats.check3++;
                    return false;
                }
            }

            checkBlueStats.passed++;
            return true;
        }

        // Reset and expose stats
        function resetCheckBlueStats() {
            checkBlueStats = { check1: 0, check2: 0, check3: 0, passed: 0 };
        }
        function getCheckBlueStats() {
            return checkBlueStats;
        }

        // Helper: Count blue blocks in anticone of a block
        function countAnticoneBlues(blockHash, blueSet) {
            let count = 0;
            for (const blueHash of blueSet) {
                if (blueHash === blockHash) continue;
                // In anticone = not ancestor and not descendant
                if (!isAncestor(blueHash, blockHash, 30) &&
                    !isAncestor(blockHash, blueHash, 30)) {
                    count++;
                }
            }
            return count;
        }

        // Helper: Count anticone blues if we add candidate to blue set
        function countAnticoneBluesWithCandidate(blueHash, candidateHash, currentBlues) {
            let count = 0;

            // Count existing blues in anticone
            for (const otherBlue of currentBlues) {
                if (otherBlue === blueHash) continue;
                if (!isAncestor(otherBlue, blueHash, 30) &&
                    !isAncestor(blueHash, otherBlue, 30)) {
                    count++;
                }
            }

            // Check if candidate would be in anticone
            if (candidateHash !== blueHash &&
                !isAncestor(candidateHash, blueHash, 30) &&
                !isAncestor(blueHash, candidateHash, 30)) {
                count++;
            }

            return count;
        }

        // kColouring: Perform k-colouring on parents (dkoder: k_colouring)
        // With caching to avoid redundant calculations
        function kColouring(parentHashes, k, selectedParentOverride = null) {
            const selectedParent = selectedParentOverride || findSelectedParent(parentHashes);
            if (!selectedParent) {
                return { selectedParent: null, mergesetBlues: new Set(), mergesetReds: new Set() };
            }

            // Cache key: sorted parents + k
            const cacheKey = parentHashes.slice().sort().join(',') + ':' + k;
            const cached = State.dagknight.kColouringCache.get(cacheKey);
            if (cached) return cached;

            const mergeset = orderedMergesetWithoutSelectedParent(selectedParent, parentHashes);
            const mergesetBlues = new Set();
            const mergesetReds = new Set();

            // Reset debug stats for this colouring
            resetCheckBlueStats();

            // Process each candidate in topological order
            for (const candidateHash of mergeset) {
                // Simulation mode: force all blocks to blue
                if (CONFIG.DUMMY.ENABLED) {
                    mergesetBlues.add(candidateHash);
                    continue;
                }

                // Early termination (dkoder): if blues already at k, remaining are Red
                if (mergesetBlues.size >= k && k > 0) {
                    // Can't add more blues, mark rest as red
                    mergesetReds.add(candidateHash);
                    continue;
                }

                if (checkBlueCandidate(null, candidateHash, k, mergesetBlues)) {
                    mergesetBlues.add(candidateHash);
                } else {
                    mergesetReds.add(candidateHash);
                }
            }

            const result = {
                selectedParent,
                mergesetBlues,
                mergesetReds,
                blueScore: mergesetBlues.size + 1,  // +1 for selected parent
            };

            // Cache result (limit cache size)
            if (State.dagknight.kColouringCache.size < 1000) {
                State.dagknight.kColouringCache.set(cacheKey, result);
            }

            return result;
        }

        // --- Step 4: DagknightExecutor - dkoder-aligned incremental processing ---

        // getBlueWorkForSort: Get blue_work for sorting (from global GHOSTDAG data)
        // blueWork is stored as hex string from API, convert to BigInt for numeric comparison
        function getBlueWorkForSort(hash) {
            const idx = State.blockHashToIndex.get(hash);
            if (idx === undefined) return 0n;
            const hexStr = State.blockData.blueWork?.[idx];
            if (!hexStr || hexStr === '0') return 0n;
            // Convert hex string to BigInt (add 0x prefix)
            try {
                return BigInt('0x' + hexStr);
            } catch (e) {
                // Fallback: if not valid hex, try as decimal
                return BigInt(hexStr || 0);
            }
        }

        // getParentsInStore: Get parents that are already in blueWorkStore (dkoder approach)
        function getParentsInStore(blockHash, blueWorkStore) {
            const idx = State.blockHashToIndex.get(blockHash);
            if (idx === undefined) return [];

            const allParents = State.blockData.parentHashes[idx] || [];
            return allParents.filter(p => blueWorkStore.has(p));
        }

        // findSelectedParentFromStore: Find SP using stored blue_work (dkoder: find_selected_parent)
        // Skip dummy blocks - only select from real blocks
        function findSelectedParentFromStore(parents, blueWorkStore) {
            // Filter out dummies - selected chain should only contain real blocks
            const realParents = parents.filter(h => !isDummyHash(h));
            if (realParents.length === 0) return null;
            if (realParents.length === 1) return realParents[0];

            let bestParent = realParents[0];
            let bestWork = blueWorkStore.get(realParents[0]) || 0n;

            for (let i = 1; i < realParents.length; i++) {
                const work = blueWorkStore.get(realParents[i]) || 0n;
                if (work > bestWork) {
                    bestWork = work;
                    bestParent = realParents[i];
                }
            }

            return bestParent;
        }

        // getMergesetBounded: Get mergeset (anticone of SP among zone parents)
        function getMergesetBounded(selectedParent, parents, blockHash) {
            const mergeset = [];
            for (const parent of parents) {
                if (parent === selectedParent) continue;
                // In bounded context, we only check among the direct parents
                // Anticone = not ancestor and not descendant
                if (!isAncestor(parent, selectedParent, 30) &&
                    !isAncestor(selectedParent, parent, 30)) {
                    mergeset.push(parent);
                }
            }
            return sortBlocks(mergeset);
        }

        // checkBlueCandidateBounded: Check if candidate can be blue using bounded store
        function checkBlueCandidateBounded(blockHash, candidateHash, k, mergesetBlues, blueStatusStore) {
            // Check 1: current mergeset blues count <= k
            if (mergesetBlues.length > k) {
                return false;
            }

            // Check 2: candidate's blue anticone size <= k
            // Count blues in anticone of candidate
            let candidateAnticoneBlues = 0;
            for (const blueHash of mergesetBlues) {
                if (!isAncestor(blueHash, candidateHash, 30) &&
                    !isAncestor(candidateHash, blueHash, 30)) {
                    candidateAnticoneBlues++;
                }
            }
            if (candidateAnticoneBlues > k) {
                return false;
            }

            // Check 3: each existing blue's anticone with candidate <= k
            for (const blueHash of mergesetBlues) {
                let blueAnticoneWithCandidate = 0;
                // Count: candidate + other mergeset blues in anticone of this blue
                if (!isAncestor(blueHash, candidateHash, 30) &&
                    !isAncestor(candidateHash, blueHash, 30)) {
                    blueAnticoneWithCandidate++;
                }
                for (const otherBlue of mergesetBlues) {
                    if (otherBlue === blueHash) continue;
                    if (!isAncestor(blueHash, otherBlue, 30) &&
                        !isAncestor(otherBlue, blueHash, 30)) {
                        blueAnticoneWithCandidate++;
                    }
                }
                if (blueAnticoneWithCandidate > k) {
                    return false;
                }
            }

            return true;
        }

        // fillBoundedGhostdagData: dkoder-aligned incremental processing
        // Process zone blocks using heap-based topological order (by blue_work)
        function fillBoundedGhostdagData(root, zoneBlocks, tips, k) {
            const zoneSet = new Set(zoneBlocks);

            // Step 1: Initialize stores
            const blueWorkStore = new Map();   // hash -> BigInt blue_work
            const blueStatusStore = new Map(); // hash -> 'blue' | 'red'
            const mergesetBluesStore = new Map();  // hash -> array of mergeset blues
            const mergesetRedsStore = new Map();   // hash -> array of mergeset reds
            const selectedParentStore = new Map(); // hash -> selected parent

            // dkoder: Pre-insert root into store with 0 blue_work
            // This allows blocks with root as parent to be processed
            blueWorkStore.set(root, 0n);
            blueStatusStore.set(root, 'blue');

            // Step 2: Sort zone blocks by blue_work (ascending) - simulates heap
            const sortedByWork = [...zoneBlocks].sort((a, b) => {
                const workA = getBlueWorkForSort(a);
                const workB = getBlueWorkForSort(b);
                if (workA < workB) return -1;
                if (workA > workB) return 1;
                return 0;
            });

            // Debug counters
            let totalMergesetBlues = 0;
            let totalMergesetReds = 0;
            let blocksProcessed = 0;
            let skippedBlocks = 0;
            let iterations = 0;

            // Step 3: Process blocks - repeat until all are processed
            // dkoder uses heap; we iterate sorted list and skip if parents not ready
            const pending = new Set(sortedByWork);
            const maxIterations = zoneBlocks.length * 2;  // Safety limit

            while (pending.size > 0 && iterations < maxIterations) {
                iterations++;
                let processedThisRound = 0;

                for (const blockHash of sortedByWork) {
                    if (!pending.has(blockHash)) continue;

                    // dkoder: Get parents that are already in store
                    const parentsInStore = getParentsInStore(blockHash, blueWorkStore);

                    // Get ALL parents for this block
                    const idx = State.blockHashToIndex.get(blockHash);
                    if (idx === undefined) {
                        pending.delete(blockHash);
                        continue;
                    }
                    const allParents = State.blockData.parentHashes[idx] || [];

                    // Filter to zone-relevant parents (in zone or root)
                    const zoneParents = allParents.filter(p => zoneSet.has(p) || p === root);

                    // Skip if not all zone parents are in store yet
                    if (parentsInStore.length < zoneParents.length) {
                        skippedBlocks++;
                        continue;
                    }

                    // All zone parents are ready - process this block
                    pending.delete(blockHash);
                    blocksProcessed++;
                    processedThisRound++;

                    if (parentsInStore.length === 0) {
                        // No parents in store - orphaned in zone context
                        blueWorkStore.set(blockHash, 0n);
                        blueStatusStore.set(blockHash, 'blue');
                        continue;
                    }

                    // Find selected parent (highest blue_work among parents in store)
                    const selectedParent = findSelectedParentFromStore(parentsInStore, blueWorkStore);
                    selectedParentStore.set(blockHash, selectedParent);

                    // Get mergeset (anticone of SP among parents in store)
                    const mergeset = getMergesetBounded(selectedParent, parentsInStore, blockHash);

                    // k-colouring on mergeset
                    const mergesetBlues = [];
                    const mergesetReds = [];

                    for (const candidate of mergeset) {
                        // Simulation mode: force all blocks to blue
                        if (CONFIG.DUMMY.ENABLED) {
                            mergesetBlues.push(candidate);
                            blueStatusStore.set(candidate, 'blue');
                            continue;
                        }

                        if (mergesetBlues.length >= k && k > 0) {
                            mergesetReds.push(candidate);
                            continue;
                        }

                        if (checkBlueCandidateBounded(blockHash, candidate, k, mergesetBlues, blueStatusStore)) {
                            mergesetBlues.push(candidate);
                            blueStatusStore.set(candidate, 'blue');
                        } else {
                            mergesetReds.push(candidate);
                            blueStatusStore.set(candidate, 'red');
                        }
                    }

                    mergesetBluesStore.set(blockHash, mergesetBlues);
                    mergesetRedsStore.set(blockHash, mergesetReds);
                    totalMergesetBlues += mergesetBlues.length;
                    totalMergesetReds += mergesetReds.length;

                    // Calculate blue_work (dkoder formula):
                    // blue_work = SP.blue_work + sum(mergeset_blues work)
                    const spBlueWork = blueWorkStore.get(selectedParent) || 0n;
                    let addedBlueWork = 0n;
                    for (const blueHash of mergesetBlues) {
                        const bidx = State.blockHashToIndex.get(blueHash);
                        if (bidx !== undefined) {
                            addedBlueWork += calcWork(State.blockData.bits[bidx]);
                        }
                    }
                    const blockBlueWork = spBlueWork + addedBlueWork;
                    blueWorkStore.set(blockHash, blockBlueWork);

                    // The block itself is on the selected chain (implicitly blue)
                    blueStatusStore.set(blockHash, 'blue');
                }

                // If no progress, break to avoid infinite loop
                if (processedThisRound === 0) break;
            }

            // Step 4: Get final result from tips
            let finalBlueWork = 0n;
            let finalSelectedParent = null;
            let finalTip = tips[0];

            for (const tip of tips) {
                const tipBlueWork = blueWorkStore.get(tip) || 0n;
                if (tipBlueWork > finalBlueWork) {
                    finalBlueWork = tipBlueWork;
                    finalTip = tip;
                }
            }
            finalSelectedParent = selectedParentStore.get(finalTip);

            // Collect all blues and reds for coloring display
            const allMergesetBlues = new Set();
            const allMergesetReds = new Set();
            for (const [hash, blues] of mergesetBluesStore) {
                for (const b of blues) allMergesetBlues.add(b);
            }
            for (const [hash, reds] of mergesetRedsStore) {
                for (const r of reds) allMergesetReds.add(r);
            }

            // Count total blues (blocks on chain + mergeset blues)
            let chainBlueCount = 0;
            for (const [hash, status] of blueStatusStore) {
                if (status === 'blue' && !allMergesetBlues.has(hash)) {
                    chainBlueCount++;  // Blue but not from mergeset = on chain
                }
            }

            return {
                selectedParent: finalSelectedParent,
                mergesetBlues: allMergesetBlues,
                mergesetReds: allMergesetReds,
                blueWork: finalBlueWork,
                blueCount: chainBlueCount + allMergesetBlues.size,
                blueStatusStore,  // For coloring
                k,
            };
        }

        // rank: Determine ranking by searching k-space (dkoder: rank)
        // Optimized: limit k search to 64 (usually k=0-5 is enough)
        function rank(conflictGenesis, subgroup, zoneWork, fullSubgroup) {
            // Search for minimal k where blueWork >= zoneWork / 2
            const halfZoneWork = zoneWork / 2n;
            const MAX_K = 64;

            for (let k = 0; k <= MAX_K; k++) {
                const data = fillBoundedGhostdagData(conflictGenesis, subgroup, subgroup, k);

                if (data.blueWork >= halfZoneWork) {
                    State.dagknight.lastK = k;  // Track K for display
                    return { k, subgroupVirtual: data };
                }
            }

            // Fallback: use MAX_K
            const fallbackData = fillBoundedGhostdagData(conflictGenesis, subgroup, subgroup, MAX_K);
            State.dagknight.lastK = MAX_K;
            return { k: MAX_K, subgroupVirtual: fallbackData };
        }

        // dagknight: Main parent selection (dkoder: dagknight)
        // Returns { selectedParent, coloringResult, k } for batch coloring
        function dagknight(parentHashes) {
            // Helper: create fallback result with k=18
            const fallbackResult = (selectedParent) => {
                const coloringResult = kColouring(parentHashes, 18);
                return {
                    selectedParent: selectedParent || coloringResult.selectedParent,
                    coloringResult,
                    k: 18,
                };
            };

            if (!parentHashes || parentHashes.length === 0) {
                return { selectedParent: null, coloringResult: null, k: 0 };
            }
            if (parentHashes.length === 1) {
                return {
                    selectedParent: parentHashes[0],
                    coloringResult: { selectedParent: parentHashes[0], mergesetBlues: new Set(), mergesetReds: new Set() },
                    k: 0,
                };
            }

            // Step 1: Find conflict genesis (LCCA)
            const conflictGenesis = commonChainAncestor(parentHashes);
            if (!conflictGenesis) {
                return fallbackResult(null);
            }

            // Step 2: Calculate zone work AND get zone blocks
            const { zoneWork, zoneBlocks } = calcConflictZoneWork(conflictGenesis, parentHashes);
            if (zoneWork === 0n) {
                return fallbackResult(null);
            }

            // Step 2.5: Compute intervals for O(1) ancestor checks (dkoder: reachability_service)
            const zoneSet = new Set(zoneBlocks);
            zoneSet.add(conflictGenesis);  // Include root
            computeIntervals(conflictGenesis, zoneSet);

            // Step 3: Rank using zone blocks (same blocks used for zoneWork)
            const rankResult = rank(conflictGenesis, zoneBlocks, zoneWork, parentHashes);

            // Return full result for batch coloring
            const selectedParent = rankResult.subgroupVirtual.selectedParent || findSelectedParent(parentHashes);
            return {
                selectedParent,
                coloringResult: rankResult.subgroupVirtual,
                k: rankResult.k,
            };
        }

        // --- Step 5: CascadeTree Functions (Confirmation) ---

        // cascadeTreeInsert: Add block to cascade tree (dkoder: CascadeTree::insert)
        function cascadeTreeInsert(hash, pastBlues, pastReds, anticoneBlues, arlb) {
            const { cascadeTree } = State.dagknight;
            cascadeTree.pastBlues.set(hash, pastBlues);
            cascadeTree.pastReds.set(hash, pastReds);
            cascadeTree.anticoneBlues.set(hash, anticoneBlues);
            cascadeTree.arlb.set(hash, arlb);

            // Calculate floor
            // floor = pastReds + arlb - pastBlues - anticoneBlues
            const floor = pastReds + arlb - pastBlues - anticoneBlues;
            cascadeTree.floor.set(hash, floor);
        }

        // updateAnticoneBlues: Update anticone blue count (dkoder: CascadeTree::update_anticone_blues)
        function updateAnticoneBlues(hash, count) {
            const { cascadeTree } = State.dagknight;
            cascadeTree.anticoneBlues.set(hash, count);

            // Recalculate floor
            const pastBlues = cascadeTree.pastBlues.get(hash) || 0;
            const pastReds = cascadeTree.pastReds.get(hash) || 0;
            const arlb = cascadeTree.arlb.get(hash) || 0;
            const floor = pastReds + arlb - pastBlues - count;
            cascadeTree.floor.set(hash, floor);
        }

        // peekMin: Get block with minimum floor (dkoder: CascadeTree::peek_min)
        function peekMin() {
            const { cascadeTree } = State.dagknight;
            let minHash = null;
            let minFloor = Infinity;

            for (const [hash, floor] of cascadeTree.floor) {
                if (floor < minFloor) {
                    minFloor = floor;
                    minHash = hash;
                }
            }

            return { hash: minHash, floor: minFloor };
        }

        // updateConfirmationState: Update block confirmation based on DAGknight (dkoder-compliant)
        function updateConfirmationState(blockHash, coloringResult) {
            const { d, PENDING, BLUE, RED } = State.dagknight;
            const idx = State.blockHashToIndex.get(blockHash);
            if (idx === undefined) return;

            // Get floor value
            const { cascadeTree } = State.dagknight;
            const floor = cascadeTree.floor.get(blockHash);

            // Check if confirmed (floor >= -d)
            if (floor !== undefined && floor >= -d) {
                // Determine blue or red from coloring result
                if (coloringResult.mergesetBlues.has(blockHash) ||
                    blockHash === coloringResult.selectedParent) {
                    State.blockData.confirmationState[idx] = BLUE;
                    State.blockData.color[idx] = CONFIG.COLORS.BLUE_BLOCK;
                    State.blockData.isBlue[idx] = 1;
                } else if (coloringResult.mergesetReds.has(blockHash)) {
                    State.blockData.confirmationState[idx] = RED;
                    State.blockData.color[idx] = CONFIG.COLORS.RED_BLOCK;
                    State.blockData.isBlue[idx] = 0;
                }
            }
            // else: stays PENDING
        }

        // ============================================================
        // End DAGknight Engine
        // ============================================================

        // ============================================================
        // Interval-based Reachability (dkoder: reachability_service)
        // ============================================================

        /**
         * Compute intervals for all blocks in the given set
         * Using DFS traversal from root, assign [start, end] intervals
         * This enables O(1) chain ancestor checks
         *
         * dkoder uses: store.get_interval(this)?.contains(store.get_interval(queried)?)
         */
        function computeIntervals(rootHash, blockSet) {
            const { intervalMap } = State.dagknight;
            intervalMap.clear();
            State.dagknight.intervalCounter = 0;

            if (!rootHash || !blockSet || blockSet.size === 0) {
                return;
            }

            // Build child map: parent → [children]
            // This is needed because we only store parentHashes, not childHashes
            const childMap = new Map();
            for (const hash of blockSet) {
                const idx = State.blockHashToIndex.get(hash);
                if (idx === undefined) continue;
                const parents = State.blockData.parentHashes[idx] || [];
                for (const parentHash of parents) {
                    if (!blockSet.has(parentHash)) continue;
                    if (!childMap.has(parentHash)) {
                        childMap.set(parentHash, []);
                    }
                    childMap.get(parentHash).push(hash);
                }
            }

            // DFS to assign intervals
            const visited = new Set();
            function dfs(hash) {
                if (visited.has(hash)) return;
                visited.add(hash);

                const start = State.dagknight.intervalCounter++;

                // Visit children (blocks that have this as parent)
                const children = childMap.get(hash) || [];
                for (const childHash of children) {
                    dfs(childHash);
                }

                const end = State.dagknight.intervalCounter++;
                intervalMap.set(hash, { start, end });
            }

            dfs(rootHash);

            // Also process any blocks not reachable from root
            for (const hash of blockSet) {
                if (!visited.has(hash)) {
                    dfs(hash);
                }
            }
        }

        /**
         * Check if hashA is a CHAIN ancestor of hashB using intervals
         * This is O(1) - just interval containment check
         *
         * dkoder: is_chain_ancestor_of uses interval.contains()
         * A is ancestor of B if A.interval contains B.interval
         */
        function isChainAncestor(hashA, hashB) {
            const { intervalMap } = State.dagknight;
            const intervalA = intervalMap.get(hashA);
            const intervalB = intervalMap.get(hashB);

            if (!intervalA || !intervalB) return null;  // Unknown, need fallback

            // A contains B means A.start <= B.start && B.end <= A.end
            return intervalA.start <= intervalB.start && intervalB.end <= intervalA.end;
        }

        // ============================================================
        // End Interval-based Reachability
        // ============================================================

        // Step 2.2: Reachability - Check if blockA is ancestor of blockB
        function isAncestor(hashA, hashB, maxDepth = 100) {
            if (hashA === hashB) return true;

            // Try O(1) interval check first (dkoder: is_chain_ancestor_of)
            const chainResult = isChainAncestor(hashA, hashB);
            if (chainResult === true) return true;
            if (chainResult === false) return false;
            // chainResult === null means no interval data, fall through to BFS

            // Check cache (dkoder optimization)
            const cacheKey = hashA + ':' + hashB;
            const cached = State.dagknight.ancestorCache.get(cacheKey);
            if (cached !== undefined) return cached;

            const visited = new Set();
            const queue = [hashB];
            let depth = 0;

            while (queue.length > 0 && depth < maxDepth) {
                const levelSize = queue.length;
                for (let i = 0; i < levelSize; i++) {
                    const currentHash = queue.shift();
                    if (currentHash === hashA) {
                        State.dagknight.ancestorCache.set(cacheKey, true);
                        return true;
                    }
                    if (visited.has(currentHash)) continue;
                    visited.add(currentHash);

                    const idx = State.blockHashToIndex.get(currentHash);
                    if (idx === undefined) continue;
                    const parents = State.blockData.parentHashes[idx] || [];
                    for (const parentHash of parents) {
                        if (!visited.has(parentHash)) {
                            queue.push(parentHash);
                        }
                    }
                }
                depth++;
            }

            State.dagknight.ancestorCache.set(cacheKey, false);
            return false;
        }

        // Step 2.3: Find Latest Common Chain Ancestor (LCCA)
        function findLCCA(hashes) {
            if (hashes.length === 0) return null;
            if (hashes.length === 1) return hashes[0];

            // Build Selected Parent Chain for each hash
            const chains = hashes.map(hash => {
                const chain = new Set([hash]);
                let current = hash;
                for (let depth = 0; depth < 30; depth++) {
                    const idx = State.blockHashToIndex.get(current);
                    if (idx === undefined) break;
                    const parents = State.blockData.parentHashes[idx] || [];
                    if (parents.length === 0) break;

                    let selectedParent = State.selectedParentCache.get(current);
                    if (selectedParent === undefined) {
                        selectedParent = selectBestFromGroup(parents);
                        if (selectedParent) State.selectedParentCache.set(current, selectedParent);
                    }

                    if (!selectedParent || chain.has(selectedParent)) break;
                    chain.add(selectedParent);
                    current = selectedParent;
                }
                return chain;
            });

            // Find common blocks across all chains
            let common = chains[0];
            for (let i = 1; i < chains.length; i++) {
                common = new Set([...common].filter(x => chains[i].has(x)));
            }

            // Return the one with highest DAA score
            let lcca = null;
            let maxDaa = -1;
            for (const hash of common) {
                const idx = State.blockHashToIndex.get(hash);
                if (idx !== undefined) {
                    const daa = State.blockData.daaScore[idx];
                    if (daa > maxDaa) {
                        maxDaa = daa;
                        lcca = hash;
                    }
                }
            }
            return lcca;
        }

        // Step 2.4: Group blocks by conflict zone origin
        // Returns Map<conflictOriginHash, blockHash[]>
        function groupByConflictZone(blockHashes, lccaHash) {
            const groups = new Map();  // conflictOrigin -> [blockHashes]

            for (const blockHash of blockHashes) {
                // Find the first block after LCCA on path from block to LCCA
                const conflictOrigin = findConflictOrigin(blockHash, lccaHash);

                if (!groups.has(conflictOrigin)) {
                    groups.set(conflictOrigin, []);
                }
                groups.get(conflictOrigin).push(blockHash);
            }

            return groups;
        }

        // Find conflict origin: first block after LCCA on the path from block to LCCA
        function findConflictOrigin(blockHash, lccaHash) {
            if (blockHash === lccaHash) return lccaHash;

            // BFS from block to LCCA, tracking path
            const parent = new Map();  // child -> parent (for path reconstruction)
            const visited = new Set([blockHash]);
            const queue = [blockHash];

            while (queue.length > 0) {
                const current = queue.shift();
                if (current === lccaHash) break;

                const idx = State.blockHashToIndex.get(current);
                if (idx === undefined) continue;

                const parents = State.blockData.parentHashes[idx] || [];
                for (const p of parents) {
                    if (!visited.has(p)) {
                        visited.add(p);
                        parent.set(p, current);
                        queue.push(p);
                    }
                }
            }

            // Reconstruct path from LCCA back to block, return first child of LCCA
            if (!visited.has(lccaHash)) return blockHash;  // No path found

            let current = lccaHash;
            let prev = null;

            // Walk from LCCA to block via parent map (reversed)
            // We need to find the child of LCCA (first step away from LCCA toward block)
            const pathToBlock = [lccaHash];
            const lccaIdx = State.blockHashToIndex.get(lccaHash);
            if (lccaIdx === undefined) return blockHash;

            // Reverse: find which visited block has LCCA as parent
            for (const [child, p] of parent.entries()) {
                if (p === lccaHash || isAncestor(lccaHash, p, 5)) {
                    // This child is close to LCCA
                    if (isAncestor(child, blockHash, 50) || child === blockHash) {
                        return child;
                    }
                }
            }

            return blockHash;  // Fallback
        }

        // Step 2.5: Compare RankValue (k, blueWork, selectedParentHash)
        function compareRank(hashA, hashB) {
            const idxA = State.blockHashToIndex.get(hashA);
            const idxB = State.blockHashToIndex.get(hashB);
            if (idxA === undefined || idxB === undefined) return 0;

            // Compare blueWork (higher is better)
            // blueWork is hex string, convert with 0x prefix
            const workStrA = State.blockData.blueWork[idxA] || '0';
            const workStrB = State.blockData.blueWork[idxB] || '0';

            try {
                const blueWorkA = BigInt('0x' + workStrA.replace(/^0x/, ''));
                const blueWorkB = BigInt('0x' + workStrB.replace(/^0x/, ''));

                if (blueWorkA > blueWorkB) return -1;  // A wins
                if (blueWorkA < blueWorkB) return 1;   // B wins
            } catch (e) {
                // Fallback: compare as strings
                if (workStrA > workStrB) return -1;
                if (workStrA < workStrB) return 1;
            }

            // Tiebreaker: hash (lexicographic, lower wins)
            if (hashA < hashB) return -1;
            if (hashA > hashB) return 1;

            return 0;
        }

        // Step 2.6: Select best block from a group using RankValue
        function selectBestFromGroup(blockHashes) {
            if (blockHashes.length === 0) return null;
            if (blockHashes.length === 1) return blockHashes[0];

            let best = blockHashes[0];
            for (let i = 1; i < blockHashes.length; i++) {
                if (compareRank(blockHashes[i], best) < 0) {
                    best = blockHashes[i];
                }
            }
            return best;
        }

        // Step 2.7: DAGknight Parent Selection (hierarchical conflict resolution)
        // Skip dummy blocks - only select from real blocks
        function selectParent(parentHashes, depth = 0) {
            // Filter out dummies at entry - selected chain should only contain real blocks
            const realParents = depth === 0
                ? parentHashes.filter(h => !isDummyHash(h))
                : parentHashes;  // Already filtered in recursive calls

            if (depth > 10) return selectBestFromGroup(realParents);
            if (realParents.length === 0) return null;
            if (realParents.length === 1) return realParents[0];

            const lcca = findLCCA(realParents);
            if (!lcca) return selectBestFromGroup(realParents);

            const groups = groupByConflictZone(realParents, lcca);
            if (groups.size <= 1) return selectBestFromGroup(realParents);

            const groupWinners = [];
            for (const [origin, members] of groups.entries()) {
                const winner = selectBestFromGroup(members);
                if (winner) groupWinners.push(winner);
            }

            return selectParent(groupWinners, depth + 1);
        }

        // Step 2.8: Build Selected Chains from each Tip
        // Returns array of edges: [[from, to], [from, to], ...]
        // Also collects all ancestors (for topological ordering / Y=0 convergence)
        function buildSelectedChains(tipHashes, maxDepth = 50) {
            const edges = [];           // [fromHash, toHash] pairs for selected chain
            const visited = new Set();  // Avoid duplicate edges after merge
            const chainBlocks = new Set(); // Blocks on selected chain
            const orderedBlocks = new Set(); // All blocks that should be Y=0 (chain + ancestors)

            for (const tip of tipHashes) {
                let currentHash = tip;
                let depth = 0;

                while (currentHash && depth < maxDepth) {
                    const idx = State.blockHashToIndex.get(currentHash);
                    if (idx === undefined) break;

                    chainBlocks.add(currentHash);
                    orderedBlocks.add(currentHash);

                    const parents = State.blockData.parentHashes[idx] || [];
                    if (parents.length === 0) break;

                    // Add ALL parents to orderedBlocks (they are topologically ordered)
                    for (const p of parents) {
                        orderedBlocks.add(p);
                        // Recursively add ancestors of non-selected parents too
                        collectAncestors(p, orderedBlocks, 30);
                    }

                    // Select parent for this block (for chain edge)
                    const selectedParent = selectParent(parents);
                    if (!selectedParent) break;

                    // Add edge if not already visited (avoid duplicates after merge)
                    const edgeKey = `${currentHash}->${selectedParent}`;
                    if (!visited.has(edgeKey)) {
                        visited.add(edgeKey);
                        edges.push([currentHash, selectedParent]);
                    }

                    currentHash = selectedParent;
                    depth++;
                }
            }

            return { edges, chainBlocks, orderedBlocks };
        }

        // Helper: Collect all ancestors up to maxDepth
        function collectAncestors(hash, resultSet, maxDepth) {
            if (maxDepth <= 0 || resultSet.has(hash)) return;

            const idx = State.blockHashToIndex.get(hash);
            if (idx === undefined) return;

            resultSet.add(hash);

            const parents = State.blockData.parentHashes[idx] || [];
            for (const p of parents) {
                collectAncestors(p, resultSet, maxDepth - 1);
            }
        }

        // ============================================================
        // Linearization Algorithm (DAGknight/GHOSTDAG compliant)
        // ============================================================

        // Check if 'ancestor' is an ancestor of 'block' (with depth limit)
        function isAncestorOf(ancestor, block, maxDepth = 30) {
            if (!block || !ancestor) return false;
            if (ancestor === block) return true;

            const visited = new Set();
            const queue = [block];
            let depth = 0;

            while (queue.length > 0 && depth < maxDepth) {
                const levelSize = queue.length;
                for (let i = 0; i < levelSize; i++) {
                    const current = queue.shift();
                    if (current === ancestor) return true;

                    const idx = State.blockHashToIndex.get(current);
                    if (idx === undefined) continue;

                    const parents = State.blockData.parentHashes[idx] || [];
                    for (const p of parents) {
                        if (!visited.has(p)) {
                            visited.add(p);
                            queue.push(p);
                        }
                    }
                }
                depth++;
            }

            return false;
        }

        // Compute Mergeset (dkoder-style): BFS from chainBlock, stop at selectedParent's ancestors
        // This only processes blocks in the "river" between chainBlock and selectedParent
        function computeMergeset(chainBlock, selectedParent) {
            const mergeset = [];
            if (!chainBlock) return mergeset;

            const idx = State.blockHashToIndex.get(chainBlock);
            if (idx === undefined) return mergeset;

            const parents = State.blockData.parentHashes[idx] || [];
            if (parents.length === 0) return mergeset;

            // BFS from chainBlock's parents (excluding selectedParent)
            const visited = new Set();
            const pastOfSelected = new Set();  // Blocks known to be in Past(selectedParent)
            const queue = [];

            for (const p of parents) {
                if (p !== selectedParent) {
                    queue.push(p);
                    visited.add(p);
                    mergeset.push(p);
                }
            }

            // BFS with stopping condition (like dkoder)
            let iterations = 0;
            const maxIterations = 200;  // Safety limit

            while (queue.length > 0 && iterations < maxIterations) {
                const current = queue.shift();
                iterations++;

                const currentIdx = State.blockHashToIndex.get(current);
                if (currentIdx === undefined) continue;

                const currentParents = State.blockData.parentHashes[currentIdx] || [];
                for (const parent of currentParents) {
                    if (visited.has(parent) || pastOfSelected.has(parent)) {
                        continue;
                    }

                    // Check if this parent is an ancestor of selectedParent (stop condition)
                    if (selectedParent && isAncestorOf(parent, selectedParent, 20)) {
                        pastOfSelected.add(parent);
                        continue;  // Don't add to mergeset, stop exploring this path
                    }

                    visited.add(parent);
                    mergeset.push(parent);
                    queue.push(parent);
                }
            }

            return mergeset;
        }

        // Sort blocks by blue_work ascending, then hash ascending (tiebreaker)
        function sortByBlueWork(hashes) {
            return hashes.sort((a, b) => {
                const idxA = State.blockHashToIndex.get(a);
                const idxB = State.blockHashToIndex.get(b);
                if (idxA === undefined || idxB === undefined) return 0;

                // Get blueWork as BigInt
                const workStrA = State.blockData.blueWork[idxA] || '0';
                const workStrB = State.blockData.blueWork[idxB] || '0';

                try {
                    const workA = BigInt('0x' + workStrA.replace(/^0x/, ''));
                    const workB = BigInt('0x' + workStrB.replace(/^0x/, ''));

                    // Ascending order (lower blue_work first)
                    if (workA < workB) return -1;
                    if (workA > workB) return 1;
                } catch (e) {
                    // Fallback: string comparison
                    if (workStrA < workStrB) return -1;
                    if (workStrA > workStrB) return 1;
                }

                // Tiebreaker: hash ascending
                if (a < b) return -1;
                if (a > b) return 1;

                return 0;
            });
        }

        // Build complete linear order from Selected Chain
        // Order: S0 → mergeset(S1) → S1 → mergeset(S2) → S2 → ...
        function buildLinearOrder(selectedChain) {
            if (selectedChain.length === 0) return [];

            const linearOrder = [];
            const addedToOrder = new Set();

            // Reverse chain to go from oldest to newest
            const chainOldestFirst = [...selectedChain].reverse();

            for (let i = 0; i < chainOldestFirst.length; i++) {
                const chainBlock = chainOldestFirst[i];
                const prevChainBlock = i > 0 ? chainOldestFirst[i - 1] : null;

                // Compute mergeset for this chain block
                const mergeset = computeMergeset(chainBlock, prevChainBlock);

                // Add dummy blocks as part of mergeset (high BPS simulation)
                // Dummies are treated as parallel blocks absorbed by this chain block
                if (CONFIG.DUMMY.ENABLED) {
                    for (let j = 0; j < CONFIG.DUMMY.MULTIPLIER; j++) {
                        const dummyHash = generateDummyHash(chainBlock, j);
                        if (State.blockHashToIndex.has(dummyHash) && !addedToOrder.has(dummyHash)) {
                            mergeset.push(dummyHash);
                        }
                    }
                }

                // Sort mergeset by blue_work ascending (dummies have lower blueWork)
                const sortedMergeset = sortByBlueWork(mergeset);

                // Add mergeset blocks (skip if already added)
                for (const hash of sortedMergeset) {
                    if (!addedToOrder.has(hash)) {
                        addedToOrder.add(hash);
                        linearOrder.push(hash);
                    }
                }

                // Add chain block itself
                if (!addedToOrder.has(chainBlock)) {
                    addedToOrder.add(chainBlock);
                    linearOrder.push(chainBlock);
                }
            }

            return linearOrder;
        }

        // Step 2.9: Run DAGknight calculation and update block positions
        function runDAGknightCalculation() {
            if (State.blockCount < 2) return;

            try {
                // Find all tips (blocks with no children)
                const allHashes = [];
                for (let i = 0; i < State.blockCount; i++) {
                    const hash = State.blockData.hashes[i];
                    if (hash) allHashes.push(hash);
                }

                // Find tips by checking which blocks are not parents of any other block
                const hasChild = new Set();
                for (let i = 0; i < State.blockCount; i++) {
                    const parents = State.blockData.parentHashes[i] || [];
                    for (const p of parents) {
                        hasChild.add(p);
                    }
                }

                const tips = allHashes.filter(h => !hasChild.has(h));
                if (tips.length === 0) return;

                // Build Selected Chains from tips (with timeout protection)
                const startTime = performance.now();
                const { edges, chainBlocks, orderedBlocks } = buildSelectedChains(tips.slice(0, 10));

                // Find LCCA (convergence point where all tip paths meet)
                const lccaHash = findLCCA(tips.slice(0, 10));
                State.lccaHash = lccaHash;

                // Build Single Selected Chain for linearization (dkoder compliant)
                // Start from best tip (highest blue_work), follow selected parents
                const bestTip = selectParent(tips);
                const chainList = [];
                let currentChainBlock = bestTip;
                const maxChainDepth = 100;

                while (currentChainBlock && chainList.length < maxChainDepth) {
                    chainList.push(currentChainBlock);

                    const idx = State.blockHashToIndex.get(currentChainBlock);
                    if (idx === undefined) break;

                    const parents = State.blockData.parentHashes[idx] || [];
                    if (parents.length === 0) break;

                    // Select next chain block (highest blue_work parent)
                    currentChainBlock = selectParent(parents);
                }
                // chainList is now [bestTip, parent1, parent2, ...] = newest to oldest

                // Build linear order (DAGknight compliant)
                const linearOrder = buildLinearOrder(chainList);
                const calcTime = performance.now() - startTime;

                // Use edges from buildSelectedChains (all tips → LCCA)
                // This shows Selected Parent path from each tip to convergence point
                State.selectedChainEdges = edges;

                State.selectedChainBlocks = chainBlocks;
                State.orderedBlocks = orderedBlocks;
                State.linearOrder = linearOrder;

                // --- DAGknight Coloring: Dynamic k-search with caching ---
                const { PENDING, BLUE, RED } = State.dagknight;
                let coloredCount = 0;
                const processedParentSets = new Set();  // Cache: avoid duplicate calculations

                // Process from tips backwards - each tip confirms its parents
                // Limit processing to avoid performance issues
                const tipsToProcess = tips.slice(0, 20);  // Process up to 20 tips

                for (const tipHash of tipsToProcess) {
                    const tipIdx = State.blockHashToIndex.get(tipHash);
                    if (tipIdx === undefined) continue;

                    const parents = State.blockData.parentHashes[tipIdx] || [];
                    if (parents.length === 0) continue;

                    // Cache key: sorted parent hashes
                    const parentsKey = parents.slice().sort().join(',');
                    if (processedParentSets.has(parentsKey)) continue;
                    processedParentSets.add(parentsKey);

                    // DAGknight: Call main function (dkoder-aligned structure)
                    const dkResult = dagknight(parents);
                    const coloringResult = dkResult.coloringResult;
                    const usedK = dkResult.k;

                    // Skip if no valid coloring result
                    if (!coloringResult) continue;

                    // Update confirmation state for parents
                    for (const parentHash of parents) {
                        const parentIdx = State.blockHashToIndex.get(parentHash);
                        if (parentIdx === undefined) continue;

                        // Only update if still pending
                        if (State.blockData.confirmationState[parentIdx] !== PENDING) continue;

                        // Determine blue or red based on DAGknight coloring
                        if (parentHash === coloringResult.selectedParent ||
                            coloringResult.mergesetBlues.has(parentHash)) {
                            State.blockData.confirmationState[parentIdx] = BLUE;
                            State.blockData.color[parentIdx] = CONFIG.COLORS.BLUE_BLOCK;
                            State.blockData.isBlue[parentIdx] = 1;
                        } else if (coloringResult.mergesetReds.has(parentHash)) {
                            State.blockData.confirmationState[parentIdx] = RED;
                            State.blockData.color[parentIdx] = CONFIG.COLORS.RED_BLOCK;
                            State.blockData.isBlue[parentIdx] = 0;
                        } else {
                            // Ancestor of selected parent - blue
                            State.blockData.confirmationState[parentIdx] = BLUE;
                            State.blockData.color[parentIdx] = CONFIG.COLORS.BLUE_BLOCK;
                            State.blockData.isBlue[parentIdx] = 1;
                        }
                        coloredCount++;
                    }

                    // Store the k value used
                    State.dagknight.coloringK.set(tipHash, usedK);
                }

                // Also color any remaining hasChild blocks that weren't processed
                // (older blocks not reachable from current tips)
                for (let i = 0; i < State.blockCount; i++) {
                    if (State.blockData.confirmationState[i] !== PENDING) continue;
                    const blockHash = State.blockData.hashes[i];
                    if (!blockHash) continue;

                    if (hasChild.has(blockHash)) {
                        // Has children but wasn't processed - mark as Blue
                        State.blockData.confirmationState[i] = BLUE;
                        State.blockData.color[i] = CONFIG.COLORS.BLUE_BLOCK;
                        State.blockData.isBlue[i] = 1;
                        coloredCount++;
                    }
                }
                // --- End DAGknight Coloring ---

                // Assign linearIndex and targetX to linearized blocks
                // Position blocks based on view mode
                if (CONFIG.VIEW_MODE === 'dag') {
                    // DAG mode: Keep newest block inside right edge (zoom-aware)
                    if (State.maxDaaScore !== null && State.minDaaScore !== null) {
                        const maxColumn = Math.floor((State.maxDaaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                        const maxX = maxColumn * CONFIG.DAA_COLUMN_WIDTH;
                        const halfWidth = State.viewport.width / 2;
                        const zoom = State.viewport.zoom;
                        const margin = 150 / zoom;  // 150px margin from right edge
                        // Position viewport so maxX is inside right edge
                        State.viewport.targetX = maxX - halfWidth / zoom + margin;
                    }
                    // targetX/Y already set in addBlock, no changes needed
                } else {
                    // Linear mode: linearized blocks align to chain
                    const maxLinearIdx = linearOrder.length - 1;
                    const SPAWN_X = CONFIG.SPAWN_X;

                    // Build hash→index map for O(1) lookup
                    const linearOrderMap = new Map();
                    for (let idx = 0; idx < linearOrder.length; idx++) {
                        linearOrderMap.set(linearOrder[idx], idx);
                    }

                    for (let i = 0; i < State.blockCount; i++) {
                        const hash = State.blockData.hashes[i];
                        const linearIdx = linearOrderMap.has(hash) ? linearOrderMap.get(hash) : -1;

                        if (linearIdx !== -1) {
                            // Block is linearized - right aligned from SPAWN_X
                            State.blockData.linearIndex[i] = linearIdx;
                            State.blockData.targetX[i] = SPAWN_X - (maxLinearIdx - linearIdx) * CONFIG.LINEAR_PITCH;
                            State.blockData.targetY[i] = 0;
                            State.blockData.isBlue[i] = 1;
                        } else {
                            // Block not yet linearized - place just right of SPAWN_X
                            State.blockData.linearIndex[i] = -1;
                            State.blockData.targetX[i] = SPAWN_X + 20;
                            // targetY stays at random position
                        }
                    }
                }

                // Viewport control (Linear mode stays fixed)

                // Cleanup: Remove blocks that have scrolled too far left
                // Dynamic threshold based on zoom and viewport position
                // Both modes: 1.5x total (visible + 0.5x margin)
                const { zoom, width, x: vpX } = State.viewport;
                const halfWidth = width / 2;
                const visibleLeft = vpX - halfWidth / zoom;
                const cleanupThreshold = visibleLeft - width / zoom * 0.5;  // 0.5x margin

                let removedCount = 0;
                for (let i = 0; i < State.blockCount; i++) {
                    const hash = State.blockData.hashes[i];
                    if (!hash) continue;

                    // Check if block is too far left (past dynamic cleanup threshold)
                    if (State.blockData.x[i] < cleanupThreshold) {
                        // Remove from hash map
                        State.blockHashToIndex.delete(hash);
                        // Clear the slot
                        State.blockData.hashes[i] = null;
                        removedCount++;
                    }
                }

                // Update cached sorted indices (by X descending = newest first)
                // This avoids O(n log n) sort every frame in renderDAG
                const { x } = State.blockData;
                State.sortedIndices = [];
                for (let i = 0; i < State.blockCount; i++) {
                    if (State.blockData.hashes[i]) {
                        State.sortedIndices.push(i);
                    }
                }
                State.sortedIndices.sort((a, b) => x[b] - x[a]);
            } catch (error) {
                console.error('DAGknight calculation error:', error);
            }
        }

        // ------------------------------------------------------------
        // Block Management
        // ------------------------------------------------------------
        function addBlock(blockInfo) {
            const index = State.ringHead;

            // Remove oldest block BEFORE overwriting (Ring Buffer bug fix)
            if (State.blockCount >= CONFIG.MAX_BLOCKS) {
                const oldestHash = State.blockData.hashes[index];
                State.blockHashToIndex.delete(oldestHash);
            }

            // Store hash (WASM SDK uses header.hash, not block.hash)
            const hash = blockInfo.header.hash;
            State.blockData.hashes[index] = hash;
            State.blockHashToIndex.set(hash, index);

            // Calculate position using relative coordinates (avoids Float32 precision issues)
            const daaScore = Number(blockInfo.header.daaScore);
            State.blockData.daaScore[index] = daaScore;

            // Set reference point on first block
            if (State.minDaaScore === null) {
                State.minDaaScore = daaScore;
                State.maxDaaScore = daaScore;
            }

            // Track DAA score range (for reference)
            if (daaScore > State.maxDaaScore) {
                State.maxDaaScore = daaScore;
            }

            // Position based on view mode
            const yScale = CONFIG.DUMMY.ENABLED ? (CONFIG.DUMMY.MULTIPLIER <= 2 ? 1.5 : 2.0) : 1.0;
            if (CONFIG.VIEW_MODE === 'dag') {
                // DAG mode: X based on column (DAA grouped), Y based on order in column
                const column = Math.floor((daaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                const columnX = column * CONFIG.DAA_COLUMN_WIDTH;

                // Get block index within column for Y positioning
                const columnKey = column;
                const blockIndexInColumn = State.dagColumnCount.get(columnKey) || 0;
                State.dagColumnCount.set(columnKey, blockIndexInColumn + 1);

                // Calculate Y: 0, +20, -20, +40, -40, ... (scaled for high BPS)
                let blockY;
                if (blockIndexInColumn === 0) {
                    blockY = 0;
                } else {
                    const offset = Math.ceil(blockIndexInColumn / 2) * CONFIG.Y_STEP * yScale;
                    const direction = (blockIndexInColumn % 2 === 1) ? 1 : -1;
                    blockY = offset * direction;
                }

                State.blockData.x[index] = columnX;
                State.blockData.targetX[index] = columnX;
                State.blockData.y[index] = blockY;
                State.blockData.targetY[index] = blockY;
            } else {
                // Linear mode: X at spawn area (will be updated by linearization)
                const tipOffset = 10 + Math.random() * 30;
                State.blockData.x[index] = CONFIG.SPAWN_X + tipOffset;
                State.blockData.targetX[index] = State.blockData.x[index];

                const randomY = (Math.random() - 0.5) * 300 * yScale;
                State.blockData.y[index] = randomY;
                State.blockData.targetY[index] = randomY;
            }
            State.blockData.linearIndex[index] = -1;  // Not linearized yet

            // Store blueScore, blueWork, and bits for DAGknight calculation
            State.blockData.blueScore[index] = Number(blockInfo.header.blueScore || 0);
            State.blockData.blueWork[index] = blockInfo.header.blueWork || '0';
            State.blockData.bits[index] = Number(blockInfo.header.bits || 0);

            // Color: Start as Pending (gray), will be confirmed when child arrives
            State.blockData.color[index] = CONFIG.COLORS.PENDING_BLOCK;
            State.blockData.confirmationState[index] = 0;  // 0 = Pending
            State.blockData.isBlue[index] = 1;  // Default to blue (will be updated)
            State.blockData.size[index] = CONFIG.BLOCK_SIZE;

            // Store parent hashes (resolved dynamically in renderDAG)
            // WASM SDK uses parentsByLevel - only use level 0 (direct parents)
            const parentsByLevel = blockInfo.header.parentsByLevel || [];
            const parents = [...(parentsByLevel[0] || [])];  // Copy to avoid mutation

            // Phase 3: Add dummy tips as additional parents (high BPS simulation)
            // Dynamic limit: MULTIPLIER * 2 to balance generation/consumption rate
            // 2x: 2 parents, 3x: 4 parents, 10x: 18 parents
            if (CONFIG.DUMMY.ENABLED && State.dummyTips.size > 0) {
                const dummyParentsToAdd = [];
                let addedCount = 0;
                const dynamicLimit = CONFIG.DUMMY.MULTIPLIER * 2;

                for (const [dummyHash, selectCount] of State.dummyTips) {
                    // Limit dummy parents per block (dynamic based on multiplier)
                    if (addedCount >= dynamicLimit) break;

                    // Add dummy as parent
                    dummyParentsToAdd.push(dummyHash);
                    addedCount++;

                    // Increment select count
                    const newCount = selectCount + 1;
                    if (newCount >= CONFIG.DUMMY.MAX_PARENT_SELECT) {
                        // Remove from tips (has been selected enough times)
                        State.dummyTips.delete(dummyHash);
                    } else {
                        State.dummyTips.set(dummyHash, newCount);
                    }
                }
                // Add limited dummy parents to the block's parents
                parents.push(...dummyParentsToAdd);
            }

            State.blockData.parentHashes[index] = parents;

            // DAGknight: Block starts as Pending (gray)
            // Actual blue/red coloring is computed in updateDAGknight() every 0.5s
            // This keeps addBlock() lightweight for high BPS

            // Update ring buffer
            State.ringHead = (State.ringHead + 1) % CONFIG.MAX_BLOCKS;
            if (State.blockCount < CONFIG.MAX_BLOCKS) {
                State.blockCount++;
            }

            // Viewport stays at center (0, 0) - no need to update
            // Note: blockCount DOM update moved to updateStatsDisplay (1/sec instead of per-block)
        }

        // ------------------------------------------------------------
        // Kaspa SDK Integration
        // ------------------------------------------------------------
        async function initKaspaSDK() {
            updateLoadingText('Loading Kaspa SDK...');

            try {
                // Dynamic import of local Kaspa WASM SDK
                const kaspa = await import('./kaspa-core.js');

                // Initialize WASM binary
                await kaspa.default({ module_or_path: './kaspa-core_bg.wasm' });

                // Store kaspa module in state for later use
                State.kaspa = kaspa;

                updateLoadingText('Connecting to network...');

                // Create RPC client
                const resolver = new kaspa.Resolver();
                State.rpcClient = new kaspa.RpcClient({
                    resolver,
                    networkId: 'mainnet',
                });

                // Connect
                await State.rpcClient.connect();

                // Get initial info
                const info = await State.rpcClient.getBlockDagInfo();

                // Update UI
                State.isConnected = true;
                DOM.status.classList.add('connected');
                DOM.connectionStatus.textContent = 'Connected';
                DOM.networkName.textContent = 'Mainnet';

                // Subscribe to new blocks
                await subscribeToBlocks();

                return kaspa;
            } catch (error) {
                console.error('Failed to initialize Kaspa SDK:', error);
                DOM.connectionStatus.textContent = 'Error: ' + error.message;
                throw error;
            }
        }

        async function subscribeToBlocks() {
            updateLoadingText('Subscribing to blocks...');

            // Subscribe to block added notifications
            State.rpcClient.addEventListener('block-added', async (event) => {
                try {
                    const block = event.data.block;

                    // During pause: buffer blocks (up to 5 seconds worth)
                    if (State.isPaused) {
                        if (!State.pauseExpired) {
                            State.pauseBuffer.push(block);
                        }
                        return;
                    }

                    // block-added event already contains full block info
                    addBlock(block);

                    // Generate dummy blocks for high BPS simulation (Phase 2)
                    generateDummyBlocks(block);
                } catch (error) {
                    console.warn('Failed to process block:', error);
                }
            });

            // Start subscription
            await State.rpcClient.subscribeBlockAdded();
        }

        // ------------------------------------------------------------
        // UI Updates
        // ------------------------------------------------------------
        function updateLoadingText(text) {
            DOM.loadingText.textContent = text;
        }

        function hideLoading() {
            DOM.loading.classList.add('hidden');
        }

        // Update block info panel (pause mode only)
        function updateBlockInfo() {
            const idx = State.selectedBlockIndex;
            if (idx === null || !State.blockData.hashes[idx]) {
                DOM.infoHash.textContent = '-';
                DOM.infoDaa.textContent = '-';
                DOM.infoBlueScore.textContent = '-';
                DOM.infoBlueWork.textContent = '-';
                DOM.blockInfo.classList.remove('clickable');
                DOM.infoHint.textContent = 'Tap a block to inspect';
                return;
            }
            const hash = State.blockData.hashes[idx];
            const daaScore = State.blockData.daaScore[idx];
            const blueScore = State.blockData.blueScore[idx];
            const blueWork = State.blockData.blueWork[idx] || '0';

            // Hash: full display
            DOM.infoHash.textContent = hash;
            DOM.infoDaa.textContent = daaScore.toLocaleString();
            DOM.infoBlueScore.textContent = blueScore.toLocaleString();
            DOM.infoBlueWork.textContent = blueWork;

            // Enable link to kaspa.stream
            DOM.blockInfo.classList.add('clickable');
            DOM.infoHint.textContent = 'Tap to view on kaspa.stream';
        }

        function updateStatsDisplay() {
            // Block count (moved from addBlock - 1/sec instead of per-block)
            DOM.blockCount.textContent = State.blockCount;

            // DAA Score (latest)
            DOM.daaScore.textContent = State.maxDaaScore !== null
                ? State.maxDaaScore.toLocaleString()
                : '-';

            // FPS
            DOM.fpsDisplay.textContent = `${State.stats.fps} FPS`;
            DOM.fpsDisplay.className = 'fps';
            if (State.stats.fps < 30) {
                DOM.fpsDisplay.classList.add('critical');
            } else if (State.stats.fps < 50) {
                DOM.fpsDisplay.classList.add('warning');
            }

            // Draw calls and visible blocks
            DOM.drawCalls.textContent = `Draws: ${State.stats.drawCalls} | Visible: ${State.stats.visibleBlocks}`;

            // Memory (if available)
            if (performance.memory) {
                const mb = Math.round(performance.memory.usedJSHeapSize / 1024 / 1024);
                DOM.memoryUsage.textContent = `Mem: ${mb}MB | Edges: ${State.stats.edgeCount}`;
            } else {
                DOM.memoryUsage.textContent = `Edges: ${State.stats.edgeCount}`;
            }

            // Debug info (multi-line for readability)
            if (DOM.debugInfo) {
                const lines = [];

                // Version
                lines.push(CONFIG.VERSION);

                // K cluster size and zone block count (minimal debug)
                const kVal = State.dagknight.lastK ?? '-';
                const zoneBlocks = State.dagknight.lastZoneBlockCount ?? 0;
                lines.push(`k:${kVal} | zone:${zoneBlocks}`);

                // Dummy status
                if (CONFIG.DUMMY.ENABLED) {
                    lines.push(`[DUMMY] ${1 + CONFIG.DUMMY.MULTIPLIER}x BPS`);
                }

                // Viewport debug (temporary)
                const canvasW = State.app?.canvas?.clientWidth ?? 0;
                const vpW = State.viewport.width;
                lines.push(`canvas:${canvasW} vp:${vpW}`);

                DOM.debugInfo.innerHTML = lines.join('<br>');
            }
        }

        // ------------------------------------------------------------
        // Controls
        // ------------------------------------------------------------
        function setupControls() {
            DOM.btnDisconnect.addEventListener('click', async () => {
                if (State.isConnected && State.rpcClient) {
                    try {
                        await State.rpcClient.disconnect();
                        State.isConnected = false;
                        DOM.connectionStatus.textContent = 'Disconnected';
                        DOM.connectionStatus.className = 'disconnected';
                        DOM.btnDisconnect.textContent = 'Connect';
                    } catch (e) {
                        console.error('Disconnect error:', e);
                    }
                } else {
                    // Reconnect
                    try {
                        await State.rpcClient.connect();
                        await State.rpcClient.subscribeBlockAdded();
                        State.isConnected = true;
                        DOM.connectionStatus.textContent = 'Connected';
                        DOM.connectionStatus.className = 'connected';
                        DOM.btnDisconnect.textContent = 'Disconnect';
                    } catch (e) {
                        console.error('Connect error:', e);
                    }
                }
            });

            DOM.btnPause.addEventListener('click', () => {
                if (!State.isPaused) {
                    // --- PAUSE ---
                    State.isPaused = true;
                    State.pauseStartTime = Date.now();
                    State.pauseBuffer = [];
                    State.pauseExpired = false;
                    State.selectedBlockIndex = null;
                    DOM.btnPause.textContent = 'Resume (5s)';
                    DOM.blockInfo.classList.add('visible');
                    updateBlockInfo();

                    // Start countdown timer
                    let remaining = 5;
                    const countdownInterval = setInterval(() => {
                        if (!State.isPaused) {
                            clearInterval(countdownInterval);
                            return;
                        }
                        remaining--;
                        if (remaining > 0) {
                            DOM.btnPause.textContent = `Resume (${remaining}s)`;
                        } else {
                            // 5 seconds expired
                            State.pauseExpired = true;
                            DOM.btnPause.textContent = 'Expired';
                            DOM.btnPause.disabled = true;
                            clearInterval(countdownInterval);
                        }
                    }, 1000);
                } else {
                    // --- RESUME ---
                    if (State.pauseExpired) {
                        // Cannot resume after 5 seconds - use Reset
                        return;
                    }

                    // Process buffered blocks quickly
                    const bufferedBlocks = State.pauseBuffer;
                    State.pauseBuffer = [];
                    State.isPaused = false;
                    State.pauseStartTime = null;
                    State.selectedBlockIndex = null;
                    DOM.btnPause.textContent = 'Pause';
                    DOM.blockInfo.classList.remove('visible');

                    // Add all buffered blocks
                    for (const block of bufferedBlocks) {
                        addBlock(block);
                        generateDummyBlocks(block);
                    }
                }
            });

            DOM.btnReset.addEventListener('click', () => {
                // Clear all blocks
                State.blockCount = 0;
                State.ringHead = 0;
                State.ringTail = 0;
                State.blockHashToIndex.clear();
                State.viewport.x = 0;
                State.viewport.y = 0;
                DOM.blockCount.textContent = '0';

                // Reset pause state
                State.isPaused = false;
                State.pauseStartTime = null;
                State.pauseBuffer = [];
                State.pauseExpired = false;
                State.selectedBlockIndex = null;
                DOM.btnPause.disabled = false;
                DOM.btnPause.textContent = 'Pause';
                DOM.blockInfo.classList.remove('visible');

                // Reset DAG state
                State.minDaaScore = null;
                State.maxDaaScore = null;
                State.dagColumnCount.clear();
                State.selectedChainEdges = [];
                State.selectedChainBlocks = new Set();
                State.linearOrder = [];
                State.lccaHash = null;
                State.sortedIndices = [];
            });

            // Block info panel click -> open kaspa.stream
            DOM.blockInfo.addEventListener('click', () => {
                const idx = State.selectedBlockIndex;
                if (idx === null || !State.blockData.hashes[idx]) return;
                const hash = State.blockData.hashes[idx];
                window.open(`https://kaspa.stream/blocks/${hash}`, '_blank');
            });

            // Zoom with right edge as anchor point
            function zoomWithRightAnchor(newZoom) {
                const oldZoom = State.viewport.zoom;
                const halfWidth = State.viewport.width / 2;
                // Keep right edge at same world position
                State.viewport.x += halfWidth * (1 / oldZoom - 1 / newZoom);
                State.viewport.targetX = State.viewport.x;
                State.viewport.zoom = newZoom;
            }

            DOM.btnZoomIn.addEventListener('click', () => {
                const newZoom = Math.min(State.viewport.zoom * 1.2, 3);
                zoomWithRightAnchor(newZoom);
            });

            DOM.btnZoomOut.addEventListener('click', () => {
                const newZoom = Math.max(State.viewport.zoom / 1.2, 0.2);
                zoomWithRightAnchor(newZoom);
            });

            // Dummy block simulation controls
            function updateDummyUI() {
                // Update toggle button
                DOM.btnDummyToggle.textContent = CONFIG.DUMMY.ENABLED ? 'ON' : 'OFF';
                DOM.btnDummyToggle.classList.toggle('active', CONFIG.DUMMY.ENABLED);

                // Update multiplier buttons
                const mult = CONFIG.DUMMY.MULTIPLIER;
                DOM.btnDummy30bps.classList.toggle('selected', mult === 2);
                DOM.btnDummy100bps.classList.toggle('selected', mult === 9);
            }

            DOM.btnDummyToggle.addEventListener('click', () => {
                CONFIG.DUMMY.ENABLED = !CONFIG.DUMMY.ENABLED;
                updateDummyUI();
            });

            DOM.btnDummy30bps.addEventListener('click', () => {
                CONFIG.DUMMY.MULTIPLIER = 2;  // 10BPS × 3 = 30BPS
                updateDummyUI();
            });

            DOM.btnDummy100bps.addEventListener('click', () => {
                CONFIG.DUMMY.MULTIPLIER = 9;  // 10BPS × 10 = 100BPS
                updateDummyUI();
            });

            // View mode controls
            function updateViewModeUI() {
                DOM.btnViewLinear.classList.toggle('selected', CONFIG.VIEW_MODE === 'linear');
                DOM.btnViewDag.classList.toggle('selected', CONFIG.VIEW_MODE === 'dag');
            }

            function switchViewMode(mode) {
                CONFIG.VIEW_MODE = mode;
                updateViewModeUI();

                if (mode === 'dag') {
                    // Reset column counts for DAG mode
                    State.dagColumnCount.clear();

                    // First pass: count blocks per column
                    const columnBlocks = new Map();  // column -> [indices]
                    for (let i = 0; i < State.blockCount; i++) {
                        const hash = State.blockData.hashes[i];
                        if (!hash) continue;
                        const daaScore = State.blockData.daaScore[i];
                        const column = Math.floor((daaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                        if (!columnBlocks.has(column)) columnBlocks.set(column, []);
                        columnBlocks.get(column).push(i);
                    }

                    // Second pass: assign X/Y positions
                    // Apply yScale for high BPS simulation
                    const yScale = CONFIG.DUMMY.ENABLED ? (CONFIG.DUMMY.MULTIPLIER <= 2 ? 1.5 : 2.0) : 1.0;
                    for (const [column, indices] of columnBlocks) {
                        const columnX = column * CONFIG.DAA_COLUMN_WIDTH;
                        indices.forEach((idx, blockIndexInColumn) => {
                            // Calculate Y: 0, +20, -20, +40, -40, ... (scaled for high BPS)
                            let blockY;
                            if (blockIndexInColumn === 0) {
                                blockY = 0;
                            } else {
                                const offset = Math.ceil(blockIndexInColumn / 2) * CONFIG.Y_STEP * yScale;
                                const direction = (blockIndexInColumn % 2 === 1) ? 1 : -1;
                                blockY = offset * direction;
                            }
                            State.blockData.targetX[idx] = columnX;
                            State.blockData.targetY[idx] = blockY;
                        });
                        State.dagColumnCount.set(column, indices.length);
                    }

                    // Update viewport for DAG mode (newest at right side)
                    if (State.maxDaaScore !== null && State.minDaaScore !== null) {
                        const maxColumn = Math.floor((State.maxDaaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                        const maxX = maxColumn * CONFIG.DAA_COLUMN_WIDTH;
                        State.viewport.targetX = maxX - CONFIG.SPAWN_X;
                    }
                } else {
                    // Linear mode: calculate correct positions using linearOrder
                    const linearOrder = State.linearOrder || [];
                    const maxLinearIdx = linearOrder.length - 1;
                    const SPAWN_X = CONFIG.SPAWN_X;

                    // Build hash→linearIndex map
                    const linearOrderMap = new Map();
                    for (let idx = 0; idx < linearOrder.length; idx++) {
                        linearOrderMap.set(linearOrder[idx], idx);
                    }

                    for (let i = 0; i < State.blockCount; i++) {
                        const hash = State.blockData.hashes[i];
                        if (!hash) continue;

                        const linearIdx = linearOrderMap.has(hash) ? linearOrderMap.get(hash) : -1;

                        if (linearIdx !== -1) {
                            // Linearized block - proper chain position
                            const newX = SPAWN_X - (maxLinearIdx - linearIdx) * CONFIG.LINEAR_PITCH;
                            State.blockData.targetX[i] = newX;
                            State.blockData.x[i] = newX;  // Instant X (prevent fly-off)
                            State.blockData.targetY[i] = 0;
                            // Y animates via lerp (smooth convergence to chain)
                            State.blockData.linearIndex[i] = linearIdx;
                        } else {
                            // Not linearized - spawn area
                            const newX = SPAWN_X + 20;
                            State.blockData.targetX[i] = newX;
                            State.blockData.x[i] = newX;  // Instant X (prevent fly-off)
                            State.blockData.targetY[i] = 0;
                            // Y animates via lerp
                        }
                    }
                    State.viewport.targetX = 0;
                    State.viewport.x = 0;  // Instant viewport
                }
            }

            DOM.btnViewLinear.addEventListener('click', () => switchViewMode('linear'));
            DOM.btnViewDag.addEventListener('click', () => switchViewMode('dag'));

            // Pan with mouse drag
            let isDragging = false;
            let lastMouse = { x: 0, y: 0 };
            let lastPinchDist = 0;
            let touchStartPos = null;  // For tap detection

            // Mouse events (desktop)
            State.app.canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouse = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = (e.clientX - lastMouse.x) / State.viewport.zoom;
                const dy = (e.clientY - lastMouse.y) / State.viewport.zoom;
                State.viewport.x -= dx;
                State.viewport.y -= dy;
                State.viewport.targetX = State.viewport.x;
                lastMouse = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Touch events (mobile)
            State.app.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    isDragging = true;
                    lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    // Pinch zoom start
                    isDragging = false;
                    touchStartPos = null;
                    const dx = e.touches[1].clientX - e.touches[0].clientX;
                    const dy = e.touches[1].clientY - e.touches[0].clientY;
                    lastPinchDist = Math.sqrt(dx * dx + dy * dy);
                }
            }, { passive: false });

            State.app.canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1 && isDragging) {
                    // Single finger drag
                    const dx = (e.touches[0].clientX - lastMouse.x) / State.viewport.zoom;
                    const dy = (e.touches[0].clientY - lastMouse.y) / State.viewport.zoom;
                    State.viewport.x -= dx;
                    State.viewport.y -= dy;
                    State.viewport.targetX = State.viewport.x;
                    lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2 && lastPinchDist > 0) {
                    // Pinch zoom
                    const dx = e.touches[1].clientX - e.touches[0].clientX;
                    const dy = e.touches[1].clientY - e.touches[0].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const scale = dist / lastPinchDist;
                    const newZoom = Math.max(0.2, Math.min(3, State.viewport.zoom * scale));
                    zoomWithRightAnchor(newZoom);
                    lastPinchDist = dist;
                }
            }, { passive: false });

            State.app.canvas.addEventListener('touchend', (e) => {
                // Detect tap (no significant movement) for block selection
                if (State.isPaused && touchStartPos && e.changedTouches.length === 1) {
                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const moveDist = Math.sqrt(
                        Math.pow(endX - touchStartPos.x, 2) +
                        Math.pow(endY - touchStartPos.y, 2)
                    );

                    // If moved less than 10px, treat as tap
                    if (moveDist < 10) {
                        const rect = State.app.canvas.getBoundingClientRect();
                        const tapX = endX - rect.left;
                        const tapY = endY - rect.top;

                        // Convert screen coords to world coords
                        const { zoom, width, height, x: vpX, y: vpY } = State.viewport;
                        const halfWidth = width / 2;
                        const halfHeight = height / 2;
                        const worldX = (tapX - halfWidth) / zoom + vpX;
                        const worldY = (tapY - halfHeight) / zoom + vpY;

                        // Hit test: find nearest block within radius
                        const hitRadius = CONFIG.BLOCK_SIZE_VIRTUAL * 2;  // Larger radius for touch
                        let foundIdx = null;
                        let minDist = hitRadius;

                        const { x, y, hashes } = State.blockData;
                        for (let i = 0; i < State.blockCount; i++) {
                            if (!hashes[i]) continue;
                            const dx = x[i] - worldX;
                            const dy = y[i] - worldY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < minDist) {
                                minDist = dist;
                                foundIdx = i;
                            }
                        }

                        State.selectedBlockIndex = foundIdx;
                        updateBlockInfo();
                    }
                }

                isDragging = false;
                lastPinchDist = 0;
                touchStartPos = null;
            });

            // Zoom with mouse wheel (right edge anchor)
            State.app.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(0.2, Math.min(3, State.viewport.zoom * zoomFactor));
                zoomWithRightAnchor(newZoom);
            });

            // Block selection (pause mode only) - click handler
            State.app.canvas.addEventListener('click', (e) => {
                if (!State.isPaused) return;

                const rect = State.app.canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                // Convert screen coords to world coords
                const { zoom, width, height, x: vpX, y: vpY } = State.viewport;
                const halfWidth = width / 2;
                const halfHeight = height / 2;
                const worldX = (clickX - halfWidth) / zoom + vpX;
                const worldY = (clickY - halfHeight) / zoom + vpY;

                // Hit test: find nearest block within radius
                const hitRadius = CONFIG.BLOCK_SIZE_VIRTUAL / zoom;
                let foundIdx = null;
                let minDist = hitRadius;

                const { x, y, hashes } = State.blockData;
                for (let i = 0; i < State.blockCount; i++) {
                    if (!hashes[i]) continue;
                    const dx = x[i] - worldX;
                    const dy = y[i] - worldY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        foundIdx = i;
                    }
                }

                State.selectedBlockIndex = foundIdx;
                updateBlockInfo();
            });
        }

        // ------------------------------------------------------------
        // Tutorial System
        // ------------------------------------------------------------
        const Tutorial = {
            currentStep: 0,
            isOpen: false,
            wasPlaying: false,  // Track if we were playing before tutorial

            steps: [
                // Step 1: Hook
                {
                    title: '10 blocks per second.',
                    content: '<p>This blockchain creates blocks <strong>6000x faster</strong> than Bitcoin.</p><p>You\'re watching it live.</p>',
                    highlight: null,
                },
                // Step 2: Problem
                {
                    title: 'But there\'s a problem.',
                    content: '<p>When blocks are created this fast, multiple blocks are born at the same time.</p><p>They don\'t know about each other. If we sort them by parent-child...</p>',
                    highlight: null,
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'linear') {
                            DOM.btnViewLinear.click();
                        }
                    }
                },
                // Step 3: Show DAG
                {
                    title: 'Look. They\'re parallel.',
                    content: '<p>See the parallel structure?</p><p>Which is the correct <strong>order</strong>?</p>',
                    highlight: null,
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'dag') {
                            DOM.btnViewDag.click();
                        }
                    }
                },
                // Step 4: Answer
                {
                    title: 'The answer: first, include everything.',
                    content: '<p>Don\'t throw away any blocks.</p><p>Decide the <strong>order</strong> later.</p>',
                    highlight: null,
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'dag') DOM.btnViewDag.click();
                    }
                },
                // Step 5: Block inclusion
                {
                    title: 'Block inclusion states',
                    content: '<p><span class="highlight-gray">⬜ Gray</span> = just arrived, pending.</p><p><span class="highlight-blue">🟦 Blue</span> = accepted into the chain.</p><p><span class="highlight-red">🟥 Red</span> = rejected (doesn\'t meet specs).</p><p>At this stage, blocks are included but <strong>not yet ordered</strong>.</p>',
                    highlight: 'legend',
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'dag') DOM.btnViewDag.click();
                    }
                },
                // Step 6: Start ordering
                {
                    title: 'Let\'s start ordering.',
                    content: '<p>First, find what\'s trustworthy.</p><p>Follow the "heaviest" route — most work. This is the <span class="highlight-green">🟩 Selected Chain</span>.</p><p>Blocks on it are shown <strong>larger</strong>.</p>',
                    highlight: 'legend',
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'dag') DOM.btnViewDag.click();
                    }
                },
                // Step 7: Gold = all paths agree
                {
                    title: 'Where all paths agree.',
                    content: '<p>The <span class="highlight-gold">🟨 gold block</span> is where all green paths converge.</p><p>Selected chains before this point have <strong>no conflicts</strong> — they\'re trustworthy.</p>',
                    highlight: 'legend',
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'dag') DOM.btnViewDag.click();
                    }
                },
                // Step 8: Linearization
                {
                    title: 'Making it a single line.',
                    content: '<p><span class="highlight-green">🟩 Green zone</span>: the most trusted path is <strong>temporarily</strong> chosen as backbone.</p><p><span class="highlight-blue">🟦 Blue zone</span>: it\'s <strong>permanent</strong>.</p><p>Large blocks place smaller parent blocks to their left, filling gaps in order of trust.</p>',
                    highlight: null,
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'dag') DOM.btnViewDag.click();
                    }
                },
                // Step 9: Result
                {
                    title: 'See them line up.',
                    content: '<p>Switch to <span class="highlight">Linear</span> view.</p><p>All those parallel blocks → one ordered sequence.</p>',
                    highlight: 'view-mode-controls',
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'linear') DOM.btnViewLinear.click();
                    }
                },
                // Step 10: Conclusion
                {
                    title: 'This is DAGknight.',
                    content: '<p>Fast <strong>and</strong> secure.</p><p>No central authority.</p>',
                    highlight: null,
                    final: true,
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'linear') DOM.btnViewLinear.click();
                    }
                }
            ],

            open() {
                this.currentStep = 0;
                this.isOpen = true;
                this.wasPlaying = !State.isPaused;
                DOM.tutorialOverlay.classList.add('visible');
                DOM.tutorialModal.classList.add('visible');
                State.tutorialStep = 0;
                this.render();
            },

            close() {
                this.isOpen = false;
                State.tutorialStep = -1;
                DOM.tutorialOverlay.classList.remove('visible');
                DOM.tutorialModal.classList.remove('visible');
                this.clearHighlight();
                // Resume if we were playing before
                if (this.wasPlaying && State.isPaused) {
                    DOM.btnPause.click();
                }
            },

            next() {
                if (this.currentStep < this.steps.length - 1) {
                    this.currentStep++;
                    this.render();
                } else {
                    this.close();
                }
            },

            back() {
                if (this.currentStep === 0) {
                    this.close();
                } else {
                    this.currentStep--;
                    this.render();
                }
            },

            render() {
                const step = this.steps[this.currentStep];
                State.tutorialStep = this.currentStep;

                // Update step indicators
                document.querySelectorAll('#tutorial-modal .step-dot').forEach((dot, i) => {
                    dot.classList.remove('active', 'completed');
                    if (i < this.currentStep) dot.classList.add('completed');
                    if (i === this.currentStep) dot.classList.add('active');
                });

                // Update content
                DOM.tutorialContent.innerHTML = `
                    <h2>${step.title}</h2>
                    ${step.content}
                `;

                // Update buttons
                if (this.currentStep === 0) {
                    DOM.tutorialBack.textContent = 'Close';
                } else {
                    DOM.tutorialBack.textContent = '← Back';
                }

                if (step.final) {
                    DOM.tutorialNext.textContent = 'Close';
                    DOM.tutorialNext.className = 'btn btn-primary';
                } else {
                    DOM.tutorialNext.textContent = 'Next →';
                    DOM.tutorialNext.className = 'btn btn-primary';
                }

                // Execute step action
                if (step.action) {
                    step.action();
                }

                // Apply highlight (supports array)
                this.clearHighlight();
                if (step.highlight) {
                    const highlights = Array.isArray(step.highlight) ? step.highlight : [step.highlight];
                    for (const id of highlights) {
                        const el = document.getElementById(id);
                        if (el) {
                            el.classList.add('tutorial-spotlight');
                        }
                    }
                }
            },

            clearHighlight() {
                document.querySelectorAll('.tutorial-spotlight').forEach(el => {
                    el.classList.remove('tutorial-spotlight');
                });
            }
        };

        // Tutorial event listeners
        DOM.tutorialBtn.addEventListener('click', () => {
            DOM.tutorialBtn.classList.add('clicked');
            Tutorial.open();
        });
        DOM.tutorialOverlay.addEventListener('click', () => Tutorial.close());
        DOM.tutorialBack.addEventListener('click', () => Tutorial.back());
        DOM.tutorialNext.addEventListener('click', () => Tutorial.next());

        // Close on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && Tutorial.isOpen) {
                Tutorial.close();
            }
        });

        // ------------------------------------------------------------
        // Main
        // ------------------------------------------------------------
        async function main() {
            try {
                await initPixi();
                setupControls();
                await initKaspaSDK();
                hideLoading();
            } catch (error) {
                console.error('Initialization failed:', error);
                updateLoadingText('Error: ' + error.message);
            }
        }

        // Start
        main();
    </script>
</body>
</html>
