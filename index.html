<!DOCTYPE html>
<html lang="en" style="background:#0A0E17">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no">
    <title>Kaspa Dagknight Protocol Visualizer</title>
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        html, body {
            width: 100%;
            height: 100%;
            overflow: hidden;
            background: #0A0E17;
            font-family: 'Segoe UI', system-ui, sans-serif;
            color: #E0E0E0;
        }

        #app {
            width: 100%;
            height: 100%;
            position: relative;
        }

        #canvas-container {
            width: 100%;
            height: 100%;
            position: absolute;
            top: 0;
            left: 0;
            touch-action: none;  /* Disable browser touch handling */
        }

        /* Status overlay */
        #status {
            position: absolute;
            top: 76px;
            left: 16px;
            z-index: 100;
            background: rgba(10, 14, 23, 0.85);
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 13px;
            backdrop-filter: blur(8px);
            min-width: 200px;
        }

        #status .title {
            font-size: 16px;
            font-weight: 600;
            color: #FFFFFF;
            margin-bottom: 8px;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        #status .title::before {
            content: '';
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: #666;
            animation: pulse 2s infinite;
        }

        #status.connected .title::before {
            background: #00FF88;
        }

        #status .row {
            display: flex;
            justify-content: space-between;
            padding: 4px 0;
            border-bottom: 1px solid rgba(255, 255, 255, 0.05);
        }

        #status .row:last-child {
            border-bottom: none;
        }

        #status .label {
            color: #888;
        }

        #status .value {
            color: #FFF;
            font-family: 'Consolas', monospace;
        }

        /* Stats overlay (Debug State) */
        #stats {
            position: absolute;
            top: 76px;
            right: 16px;
            z-index: 100;
            background: rgba(10, 14, 23, 0.85);
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 12px;
            backdrop-filter: blur(8px);
            font-family: 'Consolas', monospace;
            text-align: right;
        }

        /* Hide old stats elements - now shown in debug-info */
        #stats .fps,
        #stats #draw-calls,
        #stats #memory-usage {
            display: none;
        }

        /* Legend (Block Types) */
        #legend {
            position: absolute;
            bottom: 16px;
            left: 16px;
            z-index: 100;
            background: rgba(10, 14, 23, 0.85);
            border: none;
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 12px;
            backdrop-filter: blur(8px);
            display: flex;
            gap: 16px;
        }

        #legend .item {
            display: flex;
            align-items: center;
            gap: 6px;
        }

        #legend .color {
            width: 12px;
            height: 12px;
            border-radius: 2px;
        }

        .color-pending { background: #888888; }
        .color-blue { background: #4A90D9; }
        .color-red { background: #E74C3C; }
        .color-vspc { background: #00FF88; box-shadow: 0 0 8px #00FF88; }
        .color-lcca { background: #FFD700; box-shadow: 0 0 8px #FFD700; }

        /* Block Info Panel (shown during pause) */
        #block-info {
            position: absolute;
            bottom: 70px;
            left: 16px;
            z-index: 100;
            background: rgba(10, 14, 23, 0.9);
            border: 1px solid rgba(74, 144, 217, 0.5);
            border-radius: 8px;
            padding: 12px 16px;
            font-size: 11px;
            backdrop-filter: blur(8px);
            display: none;
            min-width: 200px;
            max-width: calc(100vw - 32px);
        }
        #block-info.visible { display: block; }
        #block-info .title {
            font-weight: bold;
            color: #4A90D9;
            margin-bottom: 8px;
            font-size: 12px;
        }
        #block-info .row {
            display: flex;
            justify-content: space-between;
            margin-bottom: 4px;
            gap: 12px;
        }
        #block-info .label { color: #888; }
        #block-info .value {
            color: #fff;
            font-family: monospace;
            word-break: break-all;
        }
        #block-info .hint {
            color: #666;
            font-size: 10px;
            margin-top: 8px;
            text-align: center;
        }
        #block-info.clickable {
            cursor: pointer;
            border-color: rgba(74, 144, 217, 0.8);
        }
        #block-info.clickable:hover {
            background: rgba(20, 30, 50, 0.95);
        }
        #block-info.clickable .hint {
            color: #4A90D9;
        }

        /* Header */
        #header {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            text-align: center;
            padding: 12px 20px;
            background: rgba(10, 14, 23, 0.9);
            border-bottom: 1px solid rgba(255, 255, 255, 0.15);
            z-index: 100;
            backdrop-filter: blur(8px);
        }

        #header h1 {
            font-size: 20px;
            font-weight: 600;
            color: #FFFFFF;
            margin-bottom: 4px;
        }

        #header .subtitle {
            color: #FFFFFF;
            font-size: 12px;
        }

        #header .logo {
            position: absolute;
            right: 16px;
            top: 50%;
            transform: translateY(-50%);
            width: 40px;
            height: 40px;
        }

        /* Controls */
        #controls {
            position: absolute;
            bottom: 16px;
            right: 16px;
            z-index: 100;
            display: flex;
            gap: 8px;
        }

        #controls button {
            background: rgba(74, 144, 217, 0.2);
            border: 1px solid rgba(74, 144, 217, 0.5);
            color: #4A90D9;
            padding: 8px 16px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
        }

        #controls button:hover {
            background: rgba(74, 144, 217, 0.4);
            border-color: #4A90D9;
        }

        #controls button:active {
            transform: scale(0.98);
        }

        /* Dummy simulation controls */
        #dummy-controls {
            position: absolute;
            bottom: 60px;
            right: 16px;
            z-index: 100;
            display: flex;
            gap: 8px;
            align-items: center;
            background: rgba(10, 14, 23, 0.85);
            border: 1px solid rgba(74, 144, 217, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            backdrop-filter: blur(8px);
        }

        #dummy-controls .label {
            font-size: 12px;
            color: #888;
            margin-right: 4px;
        }

        #dummy-controls button {
            background: rgba(74, 144, 217, 0.2);
            border: 1px solid rgba(74, 144, 217, 0.5);
            color: #4A90D9;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        #dummy-controls button:hover {
            background: rgba(74, 144, 217, 0.4);
        }

        #dummy-controls button.active {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00FF88;
            color: #00FF88;
        }

        #dummy-controls button.multiplier.selected {
            background: rgba(255, 215, 0, 0.3);
            border-color: #FFD700;
            color: #FFD700;
        }

        #dummy-controls button.disabled {
            background: rgba(100, 100, 100, 0.2);
            border-color: #555;
            color: #666;
            cursor: not-allowed;
        }

        #dummy-controls button.disabled:hover {
            background: rgba(100, 100, 100, 0.2);
            border-color: #555;
        }

        /* View mode controls */
        #view-mode-controls {
            position: absolute;
            bottom: 104px;
            right: 16px;
            z-index: 100;
            display: flex;
            gap: 8px;
            align-items: center;
            background: rgba(10, 14, 23, 0.85);
            border: 1px solid rgba(74, 144, 217, 0.3);
            border-radius: 8px;
            padding: 8px 12px;
            backdrop-filter: blur(8px);
        }

        #view-mode-controls .label {
            font-size: 12px;
            color: #888;
            margin-right: 4px;
        }

        #view-mode-controls button {
            background: rgba(74, 144, 217, 0.2);
            border: 1px solid rgba(74, 144, 217, 0.5);
            color: #4A90D9;
            padding: 4px 10px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
        }

        #view-mode-controls button:hover {
            background: rgba(74, 144, 217, 0.4);
        }

        #view-mode-controls button.selected {
            background: rgba(0, 255, 136, 0.3);
            border-color: #00FF88;
            color: #00FF88;
        }

        /* Loading overlay */
        #loading {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: #0A0E17;
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 1000;
            transition: opacity 0.5s;
        }

        #loading.hidden {
            opacity: 0;
            pointer-events: none;
        }

        #loading .spinner {
            width: 48px;
            height: 48px;
            border: 3px solid rgba(74, 144, 217, 0.2);
            border-top-color: #4A90D9;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        #loading .text {
            margin-top: 16px;
            color: #4A90D9;
            font-size: 14px;
        }

        @keyframes spin {
            to { transform: rotate(360deg); }
        }

        @keyframes pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }

        /* Hide panels when viewport is too small */
        @media (max-height: 500px) {
            #status, #stats {
                display: none;
            }
        }

        @media (max-width: 600px) {
            #status, #stats {
                display: none;
            }
            #header h1 {
                font-size: 16px;
            }
            #header .subtitle {
                font-size: 10px;
            }
            #header .logo {
                width: 30px;
                height: 30px;
            }
        }

        /* Tutorial */
        @keyframes gentle-pulse {
            0%, 100% { opacity: 1; }
            50% { opacity: 0.5; }
        }
        #tutorial-btn {
            position: absolute;
            bottom: 150px;
            right: 16px;
            z-index: 100;
            background: rgba(74, 144, 217, 0.2);
            border: 1px solid rgba(74, 144, 217, 0.5);
            color: #4A90D9;
            padding: 6px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            transition: all 0.2s;
            display: flex;
            align-items: center;
            gap: 6px;
            animation: gentle-pulse 3s ease-in-out infinite;
        }
        #tutorial-btn:hover {
            background: rgba(74, 144, 217, 0.4);
            border-color: #4A90D9;
        }
        #tutorial-btn.clicked {
            animation: none;
        }
        #tutorial-btn .icon {
            font-size: 16px;
            font-weight: bold;
        }

        /* Tutorial Overlay - disabled */
        #tutorial-overlay {
            display: none !important;
        }

        /* Tutorial Modal */
        #tutorial-modal {
            position: fixed;
            bottom: 140px;
            left: 50%;
            transform: translateX(-50%);
            z-index: 501;
            background: rgba(10, 14, 23, 0.95);
            border: 1px solid rgba(74, 144, 217, 0.5);
            border-radius: 12px;
            padding: 24px 32px;
            width: 600px;
            max-width: calc(100% - 32px);
            min-height: 260px;
            max-height: 320px;
            backdrop-filter: blur(12px);
            display: none;
            opacity: 0;
            transition: opacity 0.3s;
        }
        #tutorial-modal.visible {
            display: block;
            opacity: 1;
        }
        #tutorial-modal .step-indicator {
            display: flex;
            justify-content: center;
            gap: 8px;
            margin-bottom: 20px;
        }
        #tutorial-modal .step-dot {
            width: 8px;
            height: 8px;
            border-radius: 50%;
            background: rgba(74, 144, 217, 0.3);
            transition: all 0.3s;
        }
        #tutorial-modal .step-dot.active {
            background: #4A90D9;
            box-shadow: 0 0 8px #4A90D9;
        }
        #tutorial-modal .step-dot.completed {
            background: #00FF88;
        }
        #tutorial-modal .content {
            text-align: center;
            min-height: 100px;
            max-height: 140px;
            overflow-y: auto;
        }
        #tutorial-modal .content h2 {
            font-size: 18px;
            font-weight: 600;
            color: #fff;
            margin-bottom: 16px;
            line-height: 1.4;
        }
        #tutorial-modal .content p {
            font-size: 14px;
            color: #aaa;
            line-height: 1.4;
            margin-bottom: 6px;
        }
        #tutorial-modal .content .highlight {
            color: #4A90D9;
            font-weight: 500;
        }
        #tutorial-modal .content .highlight-gold {
            color: #FFD700;
            font-weight: 500;
        }
        #tutorial-modal .content .highlight-green {
            color: #00FF88;
            font-weight: 500;
        }
        #tutorial-modal .content .highlight-gray {
            color: #888888;
            font-weight: 500;
        }
        #tutorial-modal .content .highlight-blue {
            color: #4A90D9;
            font-weight: 500;
        }
        #tutorial-modal .content .highlight-red {
            color: #E74C3C;
            font-weight: 500;
        }
        #tutorial-modal .content .big-number {
            font-size: 32px;
            font-weight: bold;
            color: #00FF88;
            display: block;
            margin: 12px 0;
        }
        #tutorial-modal .buttons {
            display: flex;
            justify-content: space-between;
            margin-top: 24px;
            gap: 12px;
        }
        #tutorial-modal .btn {
            padding: 10px 20px;
            border-radius: 6px;
            cursor: pointer;
            font-size: 13px;
            transition: all 0.2s;
            border: none;
        }
        #tutorial-modal .btn-secondary {
            background: rgba(255, 255, 255, 0.1);
            color: #888;
        }
        #tutorial-modal .btn-secondary:hover {
            background: rgba(255, 255, 255, 0.2);
            color: #fff;
        }
        #tutorial-modal .btn-primary {
            background: rgba(74, 144, 217, 0.3);
            border: 1px solid #4A90D9;
            color: #4A90D9;
        }
        #tutorial-modal .btn-primary:hover {
            background: rgba(74, 144, 217, 0.5);
        }
        #tutorial-modal .btn-share {
            background: rgba(0, 255, 136, 0.2);
            border: 1px solid #00FF88;
            color: #00FF88;
        }
        #tutorial-modal .btn-share:hover {
            background: rgba(0, 255, 136, 0.3);
        }
        #tutorial-modal .btn:disabled {
            opacity: 0.3;
            cursor: not-allowed;
        }

        /* Spotlight highlight for tutorial */
        .tutorial-spotlight {
            box-shadow: 0 0 0 4px rgba(74, 144, 217, 0.8), 0 0 20px rgba(74, 144, 217, 0.5);
            border-radius: 8px;
            z-index: 502 !important;
        }

        /* Responsive: Portrait / Narrow screens */
        @media (max-width: 600px) {
            /* Top: Keep Network State visible, hide Debug State */
            #status {
                display: block !important;
            }
            #stats {
                display: none !important;
            }

            /* Bottom: Hide Legend (Block Type) to avoid collision with controls */
            #legend {
                display: none !important;
            }

            /* Adjust tutorial button position for narrow screens */
            #tutorial-btn {
                bottom: 160px;
                right: 8px;
            }

            /* Compact controls */
            #controls {
                right: 8px;
                gap: 4px;
            }
            #controls button {
                padding: 6px 10px;
                font-size: 11px;
            }

            #dummy-controls, #view-mode-controls {
                right: 8px;
                padding: 6px 8px;
            }
        }

        /* Very narrow screens (< 400px) */
        @media (max-width: 400px) {
            #status {
                left: 8px;
                min-width: 150px;
                font-size: 11px;
                padding: 8px 12px;
            }
            #status .title {
                font-size: 13px;
            }
        }

        /* Landscape mode: hide header to maximize visualization area */
        @media (orientation: landscape) and (max-height: 500px) {
            #header {
                display: none !important;
            }
            /* Adjust status position since header is hidden */
            #status {
                top: 16px;
            }
            #stats {
                top: 16px;
            }
        }
    </style>
</head>
<body>
    <div id="app">
        <div id="canvas-container"></div>

        <div id="header">
            <h1>Kaspa Dagknight Protocol Visualizer</h1>
            <p class="subtitle">A Parameterless Generalization of Nakamoto Consensus</p>
            <svg class="logo" xmlns="http://www.w3.org/2000/svg" viewBox="0 0 197.05 196.86">
                <defs><style>.logo-white{fill:#fff;}.logo-teal{fill:#6fc7ba;}</style></defs>
                <circle class="logo-white" cx="98.52" cy="98.43" r="41.03"></circle>
                <path class="logo-teal" d="m149.42,76.34c-2.8-6.76-7.22-13.03-12.32-18.12-5.08-5.1-11.61-8.91-18.38-11.71-6.51-2.71-13.78-4.07-21.28-4.07s-15.21.27-21.72,2.98c-6.76,2.8-12.42,8.12-17.51,13.22-5.1,5.1-11.02,10.51-13.82,17.26-2.71,6.53-1.83,14.48-1.83,21.99s.55,14.85,3.26,21.38c2.8,6.76,8.52,11.54,13.6,16.64,5.1,5.1,9.71,11.18,16.47,13.98,6.53,2.71,14.04,4.55,21.54,4.55s14.87-2.22,21.4-4.94c6.75-2.8,12.86-7.18,17.96-12.27,5.1-5.1,9.19-11.32,12.01-18.08,2.7-6.51,5.79-13.76,5.79-21.26s-2.48-15-5.19-21.53Zm-36.26,53.49l-11.88-1.75,3.39-23-24.87,19.16-7.32-9.56,21.82-16.8-21.82-16.81,7.32-9.56,24.87,19.16-3.39-22.99,11.88-1.77,4.73,31.98-4.73,31.96Z"></path>
            </svg>
        </div>

        <div id="status">
            <div class="title">Network State</div>
            <div class="row">
                <span class="label">Status</span>
                <span class="value" id="connection-status">Disconnected</span>
            </div>
            <div class="row">
                <span class="label">Network</span>
                <span class="value" id="network-name">-</span>
            </div>
            <div class="row">
                <span class="label">DAA Score</span>
                <span class="value" id="daa-score">-</span>
            </div>
            <div class="row">
                <span class="label">Blocks</span>
                <span class="value" id="block-count">0</span>
            </div>
        </div>

        <div id="stats">
            <div class="fps" id="fps-display">-- FPS</div>
            <div id="draw-calls">Draw calls: -</div>
            <div id="memory-usage">Memory: -</div>
            <div id="debug-info" style="font-size: 10px; color: #888; margin-top: 8px;"></div>
        </div>

        <div id="block-info">
            <div class="title">Block Info</div>
            <div class="row"><span class="label">Hash</span><span class="value" id="info-hash">-</span></div>
            <div class="row"><span class="label">DAA Score</span><span class="value" id="info-daa">-</span></div>
            <div class="row"><span class="label">Blue Score</span><span class="value" id="info-blue-score">-</span></div>
            <div class="row"><span class="label">Blue Work</span><span class="value" id="info-blue-work">-</span></div>
            <div class="hint" id="info-hint">Tap a block to inspect</div>
        </div>

        <div id="legend">
            <div class="item"><div class="color color-pending"></div> Pending</div>
            <div class="item"><div class="color color-blue"></div> Blue Block</div>
            <div class="item"><div class="color color-red"></div> Red Block</div>
            <div class="item"><div class="color color-vspc"></div> Selected Chain</div>
            <div class="item"><div class="color color-lcca"></div> LCCA</div>
        </div>

        <!-- Tutorial Button -->
        <button id="tutorial-btn">
            <span class="icon">?</span>
            <span>What's this?</span>
        </button>

        <!-- Tutorial Overlay -->
        <div id="tutorial-overlay"></div>

        <!-- Tutorial Modal -->
        <div id="tutorial-modal">
            <div class="step-indicator">
                <div class="step-dot" data-step="1"></div>
                <div class="step-dot" data-step="2"></div>
                <div class="step-dot" data-step="3"></div>
                <div class="step-dot" data-step="4"></div>
                <div class="step-dot" data-step="5"></div>
                <div class="step-dot" data-step="6"></div>
                <div class="step-dot" data-step="7"></div>
                <div class="step-dot" data-step="8"></div>
                <div class="step-dot" data-step="9"></div>
                <div class="step-dot" data-step="10"></div>
                <div class="step-dot" data-step="11"></div>
                <div class="step-dot" data-step="12"></div>
            </div>
            <div class="content" id="tutorial-content">
                <!-- Content injected by JS -->
            </div>
            <div class="buttons">
                <button class="btn btn-secondary" id="tutorial-back">← Back</button>
                <button class="btn btn-primary" id="tutorial-next">Next →</button>
            </div>
        </div>

        <div id="dummy-controls">
            <span class="label">BPS Simulator</span>
            <button id="btn-dummy-toggle">OFF</button>
            <button id="btn-dummy-30bps" class="multiplier selected">30BPS</button>
            <button id="btn-dummy-100bps" class="multiplier disabled">100BPS</button>
        </div>

        <div id="view-mode-controls">
            <span class="label">View</span>
            <button id="btn-view-linear" class="selected">Linear</button>
            <button id="btn-view-dag">DAG</button>
        </div>

        <div id="controls">
            <button id="btn-disconnect">Disconnect</button>
            <button id="btn-pause">Pause</button>
            <button id="btn-reset">Clear</button>
            <button id="btn-zoom-in">+</button>
            <button id="btn-zoom-out">-</button>
        </div>

        <div id="loading">
            <div class="spinner"></div>
            <div class="text">Initializing...</div>
        </div>
    </div>

    <!-- PixiJS v8 -->
    <script src="https://cdn.jsdelivr.net/npm/pixi.js@8.x/dist/pixi.min.js"></script>

    <!-- Kaspa WASM SDK -->
    <script type="module">
        // ============================================================
        // Dagknight Protocol Visualizer
        // Phase 1: Foundation
        // ============================================================

        // ------------------------------------------------------------
        // Constants
        // ------------------------------------------------------------
        const CONFIG = {
            // Version (for debugging screenshots)
            VERSION: 'v223',

            // Display
            MAX_BLOCKS: 500,
            MAX_EDGES: 500,
            BLOCK_SIZE: 8,
            BLOCK_SIZE_VIRTUAL: 12,
            LINEAR_PITCH: 10,  // X spacing between linearized blocks
            SPAWN_X: -20,  // X=0 is right edge, spawn slightly left
            RIGHT_MARGIN: 50,  // Margin from right edge of screen
            DAA_PITCH: 10,  // X spacing per DAA score in DAG mode (was 50)
            DAA_GROUP: 5,   // Group DAA scores within ±5 into same column
            DAA_COLUMN_WIDTH: 50,  // X width per column (group of DAA scores)
            Y_STEP: 20,     // Y spacing step in DAG mode
            VIEW_MODE: 'linear',  // 'linear' | 'dag'
            CLEANUP_THRESHOLD: -2000,  // Remove blocks with X below this (far left of screen)

            // Colors
            COLORS: {
                BACKGROUND: 0x0A0E17,
                PENDING_BLOCK: 0x888888,  // Gray - not yet confirmed
                BLUE_BLOCK: 0x4A90D9,
                BLUE_EDGE: 0x7AB8E8,      // Lighter blue for finalized chain edges
                RED_BLOCK: 0xE74C3C,
                SELECTED_CHAIN: 0x00FF88,
                LCCA: 0xFFD700,  // Gold/Yellow for LCCA
                WHITE: 0xFFFFFF,  // White for outlines
                EDGE: 0x334455,
                EDGE_SELECTED: 0xFFFFFF,
            },

            // Performance - Dagknight calculation interval (FPS adaptive)
            // 10BPS: 200ms start, 1000ms max
            // 30BPS: 500ms start, 1500ms max
            // If FPS < 50, increase by 100ms
            UPDATE_INTERVAL_10BPS: { base: 200, max: 1000 },
            UPDATE_INTERVAL_30BPS: { base: 500, max: 1500 },
            FPS_THRESHOLD: 50,  // Below this, increase interval
            TARGET_FPS: 60,

            // Network
            RPC_ENDPOINTS: [
                'wss://kaspa.aspectron.org/mainnet/wrpc/borsh',
                'wss://kaspa.matryx.io/mainnet/wrpc/borsh',
            ],

            // High BPS Simulation (Dummy Blocks)
            DUMMY: {
                ENABLED: false,        // Toggle dummy block generation
                MULTIPLIER: 2,         // +2=30BPS, +9=100BPS (base 10BPS)
                MAX_PARENT_SELECT: 2,  // Dummy removed from tips after this many selections
                MAX_DUMMY_PARENTS: 2,  // Max dummy tips to add as parents per block
            },

            // Edge display limit (DAG mode performance)
            MAX_EDGES_PER_BLOCK_NORMAL: 6,  // Max edges per block in normal mode (10BPS)
            MAX_EDGES_PER_BLOCK_DUMMY: 2,   // Max edges per block in dummy mode (30BPS)
        };

        // ------------------------------------------------------------
        // State
        // ------------------------------------------------------------
        const State = {
            app: null,
            graphics: null,  // Will be initialized in initPixi()
            rpcClient: null,
            isConnected: false,
            isPaused: false,
            pauseStartTime: null,      // When pause started (for 5-sec timeout)
            pauseBuffer: [],           // Blocks received during pause
            pauseExpired: false,       // True if paused > 5 seconds
            selectedBlockIndex: null,  // Selected block for info display (pause mode)
            tutorialStep: -1,  // Current tutorial step (-1 = not in tutorial)

            // Block data (TypedArrays for performance)
            blockData: {
                hashes: new Array(CONFIG.MAX_BLOCKS),
                parentHashes: new Array(CONFIG.MAX_BLOCKS),  // Store parent hashes for dynamic resolution
                x: new Float32Array(CONFIG.MAX_BLOCKS),
                y: new Float32Array(CONFIG.MAX_BLOCKS),
                targetX: new Float32Array(CONFIG.MAX_BLOCKS),  // For smooth X animation (linearization)
                targetY: new Float32Array(CONFIG.MAX_BLOCKS),  // For smooth Y animation
                linearIndex: new Int32Array(CONFIG.MAX_BLOCKS),  // -1 = not linearized yet
                color: new Uint32Array(CONFIG.MAX_BLOCKS),
                size: new Float32Array(CONFIG.MAX_BLOCKS),
                isBlue: new Uint8Array(CONFIG.MAX_BLOCKS),
                confirmationState: new Uint8Array(CONFIG.MAX_BLOCKS),  // 0=Pending, 1=Blue, 2=Red
                daaScore: new Float64Array(CONFIG.MAX_BLOCKS),
                blueScore: new Float64Array(CONFIG.MAX_BLOCKS),
                blueWork: new Array(CONFIG.MAX_BLOCKS),  // BigInt as string
                bits: new Uint32Array(CONFIG.MAX_BLOCKS),  // PoW difficulty bits
            },
            blockCount: 0,
            blockHashToIndex: new Map(),

            // High BPS Simulation (Dummy Blocks)
            dummyTips: new Map(),      // Map<dummyHash, selectCount> - tracks how many times selected as parent
            dummyBlockCount: 0,        // Total dummy blocks generated
            lastDummyLog: 0,           // Throttle debug logging

            // Ring buffer pointers
            ringHead: 0,
            ringTail: 0,

            // DAA score reference for relative X coordinates
            minDaaScore: null,
            maxDaaScore: null,
            dagColumnCount: new Map(),  // column -> block count (for Y positioning in DAG mode)

            // Viewport
            viewport: {
                x: 0,  // Center at origin
                y: 0,
                targetX: 0,  // Fixed camera (no scrolling needed)
                zoom: 1,
                width: 0,
                height: 0,
            },

            // Stats
            stats: {
                fps: 0,
                frameCount: 0,
                lastFpsUpdate: 0,
                drawCalls: 0,
                visibleBlocks: 0,
                edgeCount: 0,
            },

            // Adaptive Dagknight interval (FPS-based)
            adaptiveInterval: 200,  // Current interval, starts at base

            // Selected Chain (Selected Parent Chain)
            selectedChainEdges: [],    // [[fromHash, toHash], ...] - all edges, classified at render time
            selectedChainBlocks: new Set(),  // Blocks on selected chain (for large block rendering)
            orderedBlocks: new Set(),  // All topologically ordered blocks (chain + ancestors)
            linearOrder: [],  // Final linearized order [hash, hash, ...]
            lccaHash: null,  // Latest Common Chain Ancestor (convergence point)
            confirmedChainEdges: new Map(),  // Cache: hash -> [fromHash, toHash] for confirmed (blue) edges
            sortedIndices: [],  // Cached: block indices sorted by X (updated in Dagknight calc, not every frame)
            lastDagknightCalc: 0,

            // Selected Parent Cache (dkoder optimization)
            // Map<blockHash, selectedParentHash>
            selectedParentCache: new Map(),

            // Dagknight Engine (dkoder-compliant)
            dagknight: {
                // BlockColouring enum: 0=Pending, 1=Blue, 2=Red
                PENDING: 0,
                BLUE: 1,
                RED: 2,

                // ConflictZoneManager data
                conflictZone: {
                    root: null,        // conflict genesis (LCCA)
                    tips: [],          // current tip hashes
                    blocks: new Set(), // blocks in zone
                },

                // CascadeTree data (per-block)
                cascadeTree: {
                    pastBlues: new Map(),      // hash → count
                    pastReds: new Map(),       // hash → count
                    anticoneBlues: new Map(),  // hash → count
                    arlb: new Map(),           // anticone_reds_lower_bound
                    floor: new Map(),          // hash → floor value
                },

                // Per-block coloring data
                bluesAnticoneSizes: new Map(), // hash → Map<blueHash, size>
                mergesetBlues: new Map(),      // hash → Set<hash>
                mergesetReds: new Map(),       // hash → Set<hash>
                coloringK: new Map(),          // hash → k value used

                // Caches (dkoder optimization)
                ancestorCache: new Map(),      // "hashA:hashB" → boolean
                kColouringCache: new Map(),    // "parents_hash:k" → result

                // Interval-based reachability (dkoder: reachability_service)
                intervalMap: new Map(),        // hash → {start, end}
                intervalCounter: 0,            // Counter for interval assignment

                // Debug info for K calculation
                lastK: null,
                lastZoneBlockCount: 0,
                kDebug: {
                    blueWork: 0n,
                    redWork: 0n,
                    deficit: 0n,
                    vspcLength: 0,
                    vspcReds: 0,
                    tips: 0,
                    zone: 0,
                },

                // Parameters
                d: 10,  // deficit parameter for confirmation
            },
        };

        // ------------------------------------------------------------
        // DOM Elements
        // ------------------------------------------------------------
        const DOM = {
            container: document.getElementById('canvas-container'),
            loading: document.getElementById('loading'),
            loadingText: document.querySelector('#loading .text'),
            status: document.getElementById('status'),
            connectionStatus: document.getElementById('connection-status'),
            networkName: document.getElementById('network-name'),
            daaScore: document.getElementById('daa-score'),
            blockCount: document.getElementById('block-count'),
            fpsDisplay: document.getElementById('fps-display'),
            drawCalls: document.getElementById('draw-calls'),
            memoryUsage: document.getElementById('memory-usage'),
            btnDisconnect: document.getElementById('btn-disconnect'),
            btnPause: document.getElementById('btn-pause'),
            btnReset: document.getElementById('btn-reset'),
            btnZoomIn: document.getElementById('btn-zoom-in'),
            btnZoomOut: document.getElementById('btn-zoom-out'),
            debugInfo: document.getElementById('debug-info'),
            // Dummy controls
            btnDummyToggle: document.getElementById('btn-dummy-toggle'),
            btnDummy30bps: document.getElementById('btn-dummy-30bps'),
            btnDummy100bps: document.getElementById('btn-dummy-100bps'),
            // View mode controls
            btnViewLinear: document.getElementById('btn-view-linear'),
            btnViewDag: document.getElementById('btn-view-dag'),
            // Legend and controls (for collision detection)
            legend: document.getElementById('legend'),
            dummyControls: document.getElementById('dummy-controls'),
            // Block info panel
            blockInfo: document.getElementById('block-info'),
            infoHash: document.getElementById('info-hash'),
            infoDaa: document.getElementById('info-daa'),
            infoBlueScore: document.getElementById('info-blue-score'),
            infoBlueWork: document.getElementById('info-blue-work'),
            infoHint: document.getElementById('info-hint'),
            // Tutorial
            tutorialBtn: document.getElementById('tutorial-btn'),
            tutorialOverlay: document.getElementById('tutorial-overlay'),
            tutorialModal: document.getElementById('tutorial-modal'),
            tutorialContent: document.getElementById('tutorial-content'),
            tutorialBack: document.getElementById('tutorial-back'),
            tutorialNext: document.getElementById('tutorial-next'),
        };

        // ------------------------------------------------------------
        // PixiJS Initialization
        // ------------------------------------------------------------
        async function initPixi() {
            updateLoadingText('Initializing renderer...');

            State.app = new PIXI.Application();

            await State.app.init({
                background: CONFIG.COLORS.BACKGROUND,
                resizeTo: DOM.container,
                antialias: true,
                resolution: window.devicePixelRatio || 1,
                autoDensity: true,
                powerPreference: 'high-performance',
            });

            DOM.container.appendChild(State.app.canvas);

            // Create Graphics objects ONCE (reused every frame)
            State.graphics = {
                edges: new PIXI.Graphics(),
                chainEdges: new PIXI.Graphics(),  // Selected Chain edges (behind blocks)
                pendingBlocks: new PIXI.Graphics(),  // Pending blocks (gray, behind blue/red)
                blueBlocks: new PIXI.Graphics(),
                redBlocks: new PIXI.Graphics(),
                chainBlocks: new PIXI.Graphics(),  // Chain blocks (large, with white outline, on top)
                lcca: new PIXI.Graphics(),  // LCCA block (on top)
            };

            // Add to stage (layered: back to front)
            State.app.stage.addChild(State.graphics.edges);          // 1. Gray edges (back)
            State.app.stage.addChild(State.graphics.chainEdges);     // 2. Selected Chain edges
            State.app.stage.addChild(State.graphics.pendingBlocks);  // 3. Pending blocks (gray)
            State.app.stage.addChild(State.graphics.blueBlocks);     // 4. Blue blocks (non-chain)
            State.app.stage.addChild(State.graphics.redBlocks);      // 5. Red blocks
            State.app.stage.addChild(State.graphics.chainBlocks);    // 6. Chain blocks (large, front)
            State.app.stage.addChild(State.graphics.lcca);           // 7. LCCA (front)

            // Store viewport dimensions (use actual CSS pixels, not internal resolution)
            State.viewport.width = State.app.canvas.clientWidth;
            State.viewport.height = State.app.canvas.clientHeight;

            // Handle resize
            window.addEventListener('resize', onResize);

            // Start render loop
            State.app.ticker.add(onTick);
        }

        function onResize() {
            // Delay execution to ensure canvas size is actually updated
            requestAnimationFrame(() => {
                const newWidth = State.app.canvas.clientWidth;
                const newHeight = State.app.canvas.clientHeight;

                // Skip if no change
                if (State.viewport.width === newWidth && State.viewport.height === newHeight) return;

                // Update stored dimensions first
                State.viewport.width = newWidth;
                State.viewport.height = newHeight;

                const zoom = State.viewport.zoom;
                const newHalfWidth = newWidth / 2;

                // Both modes: viewport stays at 0 (X=0 at right edge)
                State.viewport.x = 0;
                State.viewport.targetX = 0;
            });
        }

        // ------------------------------------------------------------
        // Render Loop
        // ------------------------------------------------------------
        function onTick(ticker) {
            if (State.isPaused) {
                renderDAG();  // Keep rendering during pause (for mode switching)
                return;
            }

            // Update FPS counter
            State.stats.frameCount++;
            const now = performance.now();
            if (now - State.stats.lastFpsUpdate >= 1000) {
                State.stats.fps = State.stats.frameCount;
                State.stats.frameCount = 0;
                State.stats.lastFpsUpdate = now;

                // Adaptive interval: adjust based on FPS
                const intervalConfig = CONFIG.DUMMY.ENABLED
                    ? CONFIG.UPDATE_INTERVAL_30BPS
                    : CONFIG.UPDATE_INTERVAL_10BPS;

                if (State.stats.fps < CONFIG.FPS_THRESHOLD) {
                    // FPS low - increase interval (slower updates)
                    State.adaptiveInterval = Math.min(
                        State.adaptiveInterval + 100,
                        intervalConfig.max
                    );
                } else if (State.stats.fps >= CONFIG.FPS_THRESHOLD + 10 && State.adaptiveInterval > intervalConfig.base) {
                    // FPS recovered - decrease interval (faster updates)
                    State.adaptiveInterval = Math.max(
                        State.adaptiveInterval - 50,
                        intervalConfig.base
                    );
                }

                updateStatsDisplay();
            }

            // Run Dagknight calculation periodically (adaptive interval)
            if (now - State.lastDagknightCalc >= State.adaptiveInterval) {
                runDagknightCalculation();
                State.lastDagknightCalc = now;
            }

            // Render blocks and edges
            renderDAG();
        }

        // ------------------------------------------------------------
        // DAG Rendering (Optimized: reuse Graphics objects)
        // ------------------------------------------------------------
        function renderDAG() {
            const { edges, chainEdges, pendingBlocks, blueBlocks, redBlocks, chainBlocks, lcca } = State.graphics;

            // Smooth viewport scrolling (lerp interpolation)
            State.viewport.x += (State.viewport.targetX - State.viewport.x) * 0.1;

            // Smooth X and Y animation for all blocks (lerp to targets)
            const { x, y, targetX, targetY, linearIndex } = State.blockData;
            for (let i = 0; i < State.blockCount; i++) {
                // Y animation (all blocks)
                y[i] += (targetY[i] - y[i]) * 0.15;

                // X animation: DAG mode = all blocks, Linear mode = only linearized
                if (CONFIG.VIEW_MODE === 'dag' || linearIndex[i] >= 0) {
                    x[i] += (targetX[i] - x[i]) * 0.1;
                }
            }

            // Clear previous frame (reuse same objects)
            edges.clear();
            chainEdges.clear();
            pendingBlocks.clear();
            blueBlocks.clear();
            redBlocks.clear();
            chainBlocks.clear();
            lcca.clear();

            if (State.blockCount === 0) return;

            const { size, isBlue, confirmationState, parentHashes, hashes } = State.blockData;
            const { zoom, width, height } = State.viewport;
            const vpX = State.viewport.x;
            const vpY = State.viewport.y;
            // X=0 at right edge (minus margin), negative X goes left
            const screenAnchorX = width - CONFIG.RIGHT_MARGIN;
            const halfWidth = screenAnchorX;  // Alias for compatibility
            const halfHeight = height / 2;

            let visibleCount = 0;
            let edgeCount = 0;

            // Use cached sorted indices (updated in Dagknight calc, not every frame)
            const sortedIndices = State.sortedIndices;

            // First pass: draw edges (newest blocks first, up to MAX_EDGES)
            for (const i of sortedIndices) {
                if (edgeCount >= CONFIG.MAX_EDGES) break;

                const screenX = (x[i] - vpX) * zoom + halfWidth;
                const screenY = (y[i] - vpY) * zoom + halfHeight;

                // Skip if outside viewport (X=0 at right edge)
                const marginLeft = width * 1.5;  // 1.5x for left (Linear flows left)
                const marginRight = CONFIG.VIEW_MODE === 'dag' ? width * 0.5 : 100;  // DAG needs more right margin
                if (screenX < -marginLeft || screenX > width + marginRight ||
                    screenY < -100 || screenY > height + 100) {
                    continue;
                }

                // Draw edges to parents (skip if block has converged to Y≈0)
                // Edges fade out naturally as blocks reach Y=0, not when linearized
                if (Math.abs(y[i]) > 5) {  // Only draw edges if Y is not yet at 0
                    const parents = parentHashes[i] || [];
                    let edgesThisBlock = 0;
                    // Dynamic edges per block based on VISIBLE block count (from previous frame)
                    // 500 visible → 1 edge, 250 visible → 2 edges, 125 visible → 4 edges, etc.
                    const visibleBlocks = State.stats.visibleBlocks || State.blockCount || 1;
                    const dynamicMax = Math.max(1, Math.ceil(CONFIG.MAX_EDGES / Math.max(1, visibleBlocks)));
                    const maxPerBlock = CONFIG.DUMMY.ENABLED
                        ? Math.min(dynamicMax, CONFIG.MAX_EDGES_PER_BLOCK_DUMMY)
                        : Math.min(dynamicMax, CONFIG.MAX_EDGES_PER_BLOCK_NORMAL);
                    for (const parentHash of parents) {
                        if (edgeCount >= CONFIG.MAX_EDGES) break;
                        if (edgesThisBlock >= maxPerBlock) break;
                        const parentIdx = State.blockHashToIndex.get(parentHash);
                        if (parentIdx !== undefined) {
                            const parentScreenX = (x[parentIdx] - vpX) * zoom + halfWidth;
                            const parentScreenY = (y[parentIdx] - vpY) * zoom + halfHeight;

                            edges.moveTo(screenX, screenY);
                            edges.lineTo(parentScreenX, parentScreenY);
                            edgeCount++;
                            edgesThisBlock++;
                        }
                    }
                }
            }

            // Stroke all edges at once
            if (edgeCount > 0) {
                edges.stroke({ width: 2, color: CONFIG.COLORS.EDGE, alpha: 0.5 });
            }

            // Second pass: draw blocks (on top of edges)
            // Chain blocks are drawn larger (14px vs 8px)
            const chainBlockSize = 14 * zoom;
            const chainHalfSize = chainBlockSize / 2;

            for (let i = 0; i < State.blockCount; i++) {
                const hash = hashes[i];
                if (!hash) continue;

                const screenX = (x[i] - vpX) * zoom + halfWidth;
                const screenY = (y[i] - vpY) * zoom + halfHeight;

                // Skip if outside viewport (X=0 at right edge)
                const blockMarginLeft = width * 1.5;
                const blockMarginRight = CONFIG.VIEW_MODE === 'dag' ? width * 0.5 : 100;
                if (screenX < -blockMarginLeft || screenX > width + blockMarginRight ||
                    screenY < -50 || screenY > height + 50) {
                    continue;
                }

                // Check if this block is on the Selected Chain
                const isChainBlock = State.selectedChainBlocks && State.selectedChainBlocks.has(hash);
                const state = confirmationState[i];

                // dkoder: Tips (pending) stay gray even if on selected chain
                // Only confirmed blocks (with children) get blue/large styling
                if (state === 0) {
                    // Pending (gray) - tips or unconfirmed blocks
                    // Regular size even if on chain (not yet confirmed)
                    const blockSize = size[i] * zoom;
                    const halfSize = blockSize / 2;
                    pendingBlocks.rect(screenX - halfSize, screenY - halfSize, blockSize, blockSize);
                } else if (isChainBlock && state === 1) {
                    // Confirmed chain block - larger blue with white outline (top layer)
                    chainBlocks.rect(screenX - chainHalfSize, screenY - chainHalfSize, chainBlockSize, chainBlockSize)
                        .fill({ color: CONFIG.COLORS.BLUE_BLOCK })
                        .stroke({ width: 1, color: CONFIG.COLORS.WHITE });
                } else if (state === 1) {
                    // Blue (confirmed but not on chain) - with white outline
                    const blockSize = size[i] * zoom;
                    const halfSize = blockSize / 2;
                    blueBlocks.rect(screenX - halfSize, screenY - halfSize, blockSize, blockSize)
                        .fill({ color: CONFIG.COLORS.BLUE_BLOCK })
                        .stroke({ width: 1, color: CONFIG.COLORS.WHITE });
                } else {
                    // Red (confirmed but not selected) - with white outline
                    const blockSize = size[i] * zoom;
                    const halfSize = blockSize / 2;
                    redBlocks.rect(screenX - halfSize, screenY - halfSize, blockSize, blockSize)
                        .fill({ color: CONFIG.COLORS.RED_BLOCK })
                        .stroke({ width: 1, color: CONFIG.COLORS.WHITE });
                }

                visibleCount++;
            }

            // Draw Selected Chain edges
            // Tutorial Step 6,7 (index 5,6): draw on top with arrows
            // Normal: draw behind blocks
            const isTutorialChainStep = State.tutorialStep === 5 || State.tutorialStep === 6;

            if (!isTutorialChainStep && State.selectedChainEdges && State.selectedChainEdges.length > 0) {
                // Normal mode: draw behind blocks
                // Use DAA score instead of X position for active zone detection
                // (X position fails in DAG mode where same-column blocks have same X)
                const { daaScore } = State.blockData;
                let lccaDaa = -Infinity;
                if (State.lccaHash) {
                    const lccaIdx = State.blockHashToIndex.get(State.lccaHash);
                    if (lccaIdx !== undefined) {
                        lccaDaa = daaScore[lccaIdx];
                    }
                }

                let blueDrawn = false;
                let greenDrawn = false;

                // Draw blue edges from current selectedChainEdges
                for (const [fromHash, toHash] of State.selectedChainEdges) {
                    const idx1 = State.blockHashToIndex.get(fromHash);
                    const idx2 = State.blockHashToIndex.get(toHash);
                    if (idx1 !== undefined && idx2 !== undefined) {
                        const bothInActive = daaScore[idx1] >= lccaDaa && daaScore[idx2] >= lccaDaa;
                        if (!bothInActive) {
                            const screenX1 = (x[idx1] - vpX) * zoom + halfWidth;
                            const screenY1 = (y[idx1] - vpY) * zoom + halfHeight;
                            const screenX2 = (x[idx2] - vpX) * zoom + halfWidth;
                            const screenY2 = (y[idx2] - vpY) * zoom + halfHeight;
                            chainEdges.moveTo(screenX1, screenY1);
                            chainEdges.lineTo(screenX2, screenY2);
                            blueDrawn = true;
                        }
                    }
                }

                // Draw cached confirmed (blue) edges - persist until blocks disappear
                for (const [, [fromHash, toHash]] of State.confirmedChainEdges) {
                    const idx1 = State.blockHashToIndex.get(fromHash);
                    const idx2 = State.blockHashToIndex.get(toHash);
                    if (idx1 !== undefined && idx2 !== undefined) {
                        const screenX1 = (x[idx1] - vpX) * zoom + halfWidth;
                        const screenY1 = (y[idx1] - vpY) * zoom + halfHeight;
                        const screenX2 = (x[idx2] - vpX) * zoom + halfWidth;
                        const screenY2 = (y[idx2] - vpY) * zoom + halfHeight;
                        chainEdges.moveTo(screenX1, screenY1);
                        chainEdges.lineTo(screenX2, screenY2);
                        blueDrawn = true;
                    }
                }

                if (blueDrawn) {
                    chainEdges.stroke({ width: 3, color: CONFIG.COLORS.BLUE_EDGE, alpha: 0.9 });
                }

                for (const [fromHash, toHash] of State.selectedChainEdges) {
                    const idx1 = State.blockHashToIndex.get(fromHash);
                    const idx2 = State.blockHashToIndex.get(toHash);
                    if (idx1 !== undefined && idx2 !== undefined) {
                        const bothInActive = daaScore[idx1] >= lccaDaa && daaScore[idx2] >= lccaDaa;
                        if (bothInActive) {
                            const screenX1 = (x[idx1] - vpX) * zoom + halfWidth;
                            const screenY1 = (y[idx1] - vpY) * zoom + halfHeight;
                            const screenX2 = (x[idx2] - vpX) * zoom + halfWidth;
                            const screenY2 = (y[idx2] - vpY) * zoom + halfHeight;
                            chainEdges.moveTo(screenX1, screenY1);
                            chainEdges.lineTo(screenX2, screenY2);
                            greenDrawn = true;
                        }
                    }
                }
                if (greenDrawn) {
                    chainEdges.stroke({ width: 2, color: CONFIG.COLORS.SELECTED_CHAIN, alpha: 0.8 });
                }
            }

            // Fill pending blocks (no outline)
            // Blue, red, chain, LCCA are filled individually with stroke
            pendingBlocks.fill({ color: CONFIG.COLORS.PENDING_BLOCK });

            // Draw LCCA block LAST (on top of everything)
            if (State.lccaHash) {
                const lccaIdx = State.blockHashToIndex.get(State.lccaHash);
                if (lccaIdx !== undefined) {
                    const lccaScreenX = (x[lccaIdx] - vpX) * zoom + halfWidth;
                    const lccaScreenY = (y[lccaIdx] - vpY) * zoom + halfHeight;

                    // Only draw if visible
                    if (lccaScreenX >= -50 && lccaScreenX <= width + 50 &&
                        lccaScreenY >= -50 && lccaScreenY <= height + 50) {
                        const lccaSize = 18 * zoom;  // Larger than chain blocks (14px)
                        const lccaHalfSize = lccaSize / 2;
                        lcca.rect(lccaScreenX - lccaHalfSize, lccaScreenY - lccaHalfSize, lccaSize, lccaSize)
                            .fill({ color: CONFIG.COLORS.LCCA })  // Yellow/Gold
                            .stroke({ width: 1, color: CONFIG.COLORS.WHITE });
                    }
                }
            }

            // Draw selection highlight (pause mode only) - white block
            if (State.isPaused && State.selectedBlockIndex !== null) {
                const selIdx = State.selectedBlockIndex;
                if (hashes[selIdx]) {
                    const selScreenX = (x[selIdx] - vpX) * zoom + halfWidth;
                    const selScreenY = (y[selIdx] - vpY) * zoom + halfHeight;
                    const selSize = size[selIdx] * zoom;
                    const selHalfSize = selSize / 2;
                    // White filled block (overwrites original color)
                    lcca.rect(selScreenX - selHalfSize, selScreenY - selHalfSize, selSize, selSize)
                        .fill({ color: 0xFFFFFF });
                }
            }

            // Tutorial Step 6,7 (index 5,6): Draw Selected Chain on TOP with arrows (child → parent)
            // Blue for finalized (before LCCA), Green for active (LCCA to tips)
            if (isTutorialChainStep && State.selectedChainEdges && State.selectedChainEdges.length > 0) {
                const { daaScore } = State.blockData;
                const arrowSize = 10 * zoom;

                // Get LCCA's DAA score (not X position - X fails in DAG mode)
                let lccaDaa = -Infinity;
                if (State.lccaHash) {
                    const lccaIdx = State.blockHashToIndex.get(State.lccaHash);
                    if (lccaIdx !== undefined) {
                        lccaDaa = daaScore[lccaIdx];
                    }
                }

                // First pass: Blue edges (finalized - before LCCA)
                let blueDrawn = false;
                for (const [fromHash, toHash] of State.selectedChainEdges) {
                    const idx1 = State.blockHashToIndex.get(fromHash);
                    const idx2 = State.blockHashToIndex.get(toHash);
                    if (idx1 !== undefined && idx2 !== undefined) {
                        const bothInActive = daaScore[idx1] >= lccaDaa && daaScore[idx2] >= lccaDaa;
                        if (!bothInActive) {
                            const screenX1 = (x[idx1] - vpX) * zoom + halfWidth;
                            const screenY1 = (y[idx1] - vpY) * zoom + halfHeight;
                            const screenX2 = (x[idx2] - vpX) * zoom + halfWidth;
                            const screenY2 = (y[idx2] - vpY) * zoom + halfHeight;
                            if (screenX1 < -50 || screenX1 > width + 50 || screenX2 < -50 || screenX2 > width + 50) continue;

                            lcca.moveTo(screenX1, screenY1);
                            lcca.lineTo(screenX2, screenY2);
                            const angle = Math.atan2(screenY2 - screenY1, screenX2 - screenX1);
                            lcca.moveTo(screenX2, screenY2);
                            lcca.lineTo(screenX2 - arrowSize * Math.cos(angle - Math.PI / 6), screenY2 - arrowSize * Math.sin(angle - Math.PI / 6));
                            lcca.moveTo(screenX2, screenY2);
                            lcca.lineTo(screenX2 - arrowSize * Math.cos(angle + Math.PI / 6), screenY2 - arrowSize * Math.sin(angle + Math.PI / 6));
                            blueDrawn = true;
                        }
                    }
                }
                if (blueDrawn) {
                    lcca.stroke({ width: 3, color: CONFIG.COLORS.BLUE_EDGE, alpha: 1.0 });
                }

                // Second pass: Green edges (active - LCCA to tips)
                let greenDrawn = false;
                for (const [fromHash, toHash] of State.selectedChainEdges) {
                    const idx1 = State.blockHashToIndex.get(fromHash);
                    const idx2 = State.blockHashToIndex.get(toHash);
                    if (idx1 !== undefined && idx2 !== undefined) {
                        const bothInActive = daaScore[idx1] >= lccaDaa && daaScore[idx2] >= lccaDaa;
                        if (bothInActive) {
                            const screenX1 = (x[idx1] - vpX) * zoom + halfWidth;
                            const screenY1 = (y[idx1] - vpY) * zoom + halfHeight;
                            const screenX2 = (x[idx2] - vpX) * zoom + halfWidth;
                            const screenY2 = (y[idx2] - vpY) * zoom + halfHeight;
                            if (screenX1 < -50 || screenX1 > width + 50 || screenX2 < -50 || screenX2 > width + 50) continue;

                            lcca.moveTo(screenX1, screenY1);
                            lcca.lineTo(screenX2, screenY2);
                            const angle = Math.atan2(screenY2 - screenY1, screenX2 - screenX1);
                            lcca.moveTo(screenX2, screenY2);
                            lcca.lineTo(screenX2 - arrowSize * Math.cos(angle - Math.PI / 6), screenY2 - arrowSize * Math.sin(angle - Math.PI / 6));
                            lcca.moveTo(screenX2, screenY2);
                            lcca.lineTo(screenX2 - arrowSize * Math.cos(angle + Math.PI / 6), screenY2 - arrowSize * Math.sin(angle + Math.PI / 6));
                            greenDrawn = true;
                        }
                    }
                }
                if (greenDrawn) {
                    lcca.stroke({ width: 3, color: CONFIG.COLORS.SELECTED_CHAIN, alpha: 1.0 });
                }
            }

            // Update stats
            State.stats.drawCalls = 4; // edges + blue blocks + red blocks + chain
            State.stats.visibleBlocks = visibleCount;
            State.stats.edgeCount = edgeCount;
        }

        // ------------------------------------------------------------
        // High BPS Simulation (Dummy Block Generation)
        // ------------------------------------------------------------

        /**
         * Generate a unique dummy hash from original block hash
         * Format: 0dummy_{original}_{index}
         * - '0dummy' prefix ensures it's lexicographically smaller than real hashes
         * - This makes real blocks preferred in selected parent selection
         */
        function generateDummyHash(originalHash, index) {
            return `0dummy_${originalHash.substring(0, 16)}_${index}`;
        }

        /**
         * Check if a hash is a dummy block
         */
        function isDummyHash(hash) {
            return hash && hash.startsWith('0dummy_');
        }

        /**
         * Generate dummy blocks for high BPS simulation
         * Called after a real block is added
         */
        function generateDummyBlocks(originalBlock) {
            if (!CONFIG.DUMMY.ENABLED) return;
            // Note: Ring buffer handles overflow, no need for safety margin

            const originalHash = originalBlock.header.hash;
            const originalDaaScore = Number(originalBlock.header.daaScore);
            const originalBlueWork = originalBlock.header.blueWork || '0';
            const originalBits = Number(originalBlock.header.bits || 0);
            const parentsByLevel = originalBlock.header.parentsByLevel || [];
            const originalParents = parentsByLevel[0] || [];

            // Generate MULTIPLIER dummy blocks
            for (let i = 0; i < CONFIG.DUMMY.MULTIPLIER; i++) {
                const dummyHash = generateDummyHash(originalHash, i);

                // Skip if already exists
                if (State.blockHashToIndex.has(dummyHash)) continue;

                // Get next index
                const index = State.ringHead;
                const oldHash = State.blockData.hashes[index];
                if (oldHash) {
                    State.blockHashToIndex.delete(oldHash);
                    State.dummyTips.delete(oldHash);  // Remove from tips if it was there
                }

                // Store dummy block
                State.blockData.hashes[index] = dummyHash;
                State.blockHashToIndex.set(dummyHash, index);
                State.blockData.daaScore[index] = originalDaaScore;

                // Position based on view mode (same logic as addBlock)
                const yScale = CONFIG.DUMMY.MULTIPLIER <= 2 ? 1.5 : 2.0;
                if (CONFIG.VIEW_MODE === 'dag') {
                    // DAG mode: X based on column (DAA grouped), Y based on order in column
                    // Newest blocks near X=0 (right edge), older blocks have negative X
                    const column = Math.floor((originalDaaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                    const maxColumn = Math.floor((State.maxDaaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                    const reverseColumn = maxColumn - column;  // Preserve column grouping
                    const columnX = -reverseColumn * CONFIG.DAA_COLUMN_WIDTH;  // Newest=0, older=negative

                    // Get block index within column for Y positioning
                    const columnKey = column;
                    const blockIndexInColumn = State.dagColumnCount.get(columnKey) || 0;
                    State.dagColumnCount.set(columnKey, blockIndexInColumn + 1);

                    // Calculate Y: 0, +20, -20, +40, -40, ... (scaled for high BPS)
                    let blockY;
                    if (blockIndexInColumn === 0) {
                        blockY = 0;
                    } else {
                        const offset = Math.ceil(blockIndexInColumn / 2) * CONFIG.Y_STEP * yScale;
                        const direction = (blockIndexInColumn % 2 === 1) ? 1 : -1;
                        blockY = offset * direction;
                    }

                    // Spawn slightly right of target for left-sliding animation
                    State.blockData.x[index] = columnX + 30;
                    State.blockData.targetX[index] = columnX;
                    State.blockData.y[index] = blockY;
                    State.blockData.targetY[index] = blockY;
                } else {
                    // Linear mode: X at spawn area with slight offset
                    const tipOffset = 10 + Math.random() * 30;
                    State.blockData.x[index] = CONFIG.SPAWN_X + tipOffset;
                    State.blockData.targetX[index] = State.blockData.x[index];

                    // Y = spread vertically (scaled for high BPS)
                    const randomY = (Math.random() - 0.5) * 300 * yScale;
                    State.blockData.y[index] = randomY;
                    State.blockData.targetY[index] = randomY;
                }
                State.blockData.linearIndex[index] = -1;

                // BlueWork: subtract (i+1) to make each dummy unique and lower priority
                State.blockData.blueScore[index] = Number(originalBlock.header.blueScore || 0);
                // Parse hex blueWork, subtract to ensure unique values
                let dummyBlueWork = originalBlueWork;
                try {
                    const bwBigInt = BigInt('0x' + originalBlueWork);
                    const adjusted = bwBigInt - BigInt(i + 1);
                    dummyBlueWork = adjusted > 0n ? adjusted.toString(16) : '0';
                } catch (e) {
                    // Keep original if parsing fails
                }
                State.blockData.blueWork[index] = dummyBlueWork;
                State.blockData.bits[index] = originalBits;

                // Pending state (will be colored by Dagknight if it gets children)
                State.blockData.confirmationState[index] = 0;
                State.blockData.size[index] = CONFIG.BLOCK_SIZE;

                // Parents: same as original
                State.blockData.parentHashes[index] = [...originalParents];

                // Calculate Selected Parent (highest BlueWork) and add green edge
                // Note: Dummies are not part of Selected Chain, so no edges added

                // Update ring buffer
                State.ringHead = (State.ringHead + 1) % CONFIG.MAX_BLOCKS;
                if (State.blockCount < CONFIG.MAX_BLOCKS) {
                    State.blockCount++;
                }

                // Add to dummyTips (selectCount = 0)
                State.dummyTips.set(dummyHash, 0);
                State.dummyBlockCount++;
            }
        }

        // ------------------------------------------------------------
        // Dagknight Algorithm
        // ------------------------------------------------------------

        // ============================================================
        // Dagknight Engine (dkoder-compliant implementation)
        // ============================================================

        // --- Step 1: Base Functions ---

        // findSelectedParent: Find parent with highest blueWork (dkoder: find_selected_parent)
        // Skip dummy blocks - only select from real blocks
        function findSelectedParent(parentHashes) {
            if (!parentHashes || parentHashes.length === 0) return null;

            // Filter out dummies - selected chain should only contain real blocks
            const realParents = parentHashes.filter(h => !isDummyHash(h));
            if (realParents.length === 0) return null;
            if (realParents.length === 1) return realParents[0];

            let selectedParent = null;
            let maxBlueWork = -1n;  // BigInt for proper numeric comparison

            for (const parentHash of realParents) {
                const idx = State.blockHashToIndex.get(parentHash);
                if (idx === undefined) continue;

                const workStr = State.blockData.blueWork[idx] || '0';
                let blueWork;
                try {
                    blueWork = BigInt('0x' + workStr.replace(/^0x/, ''));
                } catch (e) {
                    blueWork = 0n;
                }

                // Higher blueWork wins, tiebreaker: higher hash
                if (blueWork > maxBlueWork || (blueWork === maxBlueWork && parentHash > (selectedParent || ''))) {
                    maxBlueWork = blueWork;
                    selectedParent = parentHash;
                }
            }

            return selectedParent;
        }

        // sortBlocks: Sort blocks by blueWork descending (dkoder: sort_blocks)
        function sortBlocks(blockHashes) {
            return [...blockHashes].sort((a, b) => {
                const idxA = State.blockHashToIndex.get(a);
                const idxB = State.blockHashToIndex.get(b);
                if (idxA === undefined) return 1;
                if (idxB === undefined) return -1;

                const workA = State.blockData.blueWork[idxA] || '0';
                const workB = State.blockData.blueWork[idxB] || '0';

                // Descending order (higher blueWork first)
                if (workB > workA) return 1;
                if (workA > workB) return -1;
                // Tie-breaker: hash
                return b > a ? 1 : -1;
            });
        }

        // blueAnticoneSize: Calculate blue anticone size from a worldview (dkoder: blue_anticone_size)
        function blueAnticoneSize(blockHash, worldviewHash, bluesAnticoneSizes) {
            if (!bluesAnticoneSizes) return 0;
            const sizes = bluesAnticoneSizes.get(worldviewHash);
            if (!sizes) return 0;
            return sizes.get(blockHash) || 0;
        }

        // --- Step 2: ConflictZoneManager Functions ---

        // commonChainAncestor: Find LCCA of multiple blocks (dkoder: common_chain_ancestor)
        // dkoder logic: Build chain from BEST tip (highest blueWork), find first block that is ancestor of ALL others
        function commonChainAncestor(hashes) {
            if (!hashes || hashes.length === 0) return null;
            if (hashes.length === 1) return hashes[0];

            // CRITICAL: Start from the BEST tip (highest blueWork)
            // dkoder's parents[0] is the selected parent = highest blueWork
            // This ensures LCCA is on the same chain as the visualization's selected chain
            let start = hashes[0];
            let bestWork = -1n;
            for (const hash of hashes) {
                const idx = State.blockHashToIndex.get(hash);
                if (idx === undefined) continue;
                const workStr = State.blockData.blueWork[idx] || '0';
                let work;
                try {
                    work = BigInt('0x' + workStr.replace(/^0x/, ''));
                } catch (e) {
                    work = 0n;
                }
                if (work > bestWork) {
                    bestWork = work;
                    start = hash;
                }
            }

            // Others to check = all hashes except start
            const othersToCheck = hashes.filter(h => h !== start);
            if (othersToCheck.length === 0) return start;

            // Build backward chain from start (dkoder: default_backward_chain_iterator)
            const chain = [start];
            let current = start;
            const visited = new Set([start]);

            for (let i = 0; i < 200; i++) {
                const idx = State.blockHashToIndex.get(current);
                if (idx === undefined) break;

                const parents = State.blockData.parentHashes[idx] || [];
                if (parents.length === 0) break;

                const sp = findSelectedParent(parents);
                if (!sp || visited.has(sp)) break;

                visited.add(sp);
                chain.push(sp);
                current = sp;
            }

            // Compute intervals for THIS exact block set (chain + othersToCheck + their chains)
            // This ensures intervals cover exactly what we're checking
            const blockSet = new Set(chain);
            for (const tip of othersToCheck) {
                let curr = tip;
                for (let depth = 0; depth < 100; depth++) {
                    if (!curr) break;
                    blockSet.add(curr);
                    const idx = State.blockHashToIndex.get(curr);
                    if (idx === undefined) break;
                    const parents = State.blockData.parentHashes[idx] || [];
                    if (parents.length === 0) break;
                    curr = findSelectedParent(parents);
                }
            }

            // Find oldest block as root and compute intervals
            let root = null;
            let minDaa = Infinity;
            for (const hash of blockSet) {
                const idx = State.blockHashToIndex.get(hash);
                if (idx !== undefined) {
                    const daa = State.blockData.daaScore[idx] || 0;
                    if (daa < minDaa) {
                        minDaa = daa;
                        root = hash;
                    }
                }
            }
            if (root) {
                computeIntervals(root, blockSet, true);
            }

            // dkoder: .skip(1) - skip start itself, check each block in chain
            // For each cb, check if it's chain ancestor of ALL othersToCheck
            for (let i = 1; i < chain.length; i++) {
                const cb = chain[i];

                // is_chain_ancestor_of_all: check if cb is ancestor of all others
                let isAncestorOfAll = true;
                for (const h of othersToCheck) {
                    if (!isAncestor(cb, h, 200)) {
                        isAncestorOfAll = false;
                        break;
                    }
                }

                if (isAncestorOfAll) {
                    return cb;
                }
            }

            return null;
        }

        // calcWork: Calculate PoW work from difficulty bits (dkoder: calc_work)
        // work = (~target / (target + 1)) + 1 ≈ 2^256 / (target + 1)
        // Same scale as Kaspa's blueWork (2^256 based)
        const TWO_256 = 1n << 256n;  // 2^256

        function calcWork(bits) {
            if (!bits || bits === 0) return 1n;  // Fallback to 1 if no bits

            // Decode compact target bits (Bitcoin-style)
            // bits = 0x1e7fffff → exponent=0x1e, mantissa=0x7fffff
            const exponent = bits >> 24;
            const mantissa = bits & 0x007fffff;

            if (exponent === 0 || mantissa === 0) return 1n;

            // target = mantissa × 2^(8 × (exponent - 3))
            const shift = 8 * (exponent - 3);

            // Calculate target as BigInt
            let target;
            if (shift >= 0) {
                target = BigInt(mantissa) << BigInt(shift);
            } else {
                target = BigInt(mantissa) >> BigInt(-shift);
            }

            if (target === 0n) return 1n;

            // work = 2^256 / (target + 1) - same as dkoder
            // dkoder: (!target / (target + 1)) + 1
            // This is mathematically equivalent to 2^256 / (target + 1)
            const work = TWO_256 / (target + 1n);
            return work > 0n ? work : 1n;
        }

        // calcConflictZoneWork: Calculate total work in conflict zone (dkoder: calc_conflict_zone_work)
        // Returns both zoneWork AND zoneBlocks for consistent kColouring
        function calcConflictZoneWork(genesisHash, subgroupHashes) {
            let totalWork = 0n;
            const visited = new Set();
            const validBlocks = [];  // Blocks with valid idx

            // BFS from subgroup tips back to genesis
            const queue = [...subgroupHashes];

            while (queue.length > 0) {
                const hash = queue.shift();
                if (visited.has(hash)) continue;
                if (hash === genesisHash) continue;  // Don't include genesis itself
                visited.add(hash);

                // Skip dummy blocks from Dagknight calculation (visualization only)
                if (isDummyHash(hash)) continue;

                const idx = State.blockHashToIndex.get(hash);
                if (idx === undefined) continue;

                // Add this block's individual work (from bits, not cumulative blueWork)
                const bits = State.blockData.bits[idx];
                const work = calcWork(bits);
                totalWork += work;
                validBlocks.push(hash);

                // Add parents to queue (if not past genesis, skip dummies)
                const parents = State.blockData.parentHashes[idx] || [];
                for (const parentHash of parents) {
                    if (!visited.has(parentHash) && parentHash !== genesisHash && !isDummyHash(parentHash)) {
                        // Check if parent is ancestor of genesis (stop condition)
                        if (!isAncestor(parentHash, genesisHash, 50)) {
                            queue.push(parentHash);
                        }
                    }
                }
            }

            // Track zone size (for display)
            State.dagknight.lastZoneBlockCount = visited.size;

            // Return only valid blocks for kColouring
            return { zoneWork: totalWork, zoneBlocks: validBlocks };
        }

        // orderedMergesetWithoutSelectedParent: Get mergeset in topological order (dkoder: ordered_mergeset_without_selected_parent)
        function orderedMergesetWithoutSelectedParent(selectedParent, allParents) {
            // Mergeset = parents that are not the selected parent
            // and not ancestors of selected parent
            const mergeset = [];

            for (const parentHash of allParents) {
                if (parentHash === selectedParent) continue;

                // Check if this parent is in the anticone of selected parent
                // (not ancestor and not descendant)
                if (!isAncestor(parentHash, selectedParent, 50) &&
                    !isAncestor(selectedParent, parentHash, 50)) {
                    mergeset.push(parentHash);
                }
            }

            // Sort by blueWork (topological approximation)
            return sortBlocks(mergeset);
        }

        // --- Step 3: K-Colouring Functions ---

        // checkBlueCandidate: Check if candidate can be blue with given k (dkoder: check_blue_candidate)
        // Debug counters for rejection reasons
        let checkBlueStats = { check1: 0, check2: 0, check3: 0, passed: 0 };

        function checkBlueCandidate(newBlockData, candidateHash, k, mergesetBlues) {
            // Check 1: mergeset blues count <= k
            if (mergesetBlues.size > k) {
                checkBlueStats.check1++;
                return false;
            }

            // Check 2: candidate's blue anticone size <= k
            const candidateBlueAnticoneSize = calcBlueAnticoneSize(candidateHash, mergesetBlues);
            if (candidateBlueAnticoneSize > k) {
                checkBlueStats.check2++;
                return false;
            }

            // Check 3: for each existing blue, adding candidate doesn't exceed k
            for (const blueHash of mergesetBlues) {
                const existingBlueAnticoneSize = calcBlueAnticoneSizeWithCandidate(
                    blueHash, candidateHash, mergesetBlues
                );
                if (existingBlueAnticoneSize > k) {
                    checkBlueStats.check3++;
                    return false;
                }
            }

            checkBlueStats.passed++;
            return true;
        }

        // Reset and expose stats
        function resetCheckBlueStats() {
            checkBlueStats = { check1: 0, check2: 0, check3: 0, passed: 0 };
        }
        function getCheckBlueStats() {
            return checkBlueStats;
        }

        // Helper: Count blue blocks in anticone of a block
        function calcBlueAnticoneSize(blockHash, blueSet) {
            let count = 0;
            for (const blueHash of blueSet) {
                if (blueHash === blockHash) continue;
                // In anticone = not ancestor and not descendant
                if (!isAncestor(blueHash, blockHash, 30) &&
                    !isAncestor(blockHash, blueHash, 30)) {
                    count++;
                }
            }
            return count;
        }

        // Helper: Count anticone blues if we add candidate to blue set
        function calcBlueAnticoneSizeWithCandidate(blueHash, candidateHash, currentBlues) {
            let count = 0;

            // Count existing blues in anticone
            for (const otherBlue of currentBlues) {
                if (otherBlue === blueHash) continue;
                if (!isAncestor(otherBlue, blueHash, 30) &&
                    !isAncestor(blueHash, otherBlue, 30)) {
                    count++;
                }
            }

            // Check if candidate would be in anticone
            if (candidateHash !== blueHash &&
                !isAncestor(candidateHash, blueHash, 30) &&
                !isAncestor(blueHash, candidateHash, 30)) {
                count++;
            }

            return count;
        }

        // kColouring: Perform k-colouring on parents (dkoder: k_colouring)
        // With caching to avoid redundant calculations
        function kColouring(parentHashes, k, selectedParentOverride = null) {
            const selectedParent = selectedParentOverride || findSelectedParent(parentHashes);
            if (!selectedParent) {
                return { selectedParent: null, mergesetBlues: new Set(), mergesetReds: new Set() };
            }

            // Cache key: sorted parents + k
            const cacheKey = parentHashes.slice().sort().join(',') + ':' + k;
            const cached = State.dagknight.kColouringCache.get(cacheKey);
            if (cached) return cached;

            const mergeset = orderedMergesetWithoutSelectedParent(selectedParent, parentHashes);
            const mergesetBlues = new Set();
            const mergesetReds = new Set();

            // Reset debug stats for this colouring
            resetCheckBlueStats();

            // Process each candidate in topological order
            for (const candidateHash of mergeset) {
                // Simulation mode: force all blocks to blue
                if (CONFIG.DUMMY.ENABLED) {
                    mergesetBlues.add(candidateHash);
                    continue;
                }

                // Early termination (dkoder): if blues already at k, remaining are Red
                if (mergesetBlues.size >= k && k > 0) {
                    // Can't add more blues, mark rest as red
                    mergesetReds.add(candidateHash);
                    continue;
                }

                if (checkBlueCandidate(null, candidateHash, k, mergesetBlues)) {
                    mergesetBlues.add(candidateHash);
                } else {
                    mergesetReds.add(candidateHash);
                }
            }

            const result = {
                selectedParent,
                mergesetBlues,
                mergesetReds,
                blueScore: mergesetBlues.size + 1,  // +1 for selected parent
            };

            // Cache result (limit cache size)
            if (State.dagknight.kColouringCache.size < 1000) {
                State.dagknight.kColouringCache.set(cacheKey, result);
            }

            return result;
        }

        // --- Step 4: DagknightExecutor - dkoder-aligned incremental processing ---

        // getBlueWork: Get blue_work for sorting (from global GHOSTDAG data)
        // blueWork is stored as hex string from API, convert to BigInt for numeric comparison
        function getBlueWork(hash) {
            const idx = State.blockHashToIndex.get(hash);
            if (idx === undefined) return 0n;
            const hexStr = State.blockData.blueWork?.[idx];
            if (!hexStr || hexStr === '0') return 0n;
            // Convert hex string to BigInt (add 0x prefix)
            try {
                return BigInt('0x' + hexStr);
            } catch (e) {
                // Fallback: if not valid hex, try as decimal
                return BigInt(hexStr || 0);
            }
        }

        // getParentsInStore: Get parents that are already in blueWorkStore (dkoder approach)
        function getParentsInStore(blockHash, blueWorkStore) {
            const idx = State.blockHashToIndex.get(blockHash);
            if (idx === undefined) return [];

            const allParents = State.blockData.parentHashes[idx] || [];
            return allParents.filter(p => blueWorkStore.has(p));
        }

        // findSelectedParentFromStore: Find SP using stored blue_work (dkoder: find_selected_parent)
        // Skip dummy blocks - only select from real blocks
        function findSelectedParentFromStore(parents, blueWorkStore) {
            // Filter out dummies - selected chain should only contain real blocks
            const realParents = parents.filter(h => !isDummyHash(h));
            if (realParents.length === 0) return null;
            if (realParents.length === 1) return realParents[0];

            let bestParent = realParents[0];
            let bestWork = blueWorkStore.get(realParents[0]) || 0n;

            for (let i = 1; i < realParents.length; i++) {
                const work = blueWorkStore.get(realParents[i]) || 0n;
                if (work > bestWork) {
                    bestWork = work;
                    bestParent = realParents[i];
                }
            }

            return bestParent;
        }

        // getZoneMergeset: Get mergeset in zone context (anticone of SP among zone parents)
        function getZoneMergeset(selectedParent, parents) {
            const mergeset = [];
            for (const parent of parents) {
                if (parent === selectedParent) continue;
                // In bounded context, we only check among the direct parents
                // Anticone = not ancestor and not descendant
                if (!isAncestor(parent, selectedParent, 30) &&
                    !isAncestor(selectedParent, parent, 30)) {
                    mergeset.push(parent);
                }
            }
            return sortBlocks(mergeset);
        }

        // checkBlueCandidateBounded: Check if candidate can be blue using bounded store
        function checkBlueCandidateBounded(blockHash, candidateHash, k, mergesetBlues, blueStatusStore) {
            // Check 1: current mergeset blues count <= k
            if (mergesetBlues.length > k) {
                return false;
            }

            // Check 2: candidate's blue anticone size <= k
            // Count blues in anticone of candidate
            let candidateBlueAnticoneSize = 0;
            for (const blueHash of mergesetBlues) {
                if (!isAncestor(blueHash, candidateHash, 30) &&
                    !isAncestor(candidateHash, blueHash, 30)) {
                    candidateBlueAnticoneSize++;
                }
            }
            if (candidateBlueAnticoneSize > k) {
                return false;
            }

            // Check 3: each existing blue's anticone with candidate <= k
            for (const blueHash of mergesetBlues) {
                let existingBlueAnticoneSize = 0;
                // Count: candidate + other mergeset blues in anticone of this blue
                if (!isAncestor(blueHash, candidateHash, 30) &&
                    !isAncestor(candidateHash, blueHash, 30)) {
                    existingBlueAnticoneSize++;
                }
                for (const otherBlue of mergesetBlues) {
                    if (otherBlue === blueHash) continue;
                    if (!isAncestor(blueHash, otherBlue, 30) &&
                        !isAncestor(otherBlue, blueHash, 30)) {
                        existingBlueAnticoneSize++;
                    }
                }
                if (existingBlueAnticoneSize > k) {
                    return false;
                }
            }

            return true;
        }

        // fillConflictZoneData: dkoder-aligned incremental processing
        // Process zone blocks using heap-based topological order (by blue_work)
        // virtualSP: The single selected parent for the entire subgroup (dkoder compliant)
        function fillConflictZoneData(root, zoneBlocks, tips, k, virtualSP) {
            const zoneSet = new Set(zoneBlocks);

            // Step 1: Initialize stores
            const blueWorkStore = new Map();   // hash -> BigInt blue_work
            const blueStatusStore = new Map(); // hash -> 'blue' | 'red'
            const mergesetBluesStore = new Map();  // hash -> array of mergeset blues
            const mergesetRedsStore = new Map();   // hash -> array of mergeset reds
            const selectedParentStore = new Map(); // hash -> selected parent

            // dkoder: Pre-insert root into store with 0 blue_work
            // This allows blocks with root as parent to be processed
            blueWorkStore.set(root, 0n);
            blueStatusStore.set(root, 'blue');

            // Step 2: Sort zone blocks by blue_work (ascending) - simulates heap
            const sortedByWork = [...zoneBlocks].sort((a, b) => {
                const workA = getBlueWork(a);
                const workB = getBlueWork(b);
                if (workA < workB) return -1;
                if (workA > workB) return 1;
                return 0;
            });

            // Debug counters
            let totalMergesetBlues = 0;
            let totalMergesetReds = 0;
            let blocksProcessed = 0;
            let skippedBlocks = 0;
            let iterations = 0;

            // Step 3: Process blocks - repeat until all are processed
            // dkoder uses heap; we iterate sorted list and skip if parents not ready
            const pending = new Set(sortedByWork);
            const maxIterations = zoneBlocks.length * 2;  // Safety limit

            while (pending.size > 0 && iterations < maxIterations) {
                iterations++;
                let processedThisRound = 0;

                for (const blockHash of sortedByWork) {
                    if (!pending.has(blockHash)) continue;

                    // dkoder: Get parents that are already in store
                    const parentsInStore = getParentsInStore(blockHash, blueWorkStore);

                    // Get ALL parents for this block
                    const idx = State.blockHashToIndex.get(blockHash);
                    if (idx === undefined) {
                        pending.delete(blockHash);
                        continue;
                    }
                    const allParents = State.blockData.parentHashes[idx] || [];

                    // Filter to zone-relevant parents (in zone or root)
                    const zoneParents = allParents.filter(p => zoneSet.has(p) || p === root);

                    // Skip if not all zone parents are in store yet
                    if (parentsInStore.length < zoneParents.length) {
                        skippedBlocks++;
                        continue;
                    }

                    // All zone parents are ready - process this block
                    pending.delete(blockHash);
                    blocksProcessed++;
                    processedThisRound++;

                    if (parentsInStore.length === 0) {
                        // No parents in store - orphaned in zone context
                        blueWorkStore.set(blockHash, 0n);
                        blueStatusStore.set(blockHash, 'blue');
                        continue;
                    }

                    // Find selected parent (highest blue_work among parents in store)
                    const selectedParent = findSelectedParentFromStore(parentsInStore, blueWorkStore);
                    selectedParentStore.set(blockHash, selectedParent);

                    // Get mergeset (anticone of SP among parents in store)
                    const mergeset = getZoneMergeset(selectedParent, parentsInStore);

                    // k-colouring on mergeset
                    const mergesetBlues = [];
                    const mergesetReds = [];

                    for (const candidate of mergeset) {
                        // Simulation mode: force all blocks to blue
                        if (CONFIG.DUMMY.ENABLED) {
                            mergesetBlues.push(candidate);
                            blueStatusStore.set(candidate, 'blue');
                            continue;
                        }

                        if (mergesetBlues.length >= k && k > 0) {
                            mergesetReds.push(candidate);
                            continue;
                        }

                        if (checkBlueCandidateBounded(blockHash, candidate, k, mergesetBlues, blueStatusStore)) {
                            mergesetBlues.push(candidate);
                            blueStatusStore.set(candidate, 'blue');
                        } else {
                            mergesetReds.push(candidate);
                            blueStatusStore.set(candidate, 'red');
                        }
                    }

                    mergesetBluesStore.set(blockHash, mergesetBlues);
                    mergesetRedsStore.set(blockHash, mergesetReds);
                    totalMergesetBlues += mergesetBlues.length;
                    totalMergesetReds += mergesetReds.length;

                    // Calculate blue_work (dkoder formula):
                    // blue_work = SP.blue_work + sum(mergeset_blues work)
                    const spBlueWork = blueWorkStore.get(selectedParent) || 0n;
                    let addedBlueWork = 0n;
                    for (const blueHash of mergesetBlues) {
                        const bidx = State.blockHashToIndex.get(blueHash);
                        if (bidx !== undefined) {
                            addedBlueWork += calcWork(State.blockData.bits[bidx]);
                        }
                    }
                    const blockBlueWork = spBlueWork + addedBlueWork;
                    blueWorkStore.set(blockHash, blockBlueWork);

                    // The block itself is on the selected chain (implicitly blue)
                    blueStatusStore.set(blockHash, 'blue');
                }

                // If no progress, break to avoid infinite loop
                if (processedThisRound === 0) break;
            }

            // Step 4: Get final result from tips
            let finalBlueWork = 0n;
            let finalSelectedParent = null;
            let finalTip = tips[0];

            for (const tip of tips) {
                const tipBlueWork = blueWorkStore.get(tip) || 0n;
                if (tipBlueWork > finalBlueWork) {
                    finalBlueWork = tipBlueWork;
                    finalTip = tip;
                }
            }
            finalSelectedParent = selectedParentStore.get(finalTip);

            // Collect all blues and reds for coloring display
            const allMergesetBlues = new Set();
            const allMergesetReds = new Set();
            for (const [hash, blues] of mergesetBluesStore) {
                for (const b of blues) allMergesetBlues.add(b);
            }
            for (const [hash, reds] of mergesetRedsStore) {
                for (const r of reds) allMergesetReds.add(r);
            }

            // Count total blues (blocks on chain + mergeset blues)
            let chainBlueCount = 0;
            for (const [hash, status] of blueStatusStore) {
                if (status === 'blue' && !allMergesetBlues.has(hash)) {
                    chainBlueCount++;  // Blue but not from mergeset = on chain
                }
            }

            // Calculate redWork/grayWork by VSPC traversal (dkoder: red_block_work, gray_block_work)
            // Traverse from finalTip back to root, classifying mergeset_reds as gray or red
            let redWork = 0n;
            let grayWork = 0n;
            let vspcLength = 0;
            let vspcRedsCount = 0;

            if (finalTip && selectedParentStore.size > 0) {
                // dkoder: get_next_chain_ancestor(tips[0], conflict_genesis)
                // The direct child of root on the chain path toward tips[0]
                const nextChainAncestor = getNextChainAncestor(tips[0], root);

                let currentHash = finalTip;
                const visited = new Set();

                // Traverse VSPC: finalTip → SP → SP's SP → ... → root
                while (currentHash && currentHash !== root && !visited.has(currentHash)) {
                    visited.add(currentHash);
                    vspcLength++;

                    // Get mergeset_reds for this block on the chain
                    const blockReds = mergesetRedsStore.get(currentHash) || [];
                    for (const redHash of blockReds) {
                        const ridx = State.blockHashToIndex.get(redHash);
                        if (ridx !== undefined && State.blockData.bits[ridx]) {
                            const work = calcWork(State.blockData.bits[ridx]);
                            vspcRedsCount++;

                            // dkoder: classify as gray or red
                            // Gray = red block is in the future of nextChainAncestor (on subgroup's chain path)
                            // Red = red block is outside subgroup's chain path (adversarial)
                            if (nextChainAncestor && isChainAncestorOf(nextChainAncestor, redHash)) {
                                grayWork += work;  // Neutral - on subgroup's path
                            } else {
                                redWork += work;   // Adversarial - competing work
                            }
                        }
                    }

                    // Move to selected parent
                    currentHash = selectedParentStore.get(currentHash);
                }
            }

            return {
                selectedParent: finalSelectedParent,
                mergesetBlues: allMergesetBlues,
                mergesetReds: allMergesetReds,
                blueWork: finalBlueWork,
                redWork,   // dkoder: adversarial red work (excludes gray)
                grayWork,  // dkoder: neutral red work (on subgroup's chain path)
                blueCount: chainBlueCount + allMergesetBlues.size,
                blueStatusStore,  // For coloring
                k,
                // Debug info
                vspcLength,
                vspcRedsCount,
            };
        }

        // selectParentFromKColouring: Single k validation (dkoder: select_parent_from_k_colouring)
        // Returns { hash, blueWork, data } if valid, null otherwise
        function selectParentFromKColouring(conflictGenesis, subgroup, tips, k, genesisWork, virtualSP) {
            const data = fillConflictZoneData(conflictGenesis, subgroup, tips, k, virtualSP);

            // deficit = sqrt(k) * work(conflict_genesis)
            const sqrtK = BigInt(Math.floor(Math.sqrt(k)));
            const deficit = sqrtK * genesisWork;

            // dkoder condition: blueWork + deficit > redWork (gray excluded)
            if (data.blueWork + deficit > data.redWork) {
                return {
                    hash: data.selectedParent,
                    blueWork: data.blueWork,
                    data,
                    deficit,
                };
            }
            return null;
        }

        // rank: K-space search using exponential + binary search (dkoder: rank)
        // Returns { k, subgroupVirtual } with minimum valid k
        function rank(conflictGenesis, subgroup, tips) {
            const MAX_K = 64;

            // dkoder: First find virtual selected parent from tips
            const virtualSP = findSelectedParent(tips);
            if (!virtualSP) {
                const fallbackData = fillConflictZoneData(conflictGenesis, subgroup, tips, MAX_K, null);
                return { k: MAX_K, subgroupVirtual: fallbackData };
            }

            // Get conflict_genesis work for deficit calculation
            const genesisIdx = State.blockHashToIndex.get(conflictGenesis);
            const genesisWork = (genesisIdx !== undefined && State.blockData.bits[genesisIdx])
                ? calcWork(State.blockData.bits[genesisIdx])
                : 1n;

            // Phase 1: Exponential search (dkoder: start at k=0, double increments)
            let lkgK = 0;           // Last known good k
            let lowerK = 0;         // Lower bound for binary search
            let increments = 1;
            let foundLkg = false;
            let lastResult = null;

            while (!foundLkg && lkgK <= MAX_K) {
                const result = selectParentFromKColouring(conflictGenesis, subgroup, tips, lkgK, genesisWork, virtualSP);
                if (result) {
                    lastResult = { k: lkgK, ...result };
                    foundLkg = true;
                } else {
                    lowerK = lkgK;
                    lkgK = increments;
                    increments *= 2;
                }
            }

            // If no valid k found in exponential search, use MAX_K
            if (!lastResult) {
                const fallbackData = fillConflictZoneData(conflictGenesis, subgroup, tips, MAX_K, virtualSP);
                return { k: MAX_K, subgroupVirtual: fallbackData };
            }

            // Phase 2: Binary search to find minimum k (dkoder: binary search)
            let bestK = lkgK;
            let bestResult = lastResult;

            // dkoder: binary search between lowerK and lkgK
            while (lowerK < lkgK) {
                const kToCheck = lowerK + Math.floor((lkgK - lowerK) / 2);
                const result = selectParentFromKColouring(conflictGenesis, subgroup, tips, kToCheck, genesisWork, virtualSP);
                if (result) {
                    lkgK = kToCheck;
                    bestK = kToCheck;
                    bestResult = { k: kToCheck, ...result };
                } else {
                    lowerK = kToCheck + 1;
                }
            }

            // Store debug info
            State.dagknight.lastK = bestK;
            State.dagknight.kDebug = {
                blueWork: bestResult.data.blueWork,
                redWork: bestResult.data.redWork,
                grayWork: bestResult.data.grayWork || 0n,
                deficit: bestResult.deficit,
                vspcLength: bestResult.data.vspcLength || 0,
                vspcReds: bestResult.data.vspcRedsCount || 0,
                tips: tips.length,
                zone: subgroup.length,
            };

            return { k: bestK, subgroupVirtual: bestResult.data };
        }

        // dagknight: Main parent selection with hierarchical conflict resolution (dkoder: dagknight)
        // Returns { selectedParent, coloringResult, k } for batch coloring
        function dagknight(parentHashes) {
            const MAX_ITERATIONS = 10;  // Limit to prevent infinite loops

            // Helper: create fallback result with k=18
            const fallbackResult = (selectedParent) => {
                const coloringResult = kColouring(parentHashes, 18);
                return {
                    selectedParent: selectedParent || coloringResult.selectedParent,
                    coloringResult,
                    k: 18,
                };
            };

            if (!parentHashes || parentHashes.length === 0) {
                return { selectedParent: null, coloringResult: null, k: 0 };
            }
            if (parentHashes.length === 1) {
                return {
                    selectedParent: parentHashes[0],
                    coloringResult: { selectedParent: parentHashes[0], mergesetBlues: new Set(), mergesetReds: new Set() },
                    k: 0,
                };
            }

            // Step 1: Find initial conflict genesis (LCCA)
            let conflictGenesis = commonChainAncestor(parentHashes);
            if (!conflictGenesis) {
                return fallbackResult(null);
            }

            // Step 2: Calculate zone work AND get zone blocks
            const { zoneWork, zoneBlocks } = calcConflictZoneWork(conflictGenesis, parentHashes);
            if (zoneWork === 0n) {
                return fallbackResult(null);
            }

            // Step 2.5: Compute intervals for O(1) ancestor checks
            const zoneSet = new Set(zoneBlocks);
            zoneSet.add(conflictGenesis);
            computeIntervals(conflictGenesis, zoneSet);

            // Step 3: Hierarchical conflict resolution (dkoder: while candidates > 1)
            let candidates = [...parentHashes];
            let lastRankResult = null;
            let iterations = 0;
            let totalGroups = 0;

            while (candidates.length > 1 && iterations < MAX_ITERATIONS) {
                iterations++;

                // Group candidates by next chain ancestor relative to conflict_genesis
                const groups = groupByConflictZone(candidates, conflictGenesis);
                totalGroups += groups.size;

                if (groups.size === 0) break;

                // If only one group, we're done
                if (groups.size === 1) {
                    const [, subgroup] = [...groups.entries()][0];
                    lastRankResult = rank(conflictGenesis, zoneBlocks, subgroup);
                    break;
                }

                // Rank each subgroup and find winner (lowest k, then highest blueWork)
                let bestRank = null;
                let bestSubgroup = null;
                let bestOrigin = null;

                for (const [origin, subgroup] of groups) {
                    if (subgroup.length === 0) continue;

                    const rankResult = rank(conflictGenesis, zoneBlocks, subgroup);

                    // Compare: lower k is better, tie-break by higher blueWork
                    if (!bestRank ||
                        rankResult.k < bestRank.k ||
                        (rankResult.k === bestRank.k &&
                         rankResult.subgroupVirtual.blueWork > bestRank.subgroupVirtual.blueWork)) {
                        bestRank = rankResult;
                        bestSubgroup = subgroup;
                        bestOrigin = origin;
                    }
                }

                if (!bestRank || !bestSubgroup) break;

                lastRankResult = bestRank;

                // Winner becomes new candidate set
                // dkoder: candidates = [winner's selected parent]
                const winnerSP = bestRank.subgroupVirtual.selectedParent;
                if (winnerSP) {
                    candidates = [winnerSP];
                } else {
                    candidates = bestSubgroup;
                }

                // Update conflict genesis for next iteration
                if (bestOrigin && bestOrigin !== conflictGenesis) {
                    conflictGenesis = bestOrigin;
                }
            }

            // Store hierarchical debug info
            State.dagknight.hierDebug = {
                iterations,
                groups: totalGroups,
                totalTips: parentHashes.length,  // All visible tips
            };

            // Return result
            if (lastRankResult) {
                const selectedParent = lastRankResult.subgroupVirtual.selectedParent || findSelectedParent(parentHashes);
                return {
                    selectedParent,
                    coloringResult: lastRankResult.subgroupVirtual,
                    k: lastRankResult.k,
                };
            }

            return fallbackResult(findSelectedParent(parentHashes));
        }

        // --- Step 5: CascadeTree Functions (Confirmation) ---

        // cascadeTreeInsert: Add block to cascade tree (dkoder: CascadeTree::insert)
        function cascadeTreeInsert(hash, pastBlues, pastReds, anticoneBlues, arlb) {
            const { cascadeTree } = State.dagknight;
            cascadeTree.pastBlues.set(hash, pastBlues);
            cascadeTree.pastReds.set(hash, pastReds);
            cascadeTree.anticoneBlues.set(hash, anticoneBlues);
            cascadeTree.arlb.set(hash, arlb);

            // Calculate floor
            // floor = pastReds + arlb - pastBlues - anticoneBlues
            const floor = pastReds + arlb - pastBlues - anticoneBlues;
            cascadeTree.floor.set(hash, floor);
        }

        // updateAnticoneBlues: Update anticone blue count (dkoder: CascadeTree::update_anticone_blues)
        function updateAnticoneBlues(hash, count) {
            const { cascadeTree } = State.dagknight;
            cascadeTree.anticoneBlues.set(hash, count);

            // Recalculate floor
            const pastBlues = cascadeTree.pastBlues.get(hash) || 0;
            const pastReds = cascadeTree.pastReds.get(hash) || 0;
            const arlb = cascadeTree.arlb.get(hash) || 0;
            const floor = pastReds + arlb - pastBlues - count;
            cascadeTree.floor.set(hash, floor);
        }

        // peekMin: Get block with minimum floor (dkoder: CascadeTree::peek_min)
        function peekMin() {
            const { cascadeTree } = State.dagknight;
            let minHash = null;
            let minFloor = Infinity;

            for (const [hash, floor] of cascadeTree.floor) {
                if (floor < minFloor) {
                    minFloor = floor;
                    minHash = hash;
                }
            }

            return { hash: minHash, floor: minFloor };
        }

        // updateConfirmationState: Update block confirmation based on Dagknight (dkoder-compliant)
        function updateConfirmationState(blockHash, coloringResult) {
            const { d, PENDING, BLUE, RED } = State.dagknight;
            const idx = State.blockHashToIndex.get(blockHash);
            if (idx === undefined) return;

            // Get floor value
            const { cascadeTree } = State.dagknight;
            const floor = cascadeTree.floor.get(blockHash);

            // Check if confirmed (floor >= -d)
            if (floor !== undefined && floor >= -d) {
                // Determine blue or red from coloring result
                if (coloringResult.mergesetBlues.has(blockHash) ||
                    blockHash === coloringResult.selectedParent) {
                    State.blockData.confirmationState[idx] = BLUE;
                    State.blockData.color[idx] = CONFIG.COLORS.BLUE_BLOCK;
                    State.blockData.isBlue[idx] = 1;
                } else if (coloringResult.mergesetReds.has(blockHash)) {
                    State.blockData.confirmationState[idx] = RED;
                    State.blockData.color[idx] = CONFIG.COLORS.RED_BLOCK;
                    State.blockData.isBlue[idx] = 0;
                }
            }
            // else: stays PENDING
        }

        // ============================================================
        // End Dagknight Engine
        // ============================================================

        // ============================================================
        // Interval-based Reachability (dkoder: reachability_service)
        // ============================================================

        /**
         * Compute intervals for all blocks in the given set
         * Using DFS traversal from root, assign [start, end] intervals
         * This enables O(1) chain ancestor checks
         *
         * dkoder uses: store.get_interval(this)?.contains(store.get_interval(queried)?)
         *
         * @param useSelectedParentOnly - if true, only build edges via selected parent (GHOSTDAG chain)
         */
        function computeIntervals(rootHash, blockSet, useSelectedParentOnly = false) {
            const { intervalMap } = State.dagknight;
            intervalMap.clear();
            State.dagknight.intervalCounter = 0;

            if (!rootHash || !blockSet || blockSet.size === 0) {
                return;
            }

            // Build child map: parent → [children]
            const childMap = new Map();
            for (const hash of blockSet) {
                const idx = State.blockHashToIndex.get(hash);
                if (idx === undefined) continue;
                const parents = State.blockData.parentHashes[idx] || [];

                if (useSelectedParentOnly) {
                    // GHOSTDAG chain: only selected parent edge
                    const sp = findSelectedParent(parents);
                    if (sp && blockSet.has(sp)) {
                        if (!childMap.has(sp)) {
                            childMap.set(sp, []);
                        }
                        childMap.get(sp).push(hash);
                    }
                } else {
                    // All parent edges (for conflict zone)
                    for (const parentHash of parents) {
                        if (!blockSet.has(parentHash)) continue;
                        if (!childMap.has(parentHash)) {
                            childMap.set(parentHash, []);
                        }
                        childMap.get(parentHash).push(hash);
                    }
                }
            }

            // DFS to assign intervals
            const visited = new Set();
            function dfs(hash) {
                if (visited.has(hash)) return;
                visited.add(hash);

                const start = State.dagknight.intervalCounter++;

                // Visit children (blocks that have this as parent)
                const children = childMap.get(hash) || [];
                for (const childHash of children) {
                    dfs(childHash);
                }

                const end = State.dagknight.intervalCounter++;
                intervalMap.set(hash, { start, end });
            }

            dfs(rootHash);

            // Also process any blocks not reachable from root
            for (const hash of blockSet) {
                if (!visited.has(hash)) {
                    dfs(hash);
                }
            }
        }

        /**
         * Check if hashA is a CHAIN ancestor of hashB using intervals
         * This is O(1) - just interval containment check
         *
         * dkoder: is_chain_ancestor_of uses interval.contains()
         * A is ancestor of B if A.interval contains B.interval
         */
        function isChainAncestorOf(hashA, hashB) {
            const { intervalMap } = State.dagknight;
            const intervalA = intervalMap.get(hashA);
            const intervalB = intervalMap.get(hashB);

            if (!intervalA || !intervalB) return null;  // Unknown, need fallback

            // A contains B means A.start <= B.start && B.end <= A.end
            return intervalA.start <= intervalB.start && intervalB.end <= intervalA.end;
        }

        /**
         * Get the next chain ancestor: the direct child of 'ancestor' on the chain path toward 'descendant'
         * dkoder: get_next_chain_ancestor(descendant, ancestor)
         * Returns the block that is one step "forward" from ancestor toward descendant on the GHOSTDAG chain
         */
        function getNextChainAncestor(descendant, ancestor) {
            if (descendant === ancestor) return null;

            // Walk backward from descendant toward ancestor, tracking the previous block
            let current = descendant;
            let prev = null;
            const visited = new Set();

            while (current && current !== ancestor && !visited.has(current)) {
                visited.add(current);
                prev = current;

                const idx = State.blockHashToIndex.get(current);
                if (idx === undefined) break;

                const parents = State.blockData.parentHashes[idx] || [];
                current = findSelectedParent(parents);  // Follow GHOSTDAG chain
            }

            // If we reached ancestor, prev is the direct child on the chain path
            return (current === ancestor) ? prev : null;
        }

        // ============================================================
        // End Interval-based Reachability
        // ============================================================

        // Step 2.2: Reachability - Check if blockA is ancestor of blockB
        function isAncestor(hashA, hashB, maxDepth = 100) {
            if (hashA === hashB) return true;

            // Try O(1) interval check first (dkoder: is_chain_ancestor_of)
            const chainResult = isChainAncestorOf(hashA, hashB);
            if (chainResult === true) return true;
            if (chainResult === false) return false;
            // chainResult === null means no interval data, fall through to BFS

            // Check cache (dkoder optimization)
            const cacheKey = hashA + ':' + hashB;
            const cached = State.dagknight.ancestorCache.get(cacheKey);
            if (cached !== undefined) return cached;

            const visited = new Set();
            const queue = [hashB];
            let depth = 0;

            while (queue.length > 0 && depth < maxDepth) {
                const levelSize = queue.length;
                for (let i = 0; i < levelSize; i++) {
                    const currentHash = queue.shift();
                    if (currentHash === hashA) {
                        State.dagknight.ancestorCache.set(cacheKey, true);
                        return true;
                    }
                    if (visited.has(currentHash)) continue;
                    visited.add(currentHash);

                    const idx = State.blockHashToIndex.get(currentHash);
                    if (idx === undefined) continue;
                    const parents = State.blockData.parentHashes[idx] || [];
                    for (const parentHash of parents) {
                        if (!visited.has(parentHash)) {
                            queue.push(parentHash);
                        }
                    }
                }
                depth++;
            }

            State.dagknight.ancestorCache.set(cacheKey, false);
            return false;
        }

        // Step 2.3: Group blocks by conflict zone origin
        // Returns Map<conflictOriginHash, blockHash[]>
        function groupByConflictZone(blockHashes, lccaHash) {
            const groups = new Map();  // conflictOrigin -> [blockHashes]

            for (const blockHash of blockHashes) {
                // Find the first block after LCCA on path from block to LCCA
                const conflictOrigin = findConflictOrigin(blockHash, lccaHash);

                if (!groups.has(conflictOrigin)) {
                    groups.set(conflictOrigin, []);
                }
                groups.get(conflictOrigin).push(blockHash);
            }

            return groups;
        }

        // Find conflict origin: first block after LCCA on the path from block to LCCA
        function findConflictOrigin(blockHash, lccaHash) {
            if (blockHash === lccaHash) return lccaHash;

            // BFS from block to LCCA, tracking path
            const parent = new Map();  // child -> parent (for path reconstruction)
            const visited = new Set([blockHash]);
            const queue = [blockHash];

            while (queue.length > 0) {
                const current = queue.shift();
                if (current === lccaHash) break;

                const idx = State.blockHashToIndex.get(current);
                if (idx === undefined) continue;

                const parents = State.blockData.parentHashes[idx] || [];
                for (const p of parents) {
                    if (!visited.has(p)) {
                        visited.add(p);
                        parent.set(p, current);
                        queue.push(p);
                    }
                }
            }

            // Reconstruct path from LCCA back to block, return first child of LCCA
            if (!visited.has(lccaHash)) return blockHash;  // No path found

            let current = lccaHash;
            let prev = null;

            // Walk from LCCA to block via parent map (reversed)
            // We need to find the child of LCCA (first step away from LCCA toward block)
            const pathToBlock = [lccaHash];
            const lccaIdx = State.blockHashToIndex.get(lccaHash);
            if (lccaIdx === undefined) return blockHash;

            // Reverse: find which visited block has LCCA as parent
            for (const [child, p] of parent.entries()) {
                if (p === lccaHash || isAncestor(lccaHash, p, 5)) {
                    // This child is close to LCCA
                    if (isAncestor(child, blockHash, 50) || child === blockHash) {
                        return child;
                    }
                }
            }

            return blockHash;  // Fallback
        }

        // Step 2.5: Compare RankValue (k, blueWork, selectedParentHash)
        function compareRank(hashA, hashB) {
            const idxA = State.blockHashToIndex.get(hashA);
            const idxB = State.blockHashToIndex.get(hashB);
            if (idxA === undefined || idxB === undefined) return 0;

            // Compare blueWork (higher is better)
            // blueWork is hex string, convert with 0x prefix
            const workStrA = State.blockData.blueWork[idxA] || '0';
            const workStrB = State.blockData.blueWork[idxB] || '0';

            try {
                const blueWorkA = BigInt('0x' + workStrA.replace(/^0x/, ''));
                const blueWorkB = BigInt('0x' + workStrB.replace(/^0x/, ''));

                if (blueWorkA > blueWorkB) return -1;  // A wins
                if (blueWorkA < blueWorkB) return 1;   // B wins
            } catch (e) {
                // Fallback: compare as strings
                if (workStrA > workStrB) return -1;
                if (workStrA < workStrB) return 1;
            }

            // Tiebreaker: hash (lexicographic, lower wins)
            if (hashA < hashB) return -1;
            if (hashA > hashB) return 1;

            return 0;
        }

        // Step 2.6: Select best block from a group using RankValue
        function selectBestFromGroup(blockHashes) {
            if (blockHashes.length === 0) return null;
            if (blockHashes.length === 1) return blockHashes[0];

            let best = blockHashes[0];
            for (let i = 1; i < blockHashes.length; i++) {
                if (compareRank(blockHashes[i], best) < 0) {
                    best = blockHashes[i];
                }
            }
            return best;
        }

        // Step 2.7: Dagknight Parent Selection (hierarchical conflict resolution)
        // Skip dummy blocks - only select from real blocks
        function selectParent(parentHashes, depth = 0) {
            // Filter out dummies at entry - selected chain should only contain real blocks
            const realParents = depth === 0
                ? parentHashes.filter(h => !isDummyHash(h))
                : parentHashes;  // Already filtered in recursive calls

            if (depth > 10) return selectBestFromGroup(realParents);
            if (realParents.length === 0) return null;
            if (realParents.length === 1) return realParents[0];

            const lcca = commonChainAncestor(realParents);
            if (!lcca) return selectBestFromGroup(realParents);

            const groups = groupByConflictZone(realParents, lcca);
            if (groups.size <= 1) return selectBestFromGroup(realParents);

            const groupWinners = [];
            for (const [origin, members] of groups.entries()) {
                const winner = selectBestFromGroup(members);
                if (winner) groupWinners.push(winner);
            }

            return selectParent(groupWinners, depth + 1);
        }

        // Step 2.8: Build Selected Chains from each Tip
        // Returns array of edges: [[from, to], [from, to], ...]
        // Also collects all ancestors (for topological ordering / Y=0 convergence)
        function buildSelectedChains(tipHashes, maxDepth = 50) {
            const edges = [];           // [fromHash, toHash] pairs for selected chain
            const visited = new Set();  // Avoid duplicate edges after merge
            const chainBlocks = new Set(); // Blocks on selected chain
            const orderedBlocks = new Set(); // All blocks that should be Y=0 (chain + ancestors)

            for (const tip of tipHashes) {
                let currentHash = tip;
                let depth = 0;

                while (currentHash && depth < maxDepth) {
                    const idx = State.blockHashToIndex.get(currentHash);
                    if (idx === undefined) break;

                    chainBlocks.add(currentHash);
                    orderedBlocks.add(currentHash);

                    const parents = State.blockData.parentHashes[idx] || [];
                    if (parents.length === 0) break;

                    // Add ALL parents to orderedBlocks (they are topologically ordered)
                    for (const p of parents) {
                        orderedBlocks.add(p);
                        // Recursively add ancestors of non-selected parents too
                        collectAncestors(p, orderedBlocks, 30);
                    }

                    // Select parent for this block (for chain edge)
                    // Use findSelectedParent (GHOSTDAG) - same as dkoder's get_chain_parent
                    const selectedParent = findSelectedParent(parents);
                    if (!selectedParent) break;

                    // Add edge if not already visited (avoid duplicates after merge)
                    const edgeKey = `${currentHash}->${selectedParent}`;
                    if (!visited.has(edgeKey)) {
                        visited.add(edgeKey);
                        edges.push([currentHash, selectedParent]);
                    }

                    currentHash = selectedParent;
                    depth++;
                }
            }

            return { edges, chainBlocks, orderedBlocks };
        }

        // Helper: Collect all ancestors up to maxDepth
        function collectAncestors(hash, resultSet, maxDepth) {
            if (maxDepth <= 0 || resultSet.has(hash)) return;

            const idx = State.blockHashToIndex.get(hash);
            if (idx === undefined) return;

            resultSet.add(hash);

            const parents = State.blockData.parentHashes[idx] || [];
            for (const p of parents) {
                collectAncestors(p, resultSet, maxDepth - 1);
            }
        }

        // ============================================================
        // Linearization Algorithm (Dagknight/GHOSTDAG compliant)
        // ============================================================

        // Check if 'ancestor' is an ancestor of 'block' (with depth limit)
        function isAncestorOf(ancestor, block, maxDepth = 30) {
            if (!block || !ancestor) return false;
            if (ancestor === block) return true;

            const visited = new Set();
            const queue = [block];
            let depth = 0;

            while (queue.length > 0 && depth < maxDepth) {
                const levelSize = queue.length;
                for (let i = 0; i < levelSize; i++) {
                    const current = queue.shift();
                    if (current === ancestor) return true;

                    const idx = State.blockHashToIndex.get(current);
                    if (idx === undefined) continue;

                    const parents = State.blockData.parentHashes[idx] || [];
                    for (const p of parents) {
                        if (!visited.has(p)) {
                            visited.add(p);
                            queue.push(p);
                        }
                    }
                }
                depth++;
            }

            return false;
        }

        // Compute Mergeset (dkoder-style): BFS from chainBlock, stop at selectedParent's ancestors
        // This only processes blocks in the "river" between chainBlock and selectedParent
        function computeMergeset(chainBlock, selectedParent) {
            const mergeset = [];
            if (!chainBlock) return mergeset;

            const idx = State.blockHashToIndex.get(chainBlock);
            if (idx === undefined) return mergeset;

            const parents = State.blockData.parentHashes[idx] || [];
            if (parents.length === 0) return mergeset;

            // BFS from chainBlock's parents (excluding selectedParent)
            const visited = new Set();
            const pastOfSelected = new Set();  // Blocks known to be in Past(selectedParent)
            const queue = [];

            for (const p of parents) {
                if (p !== selectedParent) {
                    queue.push(p);
                    visited.add(p);
                    mergeset.push(p);
                }
            }

            // BFS with stopping condition (like dkoder)
            let iterations = 0;
            const maxIterations = 200;  // Safety limit

            while (queue.length > 0 && iterations < maxIterations) {
                const current = queue.shift();
                iterations++;

                const currentIdx = State.blockHashToIndex.get(current);
                if (currentIdx === undefined) continue;

                const currentParents = State.blockData.parentHashes[currentIdx] || [];
                for (const parent of currentParents) {
                    if (visited.has(parent) || pastOfSelected.has(parent)) {
                        continue;
                    }

                    // Check if this parent is an ancestor of selectedParent (stop condition)
                    if (selectedParent && isAncestorOf(parent, selectedParent, 20)) {
                        pastOfSelected.add(parent);
                        continue;  // Don't add to mergeset, stop exploring this path
                    }

                    visited.add(parent);
                    mergeset.push(parent);
                    queue.push(parent);
                }
            }

            return mergeset;
        }

        // Sort blocks by blue_work ascending, then hash ascending (tiebreaker)
        function sortByBlueWork(hashes) {
            return hashes.sort((a, b) => {
                const idxA = State.blockHashToIndex.get(a);
                const idxB = State.blockHashToIndex.get(b);
                if (idxA === undefined || idxB === undefined) return 0;

                // Get blueWork as BigInt
                const workStrA = State.blockData.blueWork[idxA] || '0';
                const workStrB = State.blockData.blueWork[idxB] || '0';

                try {
                    const workA = BigInt('0x' + workStrA.replace(/^0x/, ''));
                    const workB = BigInt('0x' + workStrB.replace(/^0x/, ''));

                    // Ascending order (lower blue_work first)
                    if (workA < workB) return -1;
                    if (workA > workB) return 1;
                } catch (e) {
                    // Fallback: string comparison
                    if (workStrA < workStrB) return -1;
                    if (workStrA > workStrB) return 1;
                }

                // Tiebreaker: hash ascending
                if (a < b) return -1;
                if (a > b) return 1;

                return 0;
            });
        }

        // Build complete linear order from Selected Chain
        // Order: S0 → mergeset(S1) → S1 → mergeset(S2) → S2 → ...
        function buildLinearOrder(selectedChain) {
            if (selectedChain.length === 0) return [];

            const linearOrder = [];
            const addedToOrder = new Set();

            // Reverse chain to go from oldest to newest
            const chainOldestFirst = [...selectedChain].reverse();

            for (let i = 0; i < chainOldestFirst.length; i++) {
                const chainBlock = chainOldestFirst[i];
                const prevChainBlock = i > 0 ? chainOldestFirst[i - 1] : null;

                // Compute mergeset for this chain block
                const mergeset = computeMergeset(chainBlock, prevChainBlock);

                // Add dummy blocks as part of mergeset (high BPS simulation)
                // Dummies are treated as parallel blocks absorbed by this chain block
                if (CONFIG.DUMMY.ENABLED) {
                    for (let j = 0; j < CONFIG.DUMMY.MULTIPLIER; j++) {
                        const dummyHash = generateDummyHash(chainBlock, j);
                        if (State.blockHashToIndex.has(dummyHash) && !addedToOrder.has(dummyHash)) {
                            mergeset.push(dummyHash);
                        }
                    }
                }

                // Sort mergeset by blue_work ascending (dummies have lower blueWork)
                const sortedMergeset = sortByBlueWork(mergeset);

                // Add mergeset blocks (skip if already added)
                for (const hash of sortedMergeset) {
                    if (!addedToOrder.has(hash)) {
                        addedToOrder.add(hash);
                        linearOrder.push(hash);
                    }
                }

                // Add chain block itself
                if (!addedToOrder.has(chainBlock)) {
                    addedToOrder.add(chainBlock);
                    linearOrder.push(chainBlock);
                }
            }

            return linearOrder;
        }

        // Step 2.9: Run Dagknight calculation and update block positions
        function runDagknightCalculation() {
            if (State.blockCount < 2) return;

            try {
                // Find all tips (blocks with no children)
                const allHashes = [];
                for (let i = 0; i < State.blockCount; i++) {
                    const hash = State.blockData.hashes[i];
                    if (hash) allHashes.push(hash);
                }

                // Find tips by checking which blocks are not parents of any other block
                const hasChild = new Set();
                for (let i = 0; i < State.blockCount; i++) {
                    const parents = State.blockData.parentHashes[i] || [];
                    for (const p of parents) {
                        hasChild.add(p);
                    }
                }

                let tips = allHashes.filter(h => !hasChild.has(h));

                // Also include dummyTips that haven't been selected as parents yet
                // These are "virtual tips" for high BPS simulation
                if (CONFIG.DUMMY.ENABLED && State.dummyTips.size > 0) {
                    for (const dummyHash of State.dummyTips.keys()) {
                        if (!tips.includes(dummyHash) && !hasChild.has(dummyHash)) {
                            tips.push(dummyHash);
                        }
                    }
                }

                // DEBUG: Count real vs dummy tips
                const realTips = tips.filter(h => !isDummyHash(h));
                const dummyTipsCount = tips.filter(h => isDummyHash(h));
                State.debugTipsInfo = {
                    total: tips.length,
                    real: realTips.length,
                    dummy: dummyTipsCount.length,
                };

                if (tips.length === 0) return;

                // Build edges from ALL tips (for green lines showing convergence)
                const startTime = performance.now();
                const { edges, orderedBlocks } = buildSelectedChains(tips.slice(0, 50));

                // Find LCCA (convergence point where all tip paths meet)
                // Intervals are now computed internally in commonChainAncestor
                const lccaHash = commonChainAncestor(tips.slice(0, 50));
                State.lccaHash = lccaHash;

                // Build Single Selected Chain for linearization (dkoder compliant)
                // Start from best tip (max blueWork), follow GHOSTDAG selected parents
                // This is THE main selected chain - used for LARGE BLOCKS only
                // Use findSelectedParent (GHOSTDAG) - same as dkoder's get_chain_parent
                const bestTip = findSelectedParent(tips);
                const chainList = [];
                let currentChainBlock = bestTip;
                const maxChainDepth = 100;

                while (currentChainBlock && chainList.length < maxChainDepth) {
                    chainList.push(currentChainBlock);

                    const idx = State.blockHashToIndex.get(currentChainBlock);
                    if (idx === undefined) break;

                    const parents = State.blockData.parentHashes[idx] || [];
                    if (parents.length === 0) break;

                    // Select next chain block (GHOSTDAG - max blueWork)
                    currentChainBlock = findSelectedParent(parents);
                }
                // chainList is now [bestTip, parent1, parent2, ...] = newest to oldest

                // Build linear order (Dagknight compliant)
                const linearOrder = buildLinearOrder(chainList);
                const calcTime = performance.now() - startTime;

                // Green edges: from ALL tips converging to LCCA
                State.selectedChainEdges = edges;

                // Cache confirmed (blue) chain edges - edges before LCCA
                // These persist until their blocks are removed from memory
                if (lccaHash) {
                    const lccaIdx = State.blockHashToIndex.get(lccaHash);
                    const lccaDaa = lccaIdx !== undefined ? State.blockData.daaScore[lccaIdx] : Infinity;

                    for (const [fromHash, toHash] of edges) {
                        const idx1 = State.blockHashToIndex.get(fromHash);
                        const idx2 = State.blockHashToIndex.get(toHash);
                        if (idx1 !== undefined && idx2 !== undefined) {
                            const daa1 = State.blockData.daaScore[idx1];
                            const daa2 = State.blockData.daaScore[idx2];
                            // Both blocks before LCCA = confirmed edge
                            if (daa1 < lccaDaa && daa2 < lccaDaa) {
                                const edgeKey = `${fromHash}:${toHash}`;
                                State.confirmedChainEdges.set(edgeKey, [fromHash, toHash]);
                            }
                        }
                    }

                    // Clean up cached edges whose blocks no longer exist
                    for (const [key, [fromHash, toHash]] of State.confirmedChainEdges) {
                        if (!State.blockHashToIndex.has(fromHash) || !State.blockHashToIndex.has(toHash)) {
                            State.confirmedChainEdges.delete(key);
                        }
                    }
                }

                // Large blocks: only on main chain (bestTip's chain)
                State.selectedChainBlocks = new Set(chainList);
                State.orderedBlocks = orderedBlocks;
                State.linearOrder = linearOrder;

                // --- Dagknight Coloring: Dynamic k-search with caching ---
                const { PENDING, BLUE, RED } = State.dagknight;
                let coloredCount = 0;
                const processedParentSets = new Set();  // Cache: avoid duplicate calculations

                // Process from tips backwards - each tip confirms its parents
                // Limit processing to avoid performance issues
                const tipsToProcess = tips.slice(0, 50);  // Process up to 50 tips

                for (const tipHash of tipsToProcess) {
                    const tipIdx = State.blockHashToIndex.get(tipHash);
                    if (tipIdx === undefined) continue;

                    const parents = State.blockData.parentHashes[tipIdx] || [];
                    if (parents.length === 0) continue;

                    // Cache key: sorted parent hashes
                    const parentsKey = parents.slice().sort().join(',');
                    if (processedParentSets.has(parentsKey)) continue;
                    processedParentSets.add(parentsKey);

                    // Dagknight: Call main function (dkoder-aligned structure)
                    const dkResult = dagknight(parents);
                    const coloringResult = dkResult.coloringResult;
                    const usedK = dkResult.k;

                    // Skip if no valid coloring result
                    if (!coloringResult) continue;

                    // Update confirmation state for parents
                    for (const parentHash of parents) {
                        const parentIdx = State.blockHashToIndex.get(parentHash);
                        if (parentIdx === undefined) continue;

                        // Only update if still pending
                        if (State.blockData.confirmationState[parentIdx] !== PENDING) continue;

                        // Determine blue or red based on Dagknight coloring
                        if (parentHash === coloringResult.selectedParent ||
                            coloringResult.mergesetBlues.has(parentHash)) {
                            State.blockData.confirmationState[parentIdx] = BLUE;
                            State.blockData.color[parentIdx] = CONFIG.COLORS.BLUE_BLOCK;
                            State.blockData.isBlue[parentIdx] = 1;
                        } else if (coloringResult.mergesetReds.has(parentHash)) {
                            State.blockData.confirmationState[parentIdx] = RED;
                            State.blockData.color[parentIdx] = CONFIG.COLORS.RED_BLOCK;
                            State.blockData.isBlue[parentIdx] = 0;
                        } else {
                            // Ancestor of selected parent - blue
                            State.blockData.confirmationState[parentIdx] = BLUE;
                            State.blockData.color[parentIdx] = CONFIG.COLORS.BLUE_BLOCK;
                            State.blockData.isBlue[parentIdx] = 1;
                        }
                        coloredCount++;
                    }

                    // Store the k value used
                    State.dagknight.coloringK.set(tipHash, usedK);
                }

                // Also color any remaining hasChild blocks that weren't processed
                // (older blocks not reachable from current tips)
                for (let i = 0; i < State.blockCount; i++) {
                    if (State.blockData.confirmationState[i] !== PENDING) continue;
                    const blockHash = State.blockData.hashes[i];
                    if (!blockHash) continue;

                    if (hasChild.has(blockHash)) {
                        // Has children but wasn't processed - mark as Blue
                        State.blockData.confirmationState[i] = BLUE;
                        State.blockData.color[i] = CONFIG.COLORS.BLUE_BLOCK;
                        State.blockData.isBlue[i] = 1;
                        coloredCount++;
                    }
                }
                // --- End Dagknight Coloring ---

                // Assign linearIndex and targetX to linearized blocks
                // Position blocks based on view mode
                if (CONFIG.VIEW_MODE === 'dag') {
                    // DAG mode: Keep newest block inside right edge (zoom-aware)
                    // Viewport stays at 0 (X=0 at right edge, newest blocks near 0)
                    State.viewport.targetX = 0;
                } else {
                    // Linear mode: linearized blocks align to chain
                    const maxLinearIdx = linearOrder.length - 1;
                    const SPAWN_X = CONFIG.SPAWN_X;

                    // Build hash→index map for O(1) lookup
                    const linearOrderMap = new Map();
                    for (let idx = 0; idx < linearOrder.length; idx++) {
                        linearOrderMap.set(linearOrder[idx], idx);
                    }

                    for (let i = 0; i < State.blockCount; i++) {
                        const hash = State.blockData.hashes[i];
                        const linearIdx = linearOrderMap.has(hash) ? linearOrderMap.get(hash) : -1;

                        if (linearIdx !== -1) {
                            // Block is linearized - right aligned from SPAWN_X
                            State.blockData.linearIndex[i] = linearIdx;
                            State.blockData.targetX[i] = SPAWN_X - (maxLinearIdx - linearIdx) * CONFIG.LINEAR_PITCH;
                            State.blockData.targetY[i] = 0;
                            State.blockData.isBlue[i] = 1;
                        } else {
                            // Block not yet linearized - place just right of SPAWN_X
                            State.blockData.linearIndex[i] = -1;
                            State.blockData.targetX[i] = SPAWN_X + 20;
                            // targetY stays at random position
                        }
                    }
                }

                // Viewport control (Linear mode stays fixed)

                // Cleanup: Remove blocks that have scrolled too far left
                // Use fixed CLEANUP_THRESHOLD (X=0 at right edge, negative X goes left)
                let removedCount = 0;
                for (let i = 0; i < State.blockCount; i++) {
                    const hash = State.blockData.hashes[i];
                    if (!hash) continue;

                    // Check if block is too far left (past cleanup threshold)
                    if (State.blockData.x[i] < CONFIG.CLEANUP_THRESHOLD) {
                        // Remove from hash map
                        State.blockHashToIndex.delete(hash);
                        // Clear the slot
                        State.blockData.hashes[i] = null;
                        removedCount++;
                    }
                }

                // Update cached sorted indices (by X descending = newest first)
                // This avoids O(n log n) sort every frame in renderDAG
                const { x } = State.blockData;
                State.sortedIndices = [];
                for (let i = 0; i < State.blockCount; i++) {
                    if (State.blockData.hashes[i]) {
                        State.sortedIndices.push(i);
                    }
                }
                State.sortedIndices.sort((a, b) => x[b] - x[a]);
            } catch (error) {
                console.error('Dagknight calculation error:', error);
            }
        }

        // ------------------------------------------------------------
        // Block Management
        // ------------------------------------------------------------
        function addBlock(blockInfo) {
            const index = State.ringHead;

            // Remove oldest block BEFORE overwriting (Ring Buffer bug fix)
            if (State.blockCount >= CONFIG.MAX_BLOCKS) {
                const oldestHash = State.blockData.hashes[index];
                State.blockHashToIndex.delete(oldestHash);
            }

            // Store hash (WASM SDK uses header.hash, not block.hash)
            const hash = blockInfo.header.hash;
            State.blockData.hashes[index] = hash;
            State.blockHashToIndex.set(hash, index);

            // Calculate position using relative coordinates (avoids Float32 precision issues)
            const daaScore = Number(blockInfo.header.daaScore);
            State.blockData.daaScore[index] = daaScore;

            // Set reference point on first block
            if (State.minDaaScore === null) {
                State.minDaaScore = daaScore;
                State.maxDaaScore = daaScore;
            }

            // Track DAA score range (for reference)
            // When maxDaaScore increases in DAG mode, shift all existing blocks left
            if (daaScore > State.maxDaaScore) {
                if (CONFIG.VIEW_MODE === 'dag' && State.maxDaaScore !== null) {
                    const oldMaxColumn = Math.floor((State.maxDaaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                    const newMaxColumn = Math.floor((daaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                    const columnShift = newMaxColumn - oldMaxColumn;
                    if (columnShift > 0) {
                        const xShift = -columnShift * CONFIG.DAA_COLUMN_WIDTH;
                        // Shift all existing blocks left
                        for (let i = 0; i < State.blockCount; i++) {
                            if (State.blockData.hashes[i]) {
                                State.blockData.targetX[i] += xShift;
                            }
                        }
                    }
                }
                State.maxDaaScore = daaScore;
            }

            // Position based on view mode
            const yScale = CONFIG.DUMMY.ENABLED ? (CONFIG.DUMMY.MULTIPLIER <= 2 ? 1.5 : 2.0) : 1.0;
            if (CONFIG.VIEW_MODE === 'dag') {
                // DAG mode: X based on column (DAA grouped), Y based on order in column
                // Newest blocks near X=0 (right edge), older blocks have negative X
                const column = Math.floor((daaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                const maxColumn = Math.floor((State.maxDaaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                const reverseColumn = maxColumn - column;  // Preserve column grouping
                const columnX = -reverseColumn * CONFIG.DAA_COLUMN_WIDTH;

                // Get block index within column for Y positioning
                const columnKey = column;
                const blockIndexInColumn = State.dagColumnCount.get(columnKey) || 0;
                State.dagColumnCount.set(columnKey, blockIndexInColumn + 1);

                // Calculate Y: 0, +20, -20, +40, -40, ... (scaled for high BPS)
                let blockY;
                if (blockIndexInColumn === 0) {
                    blockY = 0;
                } else {
                    const offset = Math.ceil(blockIndexInColumn / 2) * CONFIG.Y_STEP * yScale;
                    const direction = (blockIndexInColumn % 2 === 1) ? 1 : -1;
                    blockY = offset * direction;
                }

                // Spawn slightly right of target for left-sliding animation
                State.blockData.x[index] = columnX + 30;
                State.blockData.targetX[index] = columnX;
                State.blockData.y[index] = blockY;
                State.blockData.targetY[index] = blockY;
            } else {
                // Linear mode: X at spawn area (will be updated by linearization)
                const tipOffset = 10 + Math.random() * 30;
                State.blockData.x[index] = CONFIG.SPAWN_X + tipOffset;
                State.blockData.targetX[index] = State.blockData.x[index];

                const randomY = (Math.random() - 0.5) * 300 * yScale;
                State.blockData.y[index] = randomY;
                State.blockData.targetY[index] = randomY;
            }
            State.blockData.linearIndex[index] = -1;  // Not linearized yet

            // Store blueScore, blueWork, and bits for Dagknight calculation
            State.blockData.blueScore[index] = Number(blockInfo.header.blueScore || 0);
            State.blockData.blueWork[index] = blockInfo.header.blueWork || '0';
            State.blockData.bits[index] = Number(blockInfo.header.bits || 0);

            // Color: Start as Pending (gray), will be confirmed when child arrives
            State.blockData.color[index] = CONFIG.COLORS.PENDING_BLOCK;
            State.blockData.confirmationState[index] = 0;  // 0 = Pending
            State.blockData.isBlue[index] = 1;  // Default to blue (will be updated)
            State.blockData.size[index] = CONFIG.BLOCK_SIZE;

            // Store parent hashes (resolved dynamically in renderDAG)
            // WASM SDK uses parentsByLevel - only use level 0 (direct parents)
            const parentsByLevel = blockInfo.header.parentsByLevel || [];
            const parents = [...(parentsByLevel[0] || [])];  // Copy to avoid mutation

            // Phase 3: Add dummy tips as additional parents (high BPS simulation)
            // Dynamic limit: MULTIPLIER * 2 to balance generation/consumption rate
            // 2x: 2 parents, 3x: 4 parents, 10x: 18 parents
            // DAA distance requirement: dummy must be at least 4 DAA behind current block
            if (CONFIG.DUMMY.ENABLED && State.dummyTips.size > 0) {
                const dummyParentsToAdd = [];
                let addedCount = 0;
                const dynamicLimit = 4;  // Fixed: max 4 dummy parents per block
                const minDaaDist = 1;  // Minimum DAA distance for dummy parent

                for (const [dummyHash, selectCount] of State.dummyTips) {
                    // Limit dummy parents per block (dynamic based on multiplier)
                    if (addedCount >= dynamicLimit) break;

                    // Check DAA distance - dummy must be old enough
                    const dummyIdx = State.blockHashToIndex.get(dummyHash);
                    if (dummyIdx !== undefined) {
                        const dummyDaa = State.blockData.daaScore[dummyIdx];
                        if (daaScore - dummyDaa < minDaaDist) {
                            continue;  // Skip - dummy is too recent
                        }
                    }

                    // Add dummy as parent
                    dummyParentsToAdd.push(dummyHash);
                    addedCount++;

                    // Increment select count
                    const newCount = selectCount + 1;
                    if (newCount >= CONFIG.DUMMY.MAX_PARENT_SELECT) {
                        // Remove from tips (has been selected enough times)
                        State.dummyTips.delete(dummyHash);
                    } else {
                        State.dummyTips.set(dummyHash, newCount);
                    }
                }
                // Add limited dummy parents to the block's parents
                parents.push(...dummyParentsToAdd);
            }

            State.blockData.parentHashes[index] = parents;

            // Dagknight: Block starts as Pending (gray)
            // Actual blue/red coloring is computed in updateDagknight() every 0.5s
            // This keeps addBlock() lightweight for high BPS

            // Update ring buffer
            State.ringHead = (State.ringHead + 1) % CONFIG.MAX_BLOCKS;
            if (State.blockCount < CONFIG.MAX_BLOCKS) {
                State.blockCount++;
            }

            // Viewport stays at center (0, 0) - no need to update
            // Note: blockCount DOM update moved to updateStatsDisplay (1/sec instead of per-block)
        }

        // ------------------------------------------------------------
        // Kaspa SDK Integration
        // ------------------------------------------------------------
        async function initKaspaSDK() {
            updateLoadingText('Loading Kaspa SDK...');

            try {
                // Dynamic import of local Kaspa WASM SDK
                const kaspa = await import('./kaspa-core.js');

                // Initialize WASM binary
                await kaspa.default({ module_or_path: './kaspa-core_bg.wasm' });

                // Store kaspa module in state for later use
                State.kaspa = kaspa;

                updateLoadingText('Connecting to network...');

                // Create RPC client
                const resolver = new kaspa.Resolver();
                State.rpcClient = new kaspa.RpcClient({
                    resolver,
                    networkId: 'mainnet',
                });

                // Connect
                await State.rpcClient.connect();

                // Get initial info
                const info = await State.rpcClient.getBlockDagInfo();

                // Update UI
                State.isConnected = true;
                DOM.status.classList.add('connected');
                DOM.connectionStatus.textContent = 'Connected';
                DOM.networkName.textContent = 'Mainnet';

                // Subscribe to new blocks
                await subscribeToBlocks();

                return kaspa;
            } catch (error) {
                console.error('Failed to initialize Kaspa SDK:', error);
                DOM.connectionStatus.textContent = 'Error: ' + error.message;
                throw error;
            }
        }

        async function subscribeToBlocks() {
            updateLoadingText('Subscribing to blocks...');

            // Subscribe to block added notifications
            State.rpcClient.addEventListener('block-added', async (event) => {
                try {
                    const block = event.data.block;

                    // During pause: buffer blocks (up to 5 seconds worth)
                    if (State.isPaused) {
                        if (!State.pauseExpired) {
                            State.pauseBuffer.push(block);
                        }
                        return;
                    }

                    // block-added event already contains full block info
                    addBlock(block);

                    // Generate dummy blocks for high BPS simulation (Phase 2)
                    generateDummyBlocks(block);
                } catch (error) {
                    console.warn('Failed to process block:', error);
                }
            });

            // Start subscription
            await State.rpcClient.subscribeBlockAdded();
        }

        // ------------------------------------------------------------
        // UI Updates
        // ------------------------------------------------------------
        function updateLoadingText(text) {
            DOM.loadingText.textContent = text;
        }

        function hideLoading() {
            DOM.loading.classList.add('hidden');
        }

        // Update block info panel (pause mode only)
        function updateBlockInfo() {
            const idx = State.selectedBlockIndex;
            if (idx === null || !State.blockData.hashes[idx]) {
                DOM.infoHash.textContent = '-';
                DOM.infoDaa.textContent = '-';
                DOM.infoBlueScore.textContent = '-';
                DOM.infoBlueWork.textContent = '-';
                DOM.blockInfo.classList.remove('clickable');
                DOM.infoHint.textContent = 'Tap a block to inspect';
                return;
            }
            const hash = State.blockData.hashes[idx];
            const daaScore = State.blockData.daaScore[idx];
            const blueScore = State.blockData.blueScore[idx];
            const blueWork = State.blockData.blueWork[idx] || '0';

            // Hash: full display
            DOM.infoHash.textContent = hash;
            DOM.infoDaa.textContent = daaScore.toLocaleString();
            DOM.infoBlueScore.textContent = blueScore.toLocaleString();
            DOM.infoBlueWork.textContent = blueWork;

            // Enable link to kaspa.stream (only for real blocks)
            if (isDummyHash(hash)) {
                DOM.blockInfo.classList.remove('clickable');
                DOM.infoHint.textContent = '';  // No hint for dummy blocks
            } else {
                DOM.blockInfo.classList.add('clickable');
                DOM.infoHint.textContent = 'Tap to view on kaspa.stream';
            }
        }

        function updateStatsDisplay() {
            // Block count
            DOM.blockCount.textContent = State.blockCount;

            // DAA Score (latest)
            DOM.daaScore.textContent = State.maxDaaScore !== null
                ? State.maxDaaScore.toLocaleString()
                : '-';

            // Debug display: FPS + version + interval + K info + hierarchical + gray_work
            if (DOM.debugInfo) {
                const kd = State.dagknight.kDebug;
                const hd = State.dagknight.hierDebug;
                const kVal = State.dagknight.lastK ?? '-';
                let html = `${State.stats.fps} FPS ${State.adaptiveInterval}ms<br>${CONFIG.VERSION}<br>`;
                if (kd && kd.blueWork !== undefined) {
                    // K info + hierarchical info
                    const iter = hd?.iterations ?? 0;
                    const grps = hd?.groups ?? 0;
                    const totalTips = hd?.totalTips ?? kd.tips;
                    html += `K=${kVal} tips:${totalTips}/${kd.tips} zone:${kd.zone} iter:${iter} grps:${grps}<br>`;
                    // Work values (shortened for display)
                    const blue = Number(kd.blueWork / 1000000n);
                    const red = Number(kd.redWork / 1000000n);
                    const gray = Number((kd.grayWork || 0n) / 1000000n);
                    html += `B:${blue}M R:${red}M G:${gray}M<br>`;
                    // Viewport debug
                    const vp = State.viewport;
                    const st = State.stats;
                    html += `vpX:${Math.round(vp.x)} z:${vp.zoom.toFixed(1)} w:${vp.width}<br>`;
                    html += `vis:${st.visibleBlocks} edges:${st.edgeCount}`;
                }
                DOM.debugInfo.innerHTML = html;
            }

            // Check legend collision with dummy-controls
            if (DOM.legend && DOM.dummyControls) {
                const legendRect = DOM.legend.getBoundingClientRect();
                const controlsRect = DOM.dummyControls.getBoundingClientRect();
                // Hide legend if it overlaps with dummy-controls
                const overlaps = !(legendRect.right < controlsRect.left ||
                                   legendRect.left > controlsRect.right ||
                                   legendRect.bottom < controlsRect.top ||
                                   legendRect.top > controlsRect.bottom);
                DOM.legend.style.display = overlaps ? 'none' : 'flex';
            }
        }

        // ------------------------------------------------------------
        // Controls
        // ------------------------------------------------------------
        function setupControls() {
            DOM.btnDisconnect.addEventListener('click', async () => {
                if (State.isConnected && State.rpcClient) {
                    try {
                        await State.rpcClient.disconnect();
                        State.isConnected = false;
                        DOM.connectionStatus.textContent = 'Disconnected';
                        DOM.connectionStatus.className = 'disconnected';
                        DOM.status.classList.remove('connected');
                        DOM.btnDisconnect.textContent = 'Connect';
                    } catch (e) {
                        console.error('Disconnect error:', e);
                    }
                } else {
                    // Full reconnect with complete state reset
                    try {
                        DOM.connectionStatus.textContent = 'Connecting...';
                        DOM.btnDisconnect.disabled = true;

                        // Clear all block state
                        State.blockCount = 0;
                        State.ringHead = 0;
                        State.ringTail = 0;
                        State.blockHashToIndex.clear();
                        State.viewport.x = 0;
                        State.viewport.y = 0;
                        State.viewport.targetX = 0;
                        DOM.blockCount.textContent = '0';

                        // Reset pause state
                        State.isPaused = false;
                        State.pauseStartTime = null;
                        State.pauseBuffer = [];
                        State.pauseExpired = false;
                        State.selectedBlockIndex = null;
                        DOM.btnPause.disabled = false;
                        DOM.btnPause.textContent = 'Pause';
                        DOM.blockInfo.classList.remove('visible');

                        // Reset DAG state
                        State.minDaaScore = null;
                        State.maxDaaScore = null;
                        State.dagColumnCount.clear();
                        State.selectedChainEdges = [];
                        State.confirmedChainEdges.clear();
                        State.selectedChainBlocks = new Set();
                        State.linearOrder = [];
                        State.lccaHash = null;
                        State.sortedIndices = [];

                        // Reset dummy state
                        State.dummyTips.clear();
                        State.dummyBlockCount = 0;

                        // Reset Dagknight coloring
                        State.dagknight.conflictZone.blocks.clear();
                        State.dagknight.cascadeTree.pastBlues.clear();
                        State.dagknight.cascadeTree.pastReds.clear();
                        State.dagknight.cascadeTree.anticoneBlues.clear();
                        State.dagknight.cascadeTree.arlb.clear();
                        State.dagknight.cascadeTree.floor.clear();
                        State.dagknight.bluesAnticoneSizes.clear();
                        State.dagknight.mergesetBlues.clear();
                        State.dagknight.mergesetReds.clear();
                        State.dagknight.coloringK.clear();
                        State.dagknight.ancestorCache.clear();
                        State.dagknight.kColouringCache.clear();
                        State.selectedParentCache.clear();

                        // Create new RPC client
                        const resolver = new State.kaspa.Resolver();
                        State.rpcClient = new State.kaspa.RpcClient({
                            resolver,
                            networkId: 'mainnet',
                        });

                        await State.rpcClient.connect();
                        await subscribeToBlocks();

                        State.isConnected = true;
                        DOM.connectionStatus.textContent = 'Connected';
                        DOM.connectionStatus.className = 'connected';
                        DOM.status.classList.add('connected');
                        DOM.btnDisconnect.textContent = 'Disconnect';
                        DOM.btnDisconnect.disabled = false;
                    } catch (e) {
                        console.error('Connect error:', e);
                        DOM.connectionStatus.textContent = 'Error: ' + e.message;
                        DOM.btnDisconnect.textContent = 'Retry';
                        DOM.btnDisconnect.disabled = false;
                    }
                }
            });

            DOM.btnPause.addEventListener('click', () => {
                if (!State.isPaused) {
                    // --- PAUSE ---
                    State.isPaused = true;
                    State.pauseStartTime = Date.now();
                    State.pauseBuffer = [];
                    State.pauseExpired = false;
                    State.selectedBlockIndex = null;
                    DOM.btnPause.textContent = 'Resume (5s)';

                    // Run Dagknight calculation once to connect tips
                    runDagknightCalculation();
                    DOM.blockInfo.classList.add('visible');
                    updateBlockInfo();

                    // Start countdown timer
                    let remaining = 5;
                    const countdownInterval = setInterval(() => {
                        if (!State.isPaused) {
                            clearInterval(countdownInterval);
                            return;
                        }
                        remaining--;
                        if (remaining > 0) {
                            DOM.btnPause.textContent = `Resume (${remaining}s)`;
                        } else {
                            // 5 seconds expired
                            State.pauseExpired = true;
                            DOM.btnPause.textContent = 'Expired';
                            DOM.btnPause.disabled = true;
                            clearInterval(countdownInterval);
                        }
                    }, 1000);
                } else {
                    // --- RESUME ---
                    if (State.pauseExpired) {
                        // Cannot resume after 5 seconds - use Clear
                        return;
                    }

                    // Process buffered blocks quickly
                    const bufferedBlocks = State.pauseBuffer;
                    State.pauseBuffer = [];
                    State.isPaused = false;
                    State.pauseStartTime = null;
                    State.selectedBlockIndex = null;
                    DOM.btnPause.textContent = 'Pause';
                    DOM.blockInfo.classList.remove('visible');

                    // Add all buffered blocks
                    for (const block of bufferedBlocks) {
                        addBlock(block);
                        generateDummyBlocks(block);
                    }
                }
            });

            DOM.btnReset.addEventListener('click', () => {
                // Clear all blocks
                State.blockCount = 0;
                State.ringHead = 0;
                State.ringTail = 0;
                State.blockHashToIndex.clear();
                State.viewport.x = 0;
                State.viewport.y = 0;
                DOM.blockCount.textContent = '0';

                // Reset pause state
                State.isPaused = false;
                State.pauseStartTime = null;
                State.pauseBuffer = [];
                State.pauseExpired = false;
                State.selectedBlockIndex = null;
                DOM.btnPause.disabled = false;
                DOM.btnPause.textContent = 'Pause';
                DOM.blockInfo.classList.remove('visible');

                // Reset DAG state
                State.minDaaScore = null;
                State.maxDaaScore = null;
                State.dagColumnCount.clear();
                State.selectedChainEdges = [];
                State.confirmedChainEdges.clear();
                State.selectedChainBlocks = new Set();
                State.linearOrder = [];
                State.lccaHash = null;
                State.sortedIndices = [];
            });

            // Block info panel click -> open kaspa.stream (only for real blocks)
            DOM.blockInfo.addEventListener('click', () => {
                const idx = State.selectedBlockIndex;
                if (idx === null || !State.blockData.hashes[idx]) return;
                const hash = State.blockData.hashes[idx];
                if (isDummyHash(hash)) return;  // Don't open for dummy blocks
                window.open(`https://kaspa.stream/blocks/${hash}`, '_blank');
            });

            // Zoom with X=0 (right edge) as anchor point
            function zoomWithRightAnchor(newZoom) {
                // X=0 stays at right edge when vpX=0, so just change zoom
                // No viewport adjustment needed
                State.viewport.zoom = newZoom;
            }

            DOM.btnZoomIn.addEventListener('click', () => {
                const newZoom = Math.min(State.viewport.zoom * 1.2, 3);
                zoomWithRightAnchor(newZoom);
            });

            DOM.btnZoomOut.addEventListener('click', () => {
                const newZoom = Math.max(State.viewport.zoom / 1.2, 0.2);
                zoomWithRightAnchor(newZoom);
            });

            // Dummy block simulation controls
            function updateDummyUI() {
                // Update toggle button
                DOM.btnDummyToggle.textContent = CONFIG.DUMMY.ENABLED ? 'ON' : 'OFF';
                DOM.btnDummyToggle.classList.toggle('active', CONFIG.DUMMY.ENABLED);

                // Update multiplier buttons
                const mult = CONFIG.DUMMY.MULTIPLIER;
                DOM.btnDummy30bps.classList.toggle('selected', mult === 2);
                DOM.btnDummy100bps.classList.toggle('selected', mult === 9);
            }

            DOM.btnDummyToggle.addEventListener('click', () => {
                CONFIG.DUMMY.ENABLED = !CONFIG.DUMMY.ENABLED;
                // Reset adaptive interval to new mode's base
                const intervalConfig = CONFIG.DUMMY.ENABLED
                    ? CONFIG.UPDATE_INTERVAL_30BPS
                    : CONFIG.UPDATE_INTERVAL_10BPS;
                State.adaptiveInterval = intervalConfig.base;
                updateDummyUI();
            });

            DOM.btnDummy30bps.addEventListener('click', () => {
                CONFIG.DUMMY.MULTIPLIER = 2;  // 10BPS × 3 = 30BPS
                updateDummyUI();
            });

            DOM.btnDummy100bps.addEventListener('click', () => {
                // 100BPS is disabled - show development message (non-blocking)
                const btn = DOM.btnDummy100bps;
                const originalText = btn.textContent;
                btn.textContent = 'Coming Soon!';
                setTimeout(() => { btn.textContent = originalText; }, 1500);
            });

            // View mode controls
            function updateViewModeUI() {
                DOM.btnViewLinear.classList.toggle('selected', CONFIG.VIEW_MODE === 'linear');
                DOM.btnViewDag.classList.toggle('selected', CONFIG.VIEW_MODE === 'dag');
            }

            function switchViewMode(mode) {
                CONFIG.VIEW_MODE = mode;
                updateViewModeUI();

                if (mode === 'dag') {
                    // Reset column counts for DAG mode
                    State.dagColumnCount.clear();

                    // First pass: count blocks per column
                    const columnBlocks = new Map();  // column -> [indices]
                    for (let i = 0; i < State.blockCount; i++) {
                        const hash = State.blockData.hashes[i];
                        if (!hash) continue;
                        const daaScore = State.blockData.daaScore[i];
                        const column = Math.floor((daaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                        if (!columnBlocks.has(column)) columnBlocks.set(column, []);
                        columnBlocks.get(column).push(i);
                    }

                    // Second pass: assign X/Y positions
                    // Apply yScale for high BPS simulation
                    // Newest blocks near X=0 (right edge), older blocks have negative X
                    const yScale = CONFIG.DUMMY.ENABLED ? (CONFIG.DUMMY.MULTIPLIER <= 2 ? 1.5 : 2.0) : 1.0;
                    const maxColumn = Math.floor((State.maxDaaScore - State.minDaaScore) / CONFIG.DAA_GROUP);
                    for (const [column, indices] of columnBlocks) {
                        const reverseColumn = maxColumn - column;
                        const columnX = -reverseColumn * CONFIG.DAA_COLUMN_WIDTH;
                        indices.forEach((idx, blockIndexInColumn) => {
                            // Calculate Y: 0, +20, -20, +40, -40, ... (scaled for high BPS)
                            let blockY;
                            if (blockIndexInColumn === 0) {
                                blockY = 0;
                            } else {
                                const offset = Math.ceil(blockIndexInColumn / 2) * CONFIG.Y_STEP * yScale;
                                const direction = (blockIndexInColumn % 2 === 1) ? 1 : -1;
                                blockY = offset * direction;
                            }
                            State.blockData.targetX[idx] = columnX;
                            State.blockData.targetY[idx] = blockY;
                        });
                        State.dagColumnCount.set(column, indices.length);
                    }

                    // Viewport stays at 0 (X=0 at right edge)
                    State.viewport.targetX = 0;
                } else {
                    // Linear mode: calculate correct positions using linearOrder
                    const linearOrder = State.linearOrder || [];
                    const maxLinearIdx = linearOrder.length - 1;
                    const SPAWN_X = CONFIG.SPAWN_X;

                    // Build hash→linearIndex map
                    const linearOrderMap = new Map();
                    for (let idx = 0; idx < linearOrder.length; idx++) {
                        linearOrderMap.set(linearOrder[idx], idx);
                    }

                    for (let i = 0; i < State.blockCount; i++) {
                        const hash = State.blockData.hashes[i];
                        if (!hash) continue;

                        const linearIdx = linearOrderMap.has(hash) ? linearOrderMap.get(hash) : -1;

                        if (linearIdx !== -1) {
                            // Linearized block - proper chain position
                            const newX = SPAWN_X - (maxLinearIdx - linearIdx) * CONFIG.LINEAR_PITCH;
                            State.blockData.targetX[i] = newX;
                            State.blockData.x[i] = newX;  // Instant X (prevent fly-off)
                            State.blockData.targetY[i] = 0;
                            // Y animates via lerp (smooth convergence to chain)
                            State.blockData.linearIndex[i] = linearIdx;
                        } else {
                            // Not linearized - spawn area
                            const newX = SPAWN_X + 20;
                            State.blockData.targetX[i] = newX;
                            State.blockData.x[i] = newX;  // Instant X (prevent fly-off)
                            State.blockData.targetY[i] = 0;
                            // Y animates via lerp
                        }
                    }
                    State.viewport.targetX = 0;
                    State.viewport.x = 0;  // Instant viewport
                }
            }

            DOM.btnViewLinear.addEventListener('click', () => switchViewMode('linear'));
            DOM.btnViewDag.addEventListener('click', () => switchViewMode('dag'));

            // Pan with mouse drag
            let isDragging = false;
            let lastMouse = { x: 0, y: 0 };
            let lastPinchDist = 0;
            let touchStartPos = null;  // For tap detection

            // Mouse events (desktop)
            State.app.canvas.addEventListener('mousedown', (e) => {
                isDragging = true;
                lastMouse = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mousemove', (e) => {
                if (!isDragging) return;
                const dx = (e.clientX - lastMouse.x) / State.viewport.zoom;
                const dy = (e.clientY - lastMouse.y) / State.viewport.zoom;
                State.viewport.x -= dx;
                State.viewport.y -= dy;
                State.viewport.targetX = State.viewport.x;
                lastMouse = { x: e.clientX, y: e.clientY };
            });

            window.addEventListener('mouseup', () => {
                isDragging = false;
            });

            // Touch events (mobile)
            State.app.canvas.addEventListener('touchstart', (e) => {
                e.preventDefault();
                if (e.touches.length === 1) {
                    isDragging = true;
                    lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                    touchStartPos = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2) {
                    // Pinch zoom start
                    isDragging = false;
                    touchStartPos = null;
                    const dx = e.touches[1].clientX - e.touches[0].clientX;
                    const dy = e.touches[1].clientY - e.touches[0].clientY;
                    lastPinchDist = Math.sqrt(dx * dx + dy * dy);
                }
            }, { passive: false });

            State.app.canvas.addEventListener('touchmove', (e) => {
                e.preventDefault();
                if (e.touches.length === 1 && isDragging) {
                    // Single finger drag
                    const dx = (e.touches[0].clientX - lastMouse.x) / State.viewport.zoom;
                    const dy = (e.touches[0].clientY - lastMouse.y) / State.viewport.zoom;
                    State.viewport.x -= dx;
                    State.viewport.y -= dy;
                    State.viewport.targetX = State.viewport.x;
                    lastMouse = { x: e.touches[0].clientX, y: e.touches[0].clientY };
                } else if (e.touches.length === 2 && lastPinchDist > 0) {
                    // Pinch zoom
                    const dx = e.touches[1].clientX - e.touches[0].clientX;
                    const dy = e.touches[1].clientY - e.touches[0].clientY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    const scale = dist / lastPinchDist;
                    const newZoom = Math.max(0.2, Math.min(3, State.viewport.zoom * scale));
                    zoomWithRightAnchor(newZoom);
                    lastPinchDist = dist;
                }
            }, { passive: false });

            State.app.canvas.addEventListener('touchend', (e) => {
                // Detect tap (no significant movement) for block selection
                if (State.isPaused && touchStartPos && e.changedTouches.length === 1) {
                    const endX = e.changedTouches[0].clientX;
                    const endY = e.changedTouches[0].clientY;
                    const moveDist = Math.sqrt(
                        Math.pow(endX - touchStartPos.x, 2) +
                        Math.pow(endY - touchStartPos.y, 2)
                    );

                    // If moved less than 10px, treat as tap
                    if (moveDist < 10) {
                        const rect = State.app.canvas.getBoundingClientRect();
                        const tapX = endX - rect.left;
                        const tapY = endY - rect.top;

                        // Convert screen coords to world coords
                        const { zoom, width, height, x: vpX, y: vpY } = State.viewport;
                        const halfWidth = width / 2;
                        const halfHeight = height / 2;
                        const worldX = (tapX - halfWidth) / zoom + vpX;
                        const worldY = (tapY - halfHeight) / zoom + vpY;

                        // Hit test: find nearest block within radius
                        const hitRadius = CONFIG.BLOCK_SIZE_VIRTUAL * 2;  // Larger radius for touch
                        let foundIdx = null;
                        let minDist = hitRadius;

                        const { x, y, hashes } = State.blockData;
                        for (let i = 0; i < State.blockCount; i++) {
                            if (!hashes[i]) continue;
                            const dx = x[i] - worldX;
                            const dy = y[i] - worldY;
                            const dist = Math.sqrt(dx * dx + dy * dy);
                            if (dist < minDist) {
                                minDist = dist;
                                foundIdx = i;
                            }
                        }

                        State.selectedBlockIndex = foundIdx;
                        updateBlockInfo();
                    }
                }

                isDragging = false;
                lastPinchDist = 0;
                touchStartPos = null;
            });

            // Zoom with mouse wheel (right edge anchor)
            State.app.canvas.addEventListener('wheel', (e) => {
                e.preventDefault();
                const zoomFactor = e.deltaY > 0 ? 0.9 : 1.1;
                const newZoom = Math.max(0.2, Math.min(3, State.viewport.zoom * zoomFactor));
                zoomWithRightAnchor(newZoom);
            });

            // Block selection (pause mode only) - click handler
            State.app.canvas.addEventListener('click', (e) => {
                if (!State.isPaused) return;

                const rect = State.app.canvas.getBoundingClientRect();
                const clickX = e.clientX - rect.left;
                const clickY = e.clientY - rect.top;

                // Convert screen coords to world coords
                const { zoom, width, height, x: vpX, y: vpY } = State.viewport;
                const halfWidth = width / 2;
                const halfHeight = height / 2;
                const worldX = (clickX - halfWidth) / zoom + vpX;
                const worldY = (clickY - halfHeight) / zoom + vpY;

                // Hit test: find nearest block within radius
                const hitRadius = CONFIG.BLOCK_SIZE_VIRTUAL / zoom;
                let foundIdx = null;
                let minDist = hitRadius;

                const { x, y, hashes } = State.blockData;
                for (let i = 0; i < State.blockCount; i++) {
                    if (!hashes[i]) continue;
                    const dx = x[i] - worldX;
                    const dy = y[i] - worldY;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist < minDist) {
                        minDist = dist;
                        foundIdx = i;
                    }
                }

                State.selectedBlockIndex = foundIdx;
                updateBlockInfo();
            });
        }

        // ------------------------------------------------------------
        // Tutorial System
        // ------------------------------------------------------------
        const Tutorial = {
            currentStep: 0,
            isOpen: false,
            wasPlaying: false,  // Track if we were playing before tutorial

            steps: [
                // Step 1: Hook
                {
                    title: '10 blocks per second.',
                    content: '<p>This blockchain creates blocks <strong>6000x faster</strong> than Bitcoin.</p><p>You\'re watching it live.</p>',
                    highlight: null,
                },
                // Step 2: Problem
                {
                    title: 'But there\'s a problem.',
                    content: '<p>When blocks are created this fast, multiple blocks are born at the same time.</p><p>They don\'t know about each other. If we sort them by parent-child...</p>',
                    highlight: null,
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'linear') {
                            DOM.btnViewLinear.click();
                        }
                    }
                },
                // Step 3: Show DAG
                {
                    title: 'Look. They\'re parallel.',
                    content: '<p>See the parallel structure?</p><p>Which is the correct <strong>order</strong>?</p>',
                    highlight: null,
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'dag') {
                            DOM.btnViewDag.click();
                        }
                    }
                },
                // Step 4: Answer
                {
                    title: 'The answer: first, include everything.',
                    content: '<p>Don\'t throw away any blocks.</p><p>Decide the <strong>order</strong> later.</p>',
                    highlight: null,
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'dag') DOM.btnViewDag.click();
                    }
                },
                // Step 5: Block inclusion
                {
                    title: 'Block inclusion states',
                    content: '<p><span class="highlight-gray">⬜ Gray</span> = just arrived, pending.</p><p><span class="highlight-blue">🟦 Blue</span> = honest block, participates in ordering.</p><p><span class="highlight-red">🟥 Red</span> = possibly from attacker or delayed. Included but excluded from ordering.</p><p>All blocks are in the DAG, but only blue blocks decide transaction order.</p>',
                    highlight: 'legend',
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'dag') DOM.btnViewDag.click();
                    }
                },
                // Step 6: Start ordering
                {
                    title: 'Let\'s start ordering.',
                    content: '<p>First, find what\'s trustworthy.</p><p>Follow the "heaviest" route — most work. This is the <span class="highlight-green">🟩 Selected Chain</span>.</p><p>Blocks on it are shown <strong>larger</strong>.</p>',
                    highlight: 'legend',
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'dag') DOM.btnViewDag.click();
                    }
                },
                // Step 7: Gold = all paths agree
                {
                    title: 'Where all paths agree.',
                    content: '<p>The <span class="highlight-gold">🟨 gold block</span> is where all green paths converge.</p><p>This is the <strong>Latest Common Chain Ancestor</strong> — all tips agree this is their shared ancestor.</p>',
                    highlight: 'legend',
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'dag') DOM.btnViewDag.click();
                    }
                },
                // Step 8: Linearization
                {
                    title: 'Making it a single line.',
                    content: '<p><span class="highlight-green">🟩 Green</span> = active chain, still changing. <span class="highlight-blue">🟦 Blue</span> = confirmed, finalized.</p><p>Large blocks place smaller ones to their left, creating a <strong>total order</strong>.</p>',
                    highlight: null,
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'dag') DOM.btnViewDag.click();
                    }
                },
                // Step 9: Result
                {
                    title: 'See them line up.',
                    content: '<p>Lined up in a <strong>mathematically provable</strong> order.</p><p>All those parallel blocks → one ordered sequence.</p>',
                    highlight: 'view-mode-controls',
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'linear') DOM.btnViewLinear.click();
                    }
                },
                // Step 10: Conclusion
                {
                    title: 'This is Dagknight.',
                    content: '<p>Fast <strong>and</strong> secure. No central authority.</p><p><a href="https://eprint.iacr.org/2022/1494" target="_blank">📄 Whitepaper</a> · <a href="https://github.com/coderofstuff/rusty-kaspa/tree/dkoder" target="_blank">💻 dkoder (GitHub)</a></p>',
                    highlight: null,
                    action: () => {
                        if (CONFIG.VIEW_MODE !== 'linear') DOM.btnViewLinear.click();
                    }
                },
                // Step 11: Block Info
                {
                    title: 'Want to see more?',
                    content: '<p>Press <strong>Pause</strong> and tap any block.</p><p>You can see its hash, DAA score, and more in the <strong>Block Info</strong> panel.</p>',
                    highlight: 'controls',
                    action: null
                },
                // Step 12: BPS Simulator
                {
                    title: 'Experience 30 BPS.',
                    content: '<p>Turn on the <strong>BPS Simulator</strong> to experience what 30 blocks per second looks like.</p><p>This is the future of Kaspa.</p>',
                    highlight: 'dummy-controls',
                    final: true,
                    action: null
                }
            ],

            open() {
                this.currentStep = 0;
                this.isOpen = true;
                this.wasPlaying = !State.isPaused;
                DOM.tutorialOverlay.classList.add('visible');
                DOM.tutorialModal.classList.add('visible');
                State.tutorialStep = 0;
                this.render();
            },

            close() {
                this.isOpen = false;
                State.tutorialStep = -1;
                DOM.tutorialOverlay.classList.remove('visible');
                DOM.tutorialModal.classList.remove('visible');
                this.clearHighlight();
                // Resume if we were playing before
                if (this.wasPlaying && State.isPaused) {
                    DOM.btnPause.click();
                }
            },

            next() {
                if (this.currentStep < this.steps.length - 1) {
                    this.currentStep++;
                    this.render();
                } else {
                    this.close();
                }
            },

            back() {
                if (this.currentStep === 0) {
                    this.close();
                } else {
                    this.currentStep--;
                    this.render();
                }
            },

            render() {
                const step = this.steps[this.currentStep];
                State.tutorialStep = this.currentStep;

                // Update step indicators
                document.querySelectorAll('#tutorial-modal .step-dot').forEach((dot, i) => {
                    dot.classList.remove('active', 'completed');
                    if (i < this.currentStep) dot.classList.add('completed');
                    if (i === this.currentStep) dot.classList.add('active');
                });

                // Update content
                DOM.tutorialContent.innerHTML = `
                    <h2>${step.title}</h2>
                    ${step.content}
                `;

                // Update buttons
                if (this.currentStep === 0) {
                    DOM.tutorialBack.textContent = 'Close';
                } else {
                    DOM.tutorialBack.textContent = '← Back';
                }

                if (step.final) {
                    DOM.tutorialNext.textContent = 'Close';
                    DOM.tutorialNext.className = 'btn btn-primary';
                } else {
                    DOM.tutorialNext.textContent = 'Next →';
                    DOM.tutorialNext.className = 'btn btn-primary';
                }

                // Execute step action
                if (step.action) {
                    step.action();
                }

                // Apply highlight (supports array)
                this.clearHighlight();
                if (step.highlight) {
                    const highlights = Array.isArray(step.highlight) ? step.highlight : [step.highlight];
                    for (const id of highlights) {
                        const el = document.getElementById(id);
                        if (el) {
                            el.classList.add('tutorial-spotlight');
                        }
                    }
                }
            },

            clearHighlight() {
                document.querySelectorAll('.tutorial-spotlight').forEach(el => {
                    el.classList.remove('tutorial-spotlight');
                });
            }
        };

        // Tutorial event listeners
        DOM.tutorialBtn.addEventListener('click', () => {
            DOM.tutorialBtn.classList.add('clicked');
            Tutorial.open();
        });
        DOM.tutorialOverlay.addEventListener('click', () => Tutorial.close());
        DOM.tutorialBack.addEventListener('click', () => Tutorial.back());
        DOM.tutorialNext.addEventListener('click', () => Tutorial.next());

        // Close on Escape key
        document.addEventListener('keydown', (e) => {
            if (e.key === 'Escape' && Tutorial.isOpen) {
                Tutorial.close();
            }
        });

        // ------------------------------------------------------------
        // Main
        // ------------------------------------------------------------
        async function main() {
            try {
                await initPixi();
                setupControls();
                await initKaspaSDK();
                hideLoading();
            } catch (error) {
                console.error('Initialization failed:', error);
                updateLoadingText('Error: ' + error.message);
            }
        }

        // Start
        main();
    </script>
</body>
</html>
